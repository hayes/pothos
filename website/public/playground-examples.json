[
  {
    "id": "basic-types",
    "title": "Basic Types",
    "description": "Define object types and queries",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\n\nconst builder = new SchemaBuilder({});\n\n// Define a simple User type\nconst User = builder.objectRef<{\n  id: string;\n  name: string;\n  email: string;\n}>('User');\n\nbuilder.objectType(User, {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    name: t.exposeString('name'),\n    email: t.exposeString('email'),\n  }),\n});\n\n// Define Query type\nbuilder.queryType({\n  fields: (t) => ({\n    hello: t.string({\n      args: {\n        name: t.arg.string({ required: false }),\n      },\n      resolve: (_, args) => `Hello, ${args.name ?? 'World'}!`,\n    }),\n    user: t.field({\n      type: User,\n      args: {\n        id: t.arg.id({ required: true }),\n      },\n      resolve: (_, args) => ({\n        id: args.id,\n        name: 'John Doe',\n        email: 'john@example.com',\n      }),\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "query {\n  hello(name: \"Pothos\")\n  user(id: \"1\") {\n    id\n    name\n    email\n  }\n}"
  },
  {
    "id": "enums-args",
    "title": "Enums & Arguments",
    "description": "Define enums and use typed arguments",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\n\nconst builder = new SchemaBuilder({});\n\n// Define an enum\nconst Status = builder.enumType('Status', {\n  values: ['DRAFT', 'PUBLISHED', 'ARCHIVED'] as const,\n});\n\n// Define a Post type using the enum\nconst Post = builder.objectRef<{\n  id: string;\n  title: string;\n  status: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';\n}>('Post');\n\nbuilder.objectType(Post, {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    title: t.exposeString('title'),\n    status: t.field({\n      type: Status,\n      resolve: (post) => post.status,\n    }),\n  }),\n});\n\n// Sample data\nconst posts = [\n  { id: '1', title: 'Hello World', status: 'PUBLISHED' as const },\n  { id: '2', title: 'Draft Post', status: 'DRAFT' as const },\n  { id: '3', title: 'Old News', status: 'ARCHIVED' as const },\n];\n\nbuilder.queryType({\n  fields: (t) => ({\n    posts: t.field({\n      type: [Post],\n      args: {\n        status: t.arg({ type: Status, required: false }),\n        limit: t.arg.int({ required: false }),\n      },\n      resolve: (_, args) => {\n        let result = posts;\n        if (args.status) {\n          result = result.filter((p) => p.status === args.status);\n        }\n        if (args.limit) {\n          result = result.slice(0, args.limit);\n        }\n        return result;\n      },\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "query {\n  allPosts: posts {\n    id\n    title\n    status\n  }\n  publishedOnly: posts(status: PUBLISHED) {\n    title\n    status\n  }\n}"
  },
  {
    "id": "interfaces",
    "title": "Interfaces & Unions",
    "description": "Using interfaces and union types",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\n\nconst builder = new SchemaBuilder({});\n\n// Define an interface\nconst Node = builder.interfaceRef<{ id: string }>('Node');\n\nbuilder.interfaceType(Node, {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n  }),\n});\n\n// Types implementing the interface\ntype UserShape = { id: string; name: string; email: string };\ntype PostShape = { id: string; title: string; content: string };\n\nconst User = builder.objectRef<UserShape>('User');\nconst Post = builder.objectRef<PostShape>('Post');\n\nbuilder.objectType(User, {\n  interfaces: [Node],\n  fields: (t) => ({\n    name: t.exposeString('name'),\n    email: t.exposeString('email'),\n  }),\n});\n\nbuilder.objectType(Post, {\n  interfaces: [Node],\n  fields: (t) => ({\n    title: t.exposeString('title'),\n    content: t.exposeString('content'),\n  }),\n});\n\n// Union type\nconst SearchResult = builder.unionType('SearchResult', {\n  types: [User, Post],\n  resolveType: (value) => {\n    if ('email' in value) return User;\n    return Post;\n  },\n});\n\nbuilder.queryType({\n  fields: (t) => ({\n    node: t.field({\n      type: Node,\n      nullable: true,\n      args: { id: t.arg.id({ required: true }) },\n      resolve: (_, { id }) => ({ id: String(id), name: 'Test', email: 'test@example.com' }),\n    }),\n    search: t.field({\n      type: [SearchResult],\n      args: { query: t.arg.string({ required: true }) },\n      resolve: () => [\n        { id: '1', name: 'John', email: 'john@example.com' },\n        { id: '2', title: 'Hello World', content: 'Welcome!' },\n      ],\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "query {\n  search(query: \"test\") {\n    ... on User {\n      id\n      name\n      email\n    }\n    ... on Post {\n      id\n      title\n      content\n    }\n  }\n}"
  },
  {
    "id": "mutations",
    "title": "Mutations",
    "description": "Define mutations with input types",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\n\nconst builder = new SchemaBuilder({});\n\n// Simple in-memory store\nconst users = new Map<string, { id: string; name: string; email: string }>();\n\n// User type ref\nconst UserType = builder.objectRef<{ id: string; name: string; email: string }>('User');\n\nbuilder.objectType(UserType, {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    name: t.exposeString('name'),\n    email: t.exposeString('email'),\n  }),\n});\n\n// Input type for creating users\nconst CreateUserInput = builder.inputType('CreateUserInput', {\n  fields: (t) => ({\n    name: t.string({ required: true }),\n    email: t.string({ required: true }),\n  }),\n});\n\nbuilder.queryType({\n  fields: (t) => ({\n    users: t.field({\n      type: [UserType],\n      resolve: () => Array.from(users.values()),\n    }),\n  }),\n});\n\nbuilder.mutationType({\n  fields: (t) => ({\n    createUser: t.field({\n      type: UserType,\n      args: {\n        input: t.arg({ type: CreateUserInput, required: true }),\n      },\n      resolve: (_, { input }) => {\n        const id = String(users.size + 1);\n        const user = { id, ...input };\n        users.set(id, user);\n        return user;\n      },\n    }),\n    deleteUser: t.boolean({\n      args: {\n        id: t.arg.id({ required: true }),\n      },\n      resolve: (_, { id }) => users.delete(String(id)),\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "mutation {\n  createUser(input: {\n    name: \"Jane Doe\"\n    email: \"jane@example.com\"\n  }) {\n    id\n    name\n    email\n  }\n}"
  },
  {
    "id": "relay-plugin",
    "title": "Relay Plugin",
    "description": "Use the Relay plugin for cursor-based pagination and global IDs",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\nimport RelayPlugin from '@pothos/plugin-relay';\n\nconst builder = new SchemaBuilder({\n  plugins: [RelayPlugin],\n  relay: {\n    // Configure relay options\n    clientMutationId: 'omit',\n    cursorType: 'String',\n  },\n});\n\n// Mock data\nconst posts = [\n  { id: '1', title: 'First Post', content: 'Hello World', published: true },\n  { id: '2', title: 'Second Post', content: 'GraphQL is awesome', published: true },\n  { id: '3', title: 'Third Post', content: 'Relay makes pagination easy', published: false },\n  { id: '4', title: 'Fourth Post', content: 'Pothos is type-safe', published: true },\n  { id: '5', title: 'Fifth Post', content: 'Building APIs is fun', published: true },\n];\n\nconst users = [\n  { id: '1', name: 'Alice', email: 'alice@example.com' },\n  { id: '2', name: 'Bob', email: 'bob@example.com' },\n  { id: '3', name: 'Charlie', email: 'charlie@example.com' },\n];\n\n// Define User and Post refs\nconst UserRef = builder.objectRef<{ id: string; name: string; email: string }>('User');\nconst PostRef = builder.objectRef<{ id: string; title: string; content: string; published: boolean }>('Post');\n\n// Define a User node\nconst User = builder.node(UserRef, {\n  id: {\n    resolve: (user) => user.id,\n  },\n  loadOne: (id) => users.find((u) => u.id === id) || null,\n  loadMany: (ids) => ids.map((id) => users.find((u) => u.id === id) || null),\n  fields: (t) => ({\n    name: t.exposeString('name'),\n    email: t.exposeString('email'),\n  }),\n});\n\n// Define a Post node\nconst Post = builder.node(PostRef, {\n  id: {\n    resolve: (post) => post.id,\n  },\n  loadOne: (id) => posts.find((p) => p.id === id) || null,\n  loadMany: (ids) => ids.map((id) => posts.find((p) => p.id === id) || null),\n  fields: (t) => ({\n    title: t.exposeString('title'),\n    content: t.exposeString('content'),\n    published: t.exposeBoolean('published'),\n  }),\n});\n\n// Query with connection fields\nbuilder.queryType({\n  fields: (t) => ({\n    // Connection for posts with cursor-based pagination\n    posts: t.connection({\n      type: Post,\n      resolve: (parent, args) => {\n        // Simple implementation - in production you'd query from a database\n        return {\n          edges: posts.map((post, index) => ({\n            cursor: `cursor:${index}`,\n            node: post,\n          })),\n          pageInfo: {\n            hasNextPage: false,\n            hasPreviousPage: false,\n            startCursor: 'cursor:0',\n            endCursor: `cursor:${posts.length - 1}`,\n          },\n        };\n      },\n    }),\n\n    // Connection for users\n    users: t.connection({\n      type: User,\n      resolve: () => ({\n        edges: users.map((user, index) => ({\n          cursor: `cursor:${index}`,\n          node: user,\n        })),\n        pageInfo: {\n          hasNextPage: false,\n          hasPreviousPage: false,\n          startCursor: 'cursor:0',\n          endCursor: `cursor:${users.length - 1}`,\n        },\n      }),\n    }),\n\n    // Single node lookup by global ID\n    // This is automatically provided by the relay plugin as 'node' field\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "# Query posts with connection/pagination\nquery PostsConnection {\n  posts(first: 3) {\n    edges {\n      cursor\n      node {\n        id\n        title\n        content\n        published\n      }\n    }\n    pageInfo {\n      hasNextPage\n      hasPreviousPage\n      startCursor\n      endCursor\n    }\n  }\n}\n\n# Query users connection\nquery UsersConnection {\n  users(first: 2) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        email\n      }\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n  }\n}\n\n# Query a specific node by global ID\nquery NodeQuery {\n  node(id: \"UG9zdDox\") {\n    id\n    ... on Post {\n      title\n      content\n    }\n    ... on User {\n      name\n      email\n    }\n  }\n}"
  },
  {
    "id": "simple-objects-plugin",
    "title": "Simple Objects Plugin",
    "description": "Use the Simple Objects plugin to define objects without separate type definitions",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\nimport SimpleObjectsPlugin from '@pothos/plugin-simple-objects';\n\nconst builder = new SchemaBuilder({\n  plugins: [SimpleObjectsPlugin],\n});\n\n// Define a simple object for contact information\nconst ContactInfo = builder.simpleObject('ContactInfo', {\n  fields: (t) => ({\n    email: t.string({\n      nullable: false,\n    }),\n    phoneNumber: t.string({\n      nullable: true,\n    }),\n    website: t.string({\n      nullable: true,\n    }),\n  }),\n});\n\n// Define a simple interface for entities with IDs\nconst Node = builder.simpleInterface('Node', {\n  fields: (t) => ({\n    id: t.id({\n      nullable: false,\n    }),\n  }),\n});\n\n// Define a User type with simpleObject\nconst User = builder.simpleObject(\n  'User',\n  {\n    interfaces: [Node],\n    fields: (t) => ({\n      firstName: t.string(),\n      lastName: t.string(),\n      age: t.int(),\n      contactInfo: t.field({\n        type: ContactInfo,\n        nullable: false,\n      }),\n    }),\n  },\n  // Add computed fields with resolvers\n  (t) => ({\n    fullName: t.string({\n      resolve: (user) => `${user.firstName} ${user.lastName}`,\n    }),\n    isAdult: t.boolean({\n      resolve: (user) => user.age >= 18,\n    }),\n  }),\n);\n\n// Define a Post type\nconst Post = builder.simpleObject(\n  'Post',\n  {\n    interfaces: [Node],\n    fields: (t) => ({\n      title: t.string(),\n      content: t.string(),\n      published: t.boolean(),\n      authorId: t.id(),\n    }),\n  },\n  // Add resolver fields\n  (t) => ({\n    excerpt: t.string({\n      resolve: (post) => `${post.content.substring(0, 100)}...`,\n    }),\n    status: t.string({\n      resolve: (post) => post.published ? 'Published' : 'Draft',\n    }),\n  }),\n);\n\n// Define Comment type\nconst Comment = builder.simpleObject(\n  'Comment',\n  {\n    interfaces: [Node],\n    fields: (t) => ({\n      text: t.string(),\n      postId: t.id(),\n      authorId: t.id(),\n      createdAt: t.string(),\n    }),\n  },\n  (t) => ({\n    preview: t.string({\n      resolve: (comment) => {\n        return comment.text.length > 50\n          ? `${comment.text.substring(0, 50)}...`\n          : comment.text;\n      },\n    }),\n  }),\n);\n\n// Query type\nbuilder.queryType({\n  fields: (t) => ({\n    user: t.field({\n      type: User,\n      args: {\n        id: t.arg.id({ required: true }),\n      },\n      resolve: (_, args) => ({\n        id: args.id,\n        firstName: 'Jane',\n        lastName: 'Doe',\n        age: 28,\n        contactInfo: {\n          email: 'jane@example.com',\n          phoneNumber: '+1-555-0123',\n          website: 'https://janedoe.com',\n        },\n      }),\n    }),\n    post: t.field({\n      type: Post,\n      args: {\n        id: t.arg.id({ required: true }),\n      },\n      resolve: (_, args) => ({\n        id: args.id,\n        title: 'Introduction to Pothos Simple Objects',\n        content: 'The Simple Objects plugin makes it easy to define GraphQL types without needing separate TypeScript type definitions. This reduces boilerplate while maintaining full type safety.',\n        published: true,\n        authorId: '1',\n      }),\n    }),\n    comments: t.field({\n      type: [Comment],\n      args: {\n        postId: t.arg.id({ required: true }),\n      },\n      resolve: (_, args) => [\n        {\n          id: '1',\n          text: 'Great article! Very helpful.',\n          postId: args.postId,\n          authorId: '2',\n          createdAt: new Date('2024-01-15').toISOString(),\n        },\n        {\n          id: '2',\n          text: 'Thanks for sharing this. The Simple Objects plugin really simplifies schema building.',\n          postId: args.postId,\n          authorId: '3',\n          createdAt: new Date('2024-01-16').toISOString(),\n        },\n      ],\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "query {\n  user(id: \"1\") {\n    id\n    firstName\n    lastName\n    fullName\n    age\n    isAdult\n    contactInfo {\n      email\n      phoneNumber\n      website\n    }\n  }\n  post(id: \"1\") {\n    id\n    title\n    excerpt\n    status\n  }\n  comments(postId: \"1\") {\n    id\n    preview\n    createdAt\n  }\n}"
  },
  {
    "id": "unions",
    "title": "Union Types",
    "description": "Define union types for polymorphic results",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\n\nconst builder = new SchemaBuilder({});\n\n// Define result types\nconst SuccessResult = builder.objectRef<{\n  __typename: 'SuccessResult';\n  message: string;\n}>('SuccessResult');\n\nconst ErrorResult = builder.objectRef<{\n  __typename: 'ErrorResult';\n  error: string;\n  code: number;\n}>('ErrorResult');\n\nbuilder.objectType(SuccessResult, {\n  fields: (t) => ({\n    message: t.exposeString('message'),\n  }),\n});\n\nbuilder.objectType(ErrorResult, {\n  fields: (t) => ({\n    error: t.exposeString('error'),\n    code: t.exposeInt('code'),\n  }),\n});\n\n// Create a union type\nconst Result = builder.unionType('Result', {\n  types: [SuccessResult, ErrorResult],\n  resolveType: (value) => {\n    if (value.__typename === 'SuccessResult') {\n      return SuccessResult;\n    }\n    return ErrorResult;\n  },\n});\n\nbuilder.queryType({\n  fields: (t) => ({\n    doSomething: t.field({\n      type: Result,\n      args: {\n        shouldSucceed: t.arg.boolean({ required: true }),\n      },\n      resolve: (_, args) => {\n        if (args.shouldSucceed) {\n          return {\n            __typename: 'SuccessResult' as const,\n            message: 'Operation completed successfully!',\n          };\n        }\n        return {\n          __typename: 'ErrorResult' as const,\n          error: 'Something went wrong',\n          code: 500,\n        };\n      },\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "query {\n  success: doSomething(shouldSucceed: true) {\n    ... on SuccessResult {\n      message\n    }\n    ... on ErrorResult {\n      error\n      code\n    }\n  }\n  failure: doSomething(shouldSucceed: false) {\n    ... on SuccessResult {\n      message\n    }\n    ... on ErrorResult {\n      error\n      code\n    }\n  }\n}"
  },
  {
    "id": "with-input-plugin",
    "title": "With-Input Plugin",
    "description": "Use the With-Input plugin to easily define fields with a single input object",
    "tags": [],
    "files": [
      {
        "filename": "schema.ts",
        "content": "import SchemaBuilder from '@pothos/core';\nimport WithInputPlugin from '@pothos/plugin-with-input';\n\nconst builder = new SchemaBuilder({\n  plugins: [WithInputPlugin],\n  withInput: {\n    typeOptions: {\n      // default options for Input object types\n    },\n  },\n});\n\n// User type\nconst User = builder.objectRef<{\n  id: string;\n  username: string;\n  email: string;\n  age: number;\n}>('User');\n\nbuilder.objectType(User, {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    username: t.exposeString('username'),\n    email: t.exposeString('email'),\n    age: t.exposeInt('age'),\n  }),\n});\n\n// Post type\nconst Post = builder.objectRef<{\n  id: string;\n  title: string;\n  content: string;\n  authorId: string;\n}>('Post');\n\nbuilder.objectType(Post, {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    title: t.exposeString('title'),\n    content: t.exposeString('content'),\n    authorId: t.exposeID('authorId'),\n  }),\n});\n\n// Query\nbuilder.queryType({\n  fields: (t) => ({\n    // Simple field with input\n    findUser: t.fieldWithInput({\n      input: {\n        id: t.input.id({ required: true }),\n      },\n      type: User,\n      nullable: true,\n      resolve: (_, args) => {\n        // The input is automatically under args.input\n        if (args.input.id === '1') {\n          return {\n            id: '1',\n            username: 'johndoe',\n            email: 'john@example.com',\n            age: 30,\n          };\n        }\n        return null;\n      },\n    }),\n\n    // Field with multiple input fields\n    searchUsers: t.fieldWithInput({\n      input: {\n        username: t.input.string(),\n        email: t.input.string(),\n        minAge: t.input.int(),\n        maxAge: t.input.int(),\n      },\n      type: [User],\n      resolve: (_, args) => {\n        // Mock search - in production this would query a database\n        return [\n          {\n            id: '1',\n            username: 'johndoe',\n            email: 'john@example.com',\n            age: 30,\n          },\n          {\n            id: '2',\n            username: 'janedoe',\n            email: 'jane@example.com',\n            age: 28,\n          },\n        ].filter((user) => {\n          if (args.input.username && !user.username.includes(args.input.username)) {\n            return false;\n          }\n          if (args.input.email && !user.email.includes(args.input.email)) {\n            return false;\n          }\n          if (args.input.minAge !== undefined && args.input.minAge !== null && user.age < args.input.minAge) {\n            return false;\n          }\n          if (args.input.maxAge !== undefined && args.input.maxAge !== null && user.age > args.input.maxAge) {\n            return false;\n          }\n          return true;\n        });\n      },\n    }),\n\n    // Custom input type name and arg name\n    findPost: t.fieldWithInput({\n      typeOptions: {\n        name: 'FindPostInput',\n      },\n      argOptions: {\n        name: 'criteria',\n      },\n      input: {\n        id: t.input.id({ required: true }),\n      },\n      type: Post,\n      nullable: true,\n      resolve: (_, args) => {\n        // Now the input is under args.criteria instead of args.input\n        if (args.criteria.id === '1') {\n          return {\n            id: '1',\n            title: 'Getting Started with Pothos',\n            content: 'Learn how to build type-safe GraphQL schemas',\n            authorId: '1',\n          };\n        }\n        return null;\n      },\n    }),\n  }),\n});\n\n// Mutation\nbuilder.mutationType({\n  fields: (t) => ({\n    // Create user with input\n    createUser: t.fieldWithInput({\n      input: {\n        username: t.input.string({ required: true }),\n        email: t.input.string({ required: true }),\n        password: t.input.string({ required: true }),\n        age: t.input.int({ required: true }),\n      },\n      type: User,\n      resolve: (_, args) => {\n        return {\n          id: '3',\n          username: args.input.username,\n          email: args.input.email,\n          age: args.input.age,\n        };\n      },\n    }),\n\n    // Update user with input\n    updateUser: t.fieldWithInput({\n      input: {\n        id: t.input.id({ required: true }),\n        username: t.input.string(),\n        email: t.input.string(),\n        age: t.input.int(),\n      },\n      type: User,\n      resolve: (_, args) => {\n        return {\n          id: args.input.id,\n          username: args.input.username || 'updated_user',\n          email: args.input.email || 'updated@example.com',\n          age: args.input.age ?? 25,\n        };\n      },\n    }),\n\n    // Create post with input\n    createPost: t.fieldWithInput({\n      input: {\n        title: t.input.string({ required: true }),\n        content: t.input.string({ required: true }),\n        authorId: t.input.id({ required: true }),\n      },\n      type: Post,\n      resolve: (_, args) => {\n        return {\n          id: '2',\n          title: args.input.title,\n          content: args.input.content,\n          authorId: args.input.authorId,\n        };\n      },\n    }),\n  }),\n});\n\nexport const schema = builder.toSchema();",
        "language": "typescript"
      }
    ],
    "defaultQuery": "# Find a user by ID\nquery FindUser {\n  findUser(input: { id: \"1\" }) {\n    id\n    username\n    email\n    age\n  }\n}\n\n# Search users with filters\nquery SearchUsers {\n  searchUsers(input: { minAge: 25, maxAge: 35 }) {\n    id\n    username\n    age\n  }\n}\n\n# Find a post using custom arg name\nquery FindPost {\n  findPost(criteria: { id: \"1\" }) {\n    id\n    title\n    content\n  }\n}\n\n# Create a new user\nmutation CreateUser {\n  createUser(\n    input: {\n      username: \"newuser\"\n      email: \"newuser@example.com\"\n      password: \"SecurePass123\"\n      age: 25\n    }\n  ) {\n    id\n    username\n    email\n  }\n}\n\n# Update a user\nmutation UpdateUser {\n  updateUser(input: { id: \"1\", email: \"newemail@example.com\" }) {\n    id\n    username\n    email\n  }\n}"
  }
]