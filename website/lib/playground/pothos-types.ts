// Auto-generated Pothos type definitions for Monaco editor
// Generated at: 2025-12-05T03:12:41.847Z

export interface TypeDefinition {
  moduleName: string;
  content: string;
}

export const pothosTypeDefinitions: TypeDefinition[] = [
  {
    "moduleName": "@pothos/core/types/global/classes",
    "content": "import type { SchemaBuilder as Builder } from '@pothos/core/builder';\nimport type { FieldBuilder as InternalFieldBuilder } from '@pothos/core/fieldUtils/builder';\nimport type { InputFieldBuilder as InternalInputFieldBuilder } from '@pothos/core/fieldUtils/input';\nimport type { RootFieldBuilder as InternalRootFieldBuilder } from '@pothos/core/fieldUtils/root';\nimport type { ArgumentRef as InternalArgumentRef } from '@pothos/core/refs/arg';\nimport type { BaseTypeRef as InternalBaseRef } from '@pothos/core/refs/base';\nimport type { EnumRef as InternalEnumRef } from '@pothos/core/refs/enum';\nimport type { FieldRef as InternalFieldRef } from '@pothos/core/refs/field';\nimport type { InputFieldRef as InternalInputFieldRef } from '@pothos/core/refs/input-field';\nimport type { InputListRef as InternalInputListRef } from '@pothos/core/refs/input-list';\nimport type { ImplementableInputObjectRef as InternalImplementableInputObjectRef, InputObjectRef as InternalInputObjectRef } from '@pothos/core/refs/input-object';\nimport type { ImplementableInterfaceRef as InternalImplementableInterfaceRef, InterfaceRef as InternalInterfaceRef } from '@pothos/core/refs/interface';\nimport type { ListRef as InternalListRef } from '@pothos/core/refs/list';\nimport type { ImplementableObjectRef as InternalImplementableObjectRef, ObjectRef as InternalObjectRef } from '@pothos/core/refs/object';\nimport type { ScalarRef as InternalScalarRef } from '@pothos/core/refs/scalar';\nimport type { UnionRef as InternalUnionRef } from '@pothos/core/refs/union';\nimport type { FieldKind } from '@pothos/core/types/builder-options';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface SchemaBuilder<Types extends SchemaTypes> extends Builder<Types> {\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends InternalRootFieldBuilder<Types, ParentShape, Kind> {\n        }\n        interface FieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends InternalFieldBuilder<Types, ParentShape, Kind>, RootFieldBuilder<Types, ParentShape, Kind> {\n        }\n        interface QueryFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Query'> {\n        }\n        interface MutationFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Mutation'> {\n        }\n        interface SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Subscription'> {\n        }\n        interface ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Object'> {\n        }\n        interface InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Interface'> {\n        }\n        interface InputFieldBuilder<Types extends SchemaTypes, Kind extends 'Arg' | 'InputObject'> extends InternalInputFieldBuilder<Types, Kind> {\n        }\n        interface BaseTypeRef<Types extends SchemaTypes, T> extends InternalBaseRef<Types, T> {\n        }\n        interface EnumRef<Types extends SchemaTypes, T, U = T> extends InternalEnumRef<Types, T, U> {\n        }\n        interface InputObjectRef<Types extends SchemaTypes, T> extends InternalInputObjectRef<Types, T> {\n        }\n        interface ImplementableInputObjectRef<Types extends SchemaTypes, T extends object, Resolved = T> extends InternalImplementableInputObjectRef<Types, T, Resolved> {\n        }\n        interface InputListRef<Types extends SchemaTypes, T> extends InternalInputListRef<Types, T> {\n        }\n        interface InterfaceRef<Types extends SchemaTypes, T, P = T> extends InternalInterfaceRef<Types, T, P> {\n        }\n        interface ImplementableInterfaceRef<Types extends SchemaTypes, T, P = T> extends InternalImplementableInterfaceRef<Types, T, P> {\n        }\n        interface ObjectRef<Types extends SchemaTypes, T, P = T> extends InternalObjectRef<Types, T, P> {\n        }\n        interface ImplementableObjectRef<Types extends SchemaTypes, T, P = T> extends InternalImplementableObjectRef<Types, T, P> {\n        }\n        interface ScalarRef<Types extends SchemaTypes, T, U, P = T> extends InternalScalarRef<Types, T, U, P> {\n        }\n        interface UnionRef<Types extends SchemaTypes, T, P = T> extends InternalUnionRef<Types, T, P> {\n        }\n        interface ListRef<Types extends SchemaTypes, T, P = T> extends InternalListRef<Types, T, P> {\n        }\n        interface FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> extends InternalFieldRef<Types, T, Kind> {\n        }\n        interface InputFieldRef<Types extends SchemaTypes, T> extends InternalInputFieldRef<Types, T> {\n        }\n        interface ArgumentRef<Types extends SchemaTypes, T> extends InternalArgumentRef<Types, T> {\n        }\n    }\n}"
  },
  {
    "moduleName": "@pothos/core/types/global/field-options",
    "content": "import type { GraphQLFieldExtensions } from 'graphql';\nimport type { InferredFieldOptionsByKind, InputFieldMap, InputShapeFromFields, Resolver, Subscriber } from '@pothos/core/types/builder-options';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nimport type { FieldNullability, FieldRequiredness, InputShapeFromTypeParam, InputType, ShapeFromTypeParam, TypeParam } from '@pothos/core/types/type-params';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface InferredFieldOptions<Types extends SchemaTypes, ResolveShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveReturnShape = unknown> {\n            Resolve: {\n                /**\n                 * Resolver function for this field\n                 * @param parent - The parent object for the current type\n                 * @param {object} args - args object based on the args defined for this field\n                 * @param {object} context - the context object for the current query, based on `Context` type provided to the SchemaBuilder\n                 * @param {GraphQLResolveInfo} info - info about how this field was queried\n                 */\n                resolve: Resolver<ResolveShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, Type, Nullable>, ResolveReturnShape>;\n            };\n        }\n        interface FieldOptions<Types extends SchemaTypes = SchemaTypes, ParentShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveShape = unknown, ResolveReturnShape = unknown> {\n            /** The type for this field */\n            type: Type;\n            /** arguments for this field (created via `t.args`) */\n            args?: Args;\n            /** determines if this field can return null */\n            nullable?: Nullable;\n            /** text description for this field.  This will be added into your schema file and visable in tools like graphql-playground */\n            description?: string;\n            /** When present marks this field as deprecated */\n            deprecationReason?: string;\n            /** extensions for this field for use by directives, server plugins or other tools that depend on extensions */\n            extensions?: GraphQLFieldExtensions<ParentShape, Types['Context'], InputShapeFromFields<Args>>;\n        }\n        interface ObjectFieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, ParentShape, Type, Nullable, Args, ParentShape, ResolveReturnShape> {\n        }\n        interface QueryFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, Types['Root'], Type, Nullable, Args, Types['Root'], ResolveReturnShape> {\n        }\n        interface MutationFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, Types['Root'], Type, Nullable, Args, Types['Root'], ResolveReturnShape> {\n        }\n        interface InterfaceFieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, ParentShape, Type, Nullable, Args, ParentShape, ResolveReturnShape> {\n        }\n        interface SubscriptionFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> extends FieldOptions<Types, Types['Root'], Type, Nullable, Args, ResolveShape, ResolveReturnShape> {\n            /**\n             * Resolver function for this field\n             * @param root - The root object for this request\n             * @param {object} args - args object based on the args defined for this field\n             * @param {object} context - the context object for the current query, based on `Context` type provided to the SchemaBuilder\n             * @param {GraphQLResolveInfo} info - info about how this field was queried\n             */\n            subscribe: Subscriber<Types['Root'], InputShapeFromFields<Args>, Types['Context'], ResolveShape>;\n        }\n        interface FieldOptionsByKind<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> {\n            Query: QueryFieldOptions<Types, Type, Nullable, Args, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], Types['Root'], Type, Nullable, Args, ResolveReturnShape>;\n            Mutation: MutationFieldOptions<Types, Type, Nullable, Args, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], Types['Root'], Type, Nullable, Args, ResolveReturnShape>;\n            Subscription: SubscriptionFieldOptions<Types, Type, Nullable, Args, ResolveShape, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], ResolveShape, Type, Nullable, Args, ResolveReturnShape>;\n            Object: ObjectFieldOptions<Types, ParentShape, Type, Nullable, Args, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], ParentShape, Type, Nullable, Args, ResolveReturnShape>;\n            Interface: InterfaceFieldOptions<Types, ParentShape, Type, Nullable, Args, ResolveReturnShape> & Partial<InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], ParentShape, Type, Nullable, Args, ResolveReturnShape>>;\n        }\n        interface InputFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            /** The type for this field */\n            type: Type;\n            /** text description for this field.  This will be added into your schema file and visable in tools like graphql-playground */\n            description?: string;\n            /** When present marks this field as deprecated */\n            deprecationReason?: string;\n            /** determines if this field can be omitted (or set as null) */\n            required?: Req;\n            /** default value if this field is not included in the query */\n            defaultValue?: InputShapeFromTypeParam<Types, Type, Req>;\n            /** extensions for this field for use by directives, server plugins or other tools that depend on extensions */\n            extensions?: Readonly<Record<string, unknown>>;\n        }\n        interface ArgFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> extends InputFieldOptions<Types, Type, Req> {\n        }\n        interface InputObjectFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> extends InputFieldOptions<Types, Type, Req> {\n        }\n        interface InputFieldOptionsByKind<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            Arg: ArgFieldOptions<Types, Type, Req>;\n            InputObject: InputObjectFieldOptions<Types, Type, Req>;\n        }\n    }\n}"
  },
  {
    "moduleName": "@pothos/core/types/global/schema-types",
    "content": "import type { GraphQLDirective } from 'graphql';\nimport type { InferredFieldOptionsKind } from '@pothos/core/types/builder-options';\nimport type { PluginConstructorMap } from '@pothos/core/types/plugins';\nimport type { MergedScalars, SchemaTypes, V3DefaultScalars } from '@pothos/core/types/schema-types';\nimport type { IsStrictMode, RecursivelyNormalizeNullableFields } from '@pothos/core/types/utils';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            plugins?: (keyof PluginConstructorMap<Types>)[];\n            defaultFieldNullability: Types['Defaults'] extends 'v3' ? false extends Types['DefaultFieldNullability'] ? never : Types['DefaultFieldNullability'] : true extends Types['DefaultFieldNullability'] ? never : Types['DefaultFieldNullability'];\n            defaultInputFieldRequiredness: false extends Types['DefaultInputFieldRequiredness'] ? never : Types['DefaultInputFieldRequiredness'];\n            notStrict: IsStrictMode extends true ? never : 'Pothos may not work correctly when strict mode is not enabled in tsconfig.json';\n            defaults: SchemaTypes['Defaults'] extends Types['Defaults'] ? never : Types['Defaults'];\n        }\n        interface V3SchemaBuilderOptions<Types extends SchemaTypes> {\n        }\n        interface V3DefaultSchemaTypes {\n            Scalars: V3DefaultScalars;\n        }\n        interface BuildSchemaOptions<Types extends SchemaTypes> {\n            directives?: readonly GraphQLDirective[];\n            extensions?: Record<string, unknown>;\n            sortSchema?: boolean;\n        }\n        interface Plugins<Types extends SchemaTypes> {\n        }\n        interface PothosKindToGraphQLType {\n            Object: 'Object';\n            Query: 'Object';\n            Mutation: 'Object';\n            Subscription: 'Object';\n            Interface: 'Interface';\n            Union: 'Union';\n            Enum: 'Enum';\n            Scalar: 'Scalar';\n            InputObject: 'InputObject';\n        }\n        interface UserSchemaTypes {\n            Defaults: 'v3' | 'v4';\n            Scalars: Record<string, {\n                Input: unknown;\n                Output: unknown;\n            }>;\n            Objects: {};\n            Inputs: {};\n            Interfaces: {};\n            Root: object;\n            Context: object;\n            DefaultFieldNullability: boolean;\n            DefaultInputFieldRequiredness: boolean;\n            InferredFieldOptionsKind: InferredFieldOptionsKind;\n        }\n        interface ExtendDefaultTypes<PartialTypes extends Partial<UserSchemaTypes>> extends SchemaTypes {\n            Defaults: PartialTypes['Defaults'] & SchemaTypes['Defaults'];\n            Scalars: MergedScalars<PartialTypes>;\n            Objects: PartialTypes['Objects'] & {};\n            Inputs: PartialTypes['Inputs'] & {};\n            Interfaces: PartialTypes['Interfaces'] & {};\n            Root: PartialTypes['Root'] & {};\n            Context: PartialTypes['Context'] & {};\n            InferredFieldOptionsKind: PartialTypes['InferredFieldOptionsKind'] extends InferredFieldOptionsKind ? PartialTypes['InferredFieldOptionsKind'] : 'Resolve';\n            DefaultFieldNullability: PartialTypes['Defaults'] extends 'v3' ? PartialTypes['DefaultFieldNullability'] extends true ? true : false : PartialTypes['DefaultFieldNullability'] extends false ? false : true;\n            DefaultInputFieldRequiredness: PartialTypes['DefaultInputFieldRequiredness'] extends true ? true : false;\n            outputShapes: {\n                [K in keyof MergedScalars<PartialTypes>]: MergedScalars<PartialTypes>[K] extends {\n                    Output: infer T;\n                } ? T : never;\n            } & {\n                [K in keyof PartialTypes['Objects']]: PartialTypes['Objects'][K];\n            } & {\n                [K in keyof PartialTypes['Interfaces']]: PartialTypes['Interfaces'][K];\n            };\n            inputShapes: {\n                [K in keyof MergedScalars<PartialTypes>]: MergedScalars<PartialTypes>[K] extends {\n                    Input: infer T;\n                } ? T : never;\n            } & {\n                [K in keyof PartialTypes['Inputs']]: RecursivelyNormalizeNullableFields<PartialTypes['Inputs'][K]>;\n            };\n        }\n    }\n}"
  },
  {
    "moduleName": "@pothos/core/types/global/type-options",
    "content": "import type { GraphQLIsTypeOfFn, GraphQLResolveInfo, GraphQLScalarLiteralParser, GraphQLScalarValueParser, GraphQLUnionType } from 'graphql';\nimport type { EnumValues, InputFieldMap, InterfaceFieldsShape, MutationFieldsShape, ObjectFieldsShape, QueryFieldsShape, SubscriptionFieldsShape, ValidateInterfaces } from '@pothos/core/types/builder-options';\nimport type { RootName, SchemaTypes } from '@pothos/core/types/schema-types';\nimport type { InterfaceParam, ObjectParam, ParentShape } from '@pothos/core/types/type-params';\nimport type { MaybePromise } from '@pothos/core/types/utils';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface BaseTypeOptions<Types extends SchemaTypes = SchemaTypes> {\n            description?: string;\n            extensions?: Readonly<Record<string, unknown>>;\n        }\n        interface EnumTypeOptions<Types extends SchemaTypes = SchemaTypes, Values extends EnumValues<Types> = EnumValues<Types>> extends BaseTypeOptions<Types> {\n            values: Values;\n        }\n        interface ObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown> extends BaseTypeOptions<Types> {\n            fields?: ObjectFieldsShape<Types, Shape>;\n            interfaces?: undefined;\n            isTypeOf?: GraphQLIsTypeOfFn<unknown, Types['Context']>;\n        }\n        interface ObjectTypeWithInterfaceOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[]> extends Omit<ObjectTypeOptions<Types, Shape>, 'interfaces'> {\n            interfaces?: (() => Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]) | (Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]);\n        }\n        interface RootTypeOptions<Types extends SchemaTypes, Type extends RootName> extends BaseTypeOptions<Types> {\n            name?: string;\n        }\n        interface QueryTypeOptions<Types extends SchemaTypes = SchemaTypes> extends RootTypeOptions<Types, 'Query'> {\n            fields?: QueryFieldsShape<Types>;\n        }\n        interface MutationTypeOptions<Types extends SchemaTypes = SchemaTypes> extends RootTypeOptions<Types, 'Mutation'> {\n            fields?: MutationFieldsShape<Types>;\n        }\n        interface SubscriptionTypeOptions<Types extends SchemaTypes = SchemaTypes> extends RootTypeOptions<Types, 'Subscription'> {\n            fields?: SubscriptionFieldsShape<Types>;\n        }\n        interface InputObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Fields extends InputFieldMap = InputFieldMap> extends BaseTypeOptions<Types> {\n            isOneOf?: boolean;\n            fields: (t: InputFieldBuilder<Types, 'InputObject'>) => Fields;\n        }\n        interface InterfaceTypeOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[], ResolveType = unknown> extends BaseTypeOptions<Types> {\n            fields?: InterfaceFieldsShape<Types, Shape>;\n            interfaces?: (() => Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]) | (Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]);\n            resolveType?: ResolveType & ((parent: Shape, context: Types['Context'], info: GraphQLResolveInfo, type: GraphQLUnionType) => MaybePromise<ObjectParam<Types> | string | null | undefined>);\n        }\n        interface UnionTypeOptions<Types extends SchemaTypes = SchemaTypes, Member extends ObjectParam<Types> = ObjectParam<Types>, ResolveType = unknown> extends BaseTypeOptions<Types> {\n            types: Member[] | (() => Member[]);\n            resolveType?: ResolveType & ((parent: ParentShape<Types, Member>, context: Types['Context'], info: GraphQLResolveInfo, type: GraphQLUnionType) => MaybePromise<Member | string | null | undefined>);\n        }\n        interface ScalarTypeOptions<Types extends SchemaTypes = SchemaTypes, ScalarInputShape = unknown, ScalarOutputShape = unknown> extends BaseTypeOptions<Types> {\n            serialize: (outputValue: ScalarOutputShape) => unknown;\n            parseValue?: GraphQLScalarValueParser<ScalarInputShape>;\n            parseLiteral?: GraphQLScalarLiteralParser<ScalarInputShape>;\n        }\n        interface EnumValueConfig<Types extends SchemaTypes> {\n            description?: string;\n            value?: number | string;\n            deprecationReason?: string;\n            extensions?: Readonly<Record<string, unknown>>;\n        }\n    }\n}"
  },
  {
    "moduleName": "graphql",
    "content": "declare module 'graphql' {\n  export interface GraphQLScalarType<TInternal = unknown, TExternal = TInternal> {\n    name: string;\n    description?: string | null;\n    serialize: (value: unknown) => TExternal | null;\n    parseValue?: (value: unknown) => TInternal | null;\n    parseLiteral?: (ast: unknown, variables?: Record<string, unknown> | null) => TInternal | null;\n  }\n\n  export interface GraphQLSchema {\n    getQueryType(): GraphQLObjectType | null | undefined;\n    getMutationType(): GraphQLObjectType | null | undefined;\n    getSubscriptionType(): GraphQLObjectType | null | undefined;\n  }\n\n  export interface GraphQLObjectType {\n    name: string;\n  }\n\n  export interface GraphQLInputObjectType {\n    name: string;\n  }\n\n  export interface GraphQLInterfaceType {\n    name: string;\n  }\n\n  export interface GraphQLUnionType {\n    name: string;\n  }\n\n  export interface GraphQLEnumType {\n    name: string;\n  }\n\n  export type GraphQLType =\n    | GraphQLScalarType\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n    | GraphQLEnumType\n    | GraphQLInputObjectType\n    | GraphQLList<GraphQLType>\n    | GraphQLNonNull<GraphQLType>;\n\n  export interface GraphQLList<T> {\n    ofType: T;\n  }\n\n  export interface GraphQLNonNull<T> {\n    ofType: T;\n  }\n\n  export interface GraphQLField<TSource, TContext, TArgs = Record<string, unknown>> {\n    name: string;\n    type: GraphQLOutputType;\n    args: ReadonlyArray<GraphQLArgument>;\n    resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>;\n  }\n\n  export interface GraphQLArgument {\n    name: string;\n    type: GraphQLInputType;\n    defaultValue?: unknown;\n  }\n\n  export type GraphQLOutputType =\n    | GraphQLScalarType\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n    | GraphQLEnumType\n    | GraphQLList<GraphQLOutputType>\n    | GraphQLNonNull<GraphQLOutputType>;\n\n  export type GraphQLInputType =\n    | GraphQLScalarType\n    | GraphQLInputObjectType\n    | GraphQLEnumType\n    | GraphQLList<GraphQLInputType>\n    | GraphQLNonNull<GraphQLInputType>;\n\n  export type GraphQLFieldResolver<TSource, TContext, TArgs = Record<string, unknown>> = (\n    source: TSource,\n    args: TArgs,\n    context: TContext,\n    info: GraphQLResolveInfo,\n  ) => unknown;\n\n  export interface GraphQLResolveInfo {\n    fieldName: string;\n    returnType: GraphQLOutputType;\n    parentType: GraphQLObjectType;\n    schema: GraphQLSchema;\n  }\n\n  export function printSchema(schema: GraphQLSchema): string;\n}"
  },
  {
    "moduleName": "@pothos/core/build-cache",
    "content": "declare module '@pothos/core/build-cache' {\nimport { GraphQLInterfaceType, type GraphQLNamedType } from 'graphql';\nimport type { SchemaBuilder } from '@pothos/core/builder';\nimport { type BasePlugin } from '@pothos/core/plugins';\nimport { type InputType, type OutputType, type PothosInputFieldConfig, type PothosObjectTypeConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class BuildCache<Types extends SchemaTypes> {\n    types: Map<string, GraphQLNamedType>;\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    plugin: BasePlugin<Types>;\n    options: PothosSchemaTypes.BuildSchemaOptions<Types>;\n    private configStore;\n    private pluginList;\n    private implementers;\n    private typeConfigs;\n    private enumValueConfigs;\n    private outputFieldConfigs;\n    private inputFieldConfigs;\n    constructor(builder: SchemaBuilder<Types>, options: PothosSchemaTypes.BuildSchemaOptions<Types>);\n    getTypeConfig<T extends PothosTypeConfig['kind']>(ref: InputType<Types> | OutputType<Types> | string, kind?: T): Extract<PothosTypeConfig, {\n        kind: T;\n    }>;\n    getInputTypeFieldConfigs(ref: InputType<Types>): Record<string, PothosInputFieldConfig<Types>>;\n    getImplementers(iface: GraphQLInterfaceType): PothosObjectTypeConfig[];\n    buildAll(): void;\n    buildTypeFromConfig(baseConfig: PothosTypeConfig): void;\n    private addType;\n    private buildOutputTypeParam;\n    private buildInputTypeParam;\n    private buildFields;\n    private buildInputFields;\n    private getInterfaceFields;\n    private getObjectFields;\n    private getRootFields;\n    private getFields;\n    private getInputFields;\n    private getType;\n    private getOutputType;\n    private getInputType;\n    private getTypeOfKind;\n    private buildObject;\n    private buildInterface;\n    private buildUnion;\n    private buildInputObject;\n    private buildScalar;\n    private buildEnum;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/builder",
    "content": "declare module '@pothos/core/builder' {\nimport { type GraphQLScalarSerializer, type GraphQLScalarType, GraphQLSchema } from 'graphql';\nimport { ConfigStore } from '@pothos/core/config-store';\nimport { InputObjectRef } from '@pothos/core/refs/input-object';\nimport { MutationRef } from '@pothos/core/refs/mutation';\nimport { QueryRef } from '@pothos/core/refs/query';\nimport { SubscriptionRef } from '@pothos/core/refs/subscription';\nimport type { AbstractReturnShape, AddVersionedDefaultsToBuilderOptions, BaseEnum, EnumParam, EnumTypeOptions, EnumValues, InputFieldMap, InputFieldsFromShape, InputShape, InputShapeFromFields, InterfaceFieldsShape, InterfaceFieldThunk, InterfaceParam, InterfaceTypeOptions, MutationFieldsShape, MutationFieldThunk, NormalizeArgs, NormalizeSchemeBuilderOptions, ObjectFieldsShape, ObjectFieldThunk, ObjectParam, ObjectTypeOptions, OneOfInputShapeFromFields, OutputShape, ParentShape, PluginConstructorMap, QueryFieldsShape, QueryFieldThunk, RecursivelyNormalizeNullableFields, ScalarName, SchemaTypes, ShapeFromEnumValues, SubscriptionFieldsShape, SubscriptionFieldThunk, ValuesFromEnum } from '@pothos/core/types';\nexport declare class SchemaBuilder<Types extends SchemaTypes> {\n    $inferSchemaTypes: Types;\n    private queryRef;\n    private mutationRef;\n    private subscriptionRef;\n    static plugins: Partial<PluginConstructorMap<SchemaTypes>>;\n    static optionNormalizers: Map<string, {\n        v3?: (options: AddVersionedDefaultsToBuilderOptions<SchemaTypes, 'v3'>) => Partial<NormalizeSchemeBuilderOptions<SchemaTypes>>;\n        v4?: undefined;\n    }>;\n    static allowPluginReRegistration: boolean;\n    configStore: ConfigStore<Types>;\n    options: PothosSchemaTypes.SchemaBuilderOptions<Types>;\n    defaultFieldNullability: boolean;\n    defaultInputFieldRequiredness: boolean;\n    constructor(options: PothosSchemaTypes.SchemaBuilderOptions<Types>);\n    static registerPlugin<T extends keyof PluginConstructorMap<SchemaTypes>>(name: T, plugin: PluginConstructorMap<SchemaTypes>[T], normalizeOptions?: {\n        v3?: (options: AddVersionedDefaultsToBuilderOptions<SchemaTypes, 'v3'>) => Partial<NormalizeSchemeBuilderOptions<SchemaTypes>>;\n    }): void;\n    objectType<const Interfaces extends InterfaceParam<Types>[], Param extends ObjectParam<Types>>(param: Param, options: ObjectTypeOptions<Types, Param, ParentShape<Types, Param>, Interfaces>, fields?: ObjectFieldsShape<Types, ParentShape<Types, Param>>): PothosSchemaTypes.ObjectRef<Types, OutputShape<Types, Param>, ParentShape<Types, Param>>;\n    objectFields<Type extends ObjectParam<Types>>(param: Type, fields: ObjectFieldsShape<Types, ParentShape<Types, Type>>): void;\n    objectField<Type extends ObjectParam<Types>>(param: Type, fieldName: string, field: ObjectFieldThunk<Types, ParentShape<Types, Type>>): void;\n    queryType(...args: NormalizeArgs<[\n        options: PothosSchemaTypes.QueryTypeOptions<Types>,\n        fields?: QueryFieldsShape<Types>\n    ], 0>): QueryRef<Types>;\n    queryFields(fields: QueryFieldsShape<Types>): void;\n    queryField(name: string, field: QueryFieldThunk<Types>): void;\n    mutationType(...args: NormalizeArgs<[\n        options: PothosSchemaTypes.MutationTypeOptions<Types>,\n        fields?: MutationFieldsShape<Types>\n    ], 0>): MutationRef<Types>;\n    mutationFields(fields: MutationFieldsShape<Types>): void;\n    mutationField(name: string, field: MutationFieldThunk<Types>): void;\n    subscriptionType(...args: NormalizeArgs<[\n        options: PothosSchemaTypes.SubscriptionTypeOptions<Types>,\n        fields?: SubscriptionFieldsShape<Types>\n    ], 0>): SubscriptionRef<Types>;\n    subscriptionFields(fields: SubscriptionFieldsShape<Types>): void;\n    subscriptionField(name: string, field: SubscriptionFieldThunk<Types>): void;\n    args<Shape extends InputFieldMap>(fields: (t: PothosSchemaTypes.InputFieldBuilder<Types, 'Arg'>) => Shape): Shape;\n    interfaceType<Param extends InterfaceParam<Types>, const Interfaces extends InterfaceParam<Types>[], ResolveType>(param: Param, options: InterfaceTypeOptions<Types, Param, ParentShape<Types, Param>, Interfaces, ResolveType>, fields?: InterfaceFieldsShape<Types, ParentShape<Types, Param>>): PothosSchemaTypes.InterfaceRef<Types, AbstractReturnShape<Types, Param, ResolveType>, ParentShape<Types, Param>>;\n    interfaceFields<Type extends InterfaceParam<Types>>(ref: Type, fields: InterfaceFieldsShape<Types, ParentShape<Types, Type>>): void;\n    interfaceField<Type extends InterfaceParam<Types>>(ref: Type, fieldName: string, field: InterfaceFieldThunk<Types, ParentShape<Types, Type>>): void;\n    unionType<Member extends ObjectParam<Types>, ResolveType>(name: string, options: PothosSchemaTypes.UnionTypeOptions<Types, Member, ResolveType>): PothosSchemaTypes.UnionRef<Types, AbstractReturnShape<Types, Member, ResolveType>, ParentShape<Types, Member>>;\n    enumType<Param extends EnumParam, const Values extends EnumValues<Types>>(param: Param, options: EnumTypeOptions<Types, Param, Values>): PothosSchemaTypes.EnumRef<Types, Param extends BaseEnum ? ValuesFromEnum<Param> : ShapeFromEnumValues<Types, Values>>;\n    scalarType<Name extends ScalarName<Types>>(name: Name, options: PothosSchemaTypes.ScalarTypeOptions<Types, InputShape<Types, Name>, ParentShape<Types, Name>>): PothosSchemaTypes.ScalarRef<Types, InputShape<Types, Name>, ParentShape<Types, Name>>;\n    addScalarType<Name extends ScalarName<Types>>(name: Name, scalar: GraphQLScalarType, ...args: NormalizeArgs<[\n        options: Omit<PothosSchemaTypes.ScalarTypeOptions<Types, InputShape<Types, Name>, OutputShape<Types, Name>>, 'serialize'> & {\n            serialize?: GraphQLScalarSerializer<OutputShape<Types, Name>>;\n        }\n    ]>): PothosSchemaTypes.ScalarRef<Types, InputShape<Types, Name>, ParentShape<Types, Name>, InputShape<Types, Name>>;\n    inputType<Param extends InputObjectRef<Types, unknown> | string, Fields extends Param extends PothosSchemaTypes.InputObjectRef<Types, unknown> ? InputFieldsFromShape<Types, InputShape<Types, Param> & object, 'InputObject'> : Param extends keyof Types['Inputs'] ? InputFieldsFromShape<Types, InputShape<Types, Param> & object, 'InputObject'> : InputFieldMap, IsOneOf extends boolean = boolean>(param: Param, options: PothosSchemaTypes.InputObjectTypeOptions<Types, Fields> & {\n        isOneOf?: IsOneOf;\n    }): PothosSchemaTypes.InputObjectRef<Types, [\n        IsOneOf\n    ] extends [true] ? OneOfInputShapeFromFields<Fields> : InputShapeFromFields<Fields>>;\n    inputRef<T extends object, Normalize = true>(name: string): PothosSchemaTypes.ImplementableInputObjectRef<Types, RecursivelyNormalizeNullableFields<T>, Normalize extends false ? T : RecursivelyNormalizeNullableFields<T>>;\n    objectRef<T>(name: string): PothosSchemaTypes.ImplementableObjectRef<Types, T>;\n    interfaceRef<T>(name: string): PothosSchemaTypes.ImplementableInterfaceRef<Types, T>;\n    toSchema(...args: NormalizeArgs<[options?: PothosSchemaTypes.BuildSchemaOptions<Types>]>): GraphQLSchema;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/config-store",
    "content": "declare module '@pothos/core/config-store' {\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { ConfigurableRef, FieldMap, GraphQLFieldKind, InputFieldMap, InputRef, OutputType, PothosFieldConfig, PothosTypeConfig, SchemaTypes } from '@pothos/core/types';\nexport declare class ConfigStore<Types extends SchemaTypes> {\n    typeConfigs: Map<string, PothosTypeConfig>;\n    private fields;\n    private refs;\n    private implementors;\n    private pendingActions;\n    private paramAssociations;\n    private pendingTypeConfigResolutions;\n    private pending;\n    private builder;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n    addFields(param: ConfigurableRef<Types>, fields: () => FieldMap): void;\n    addInputFields(param: ConfigurableRef<Types>, fields: () => InputFieldMap): void;\n    associateParamWithRef<T>(param: ConfigurableRef<Types>, ref: BaseTypeRef<Types, T> | string): void;\n    onTypeConfig(param: ConfigurableRef<Types>, onConfig: (config: PothosTypeConfig, ref: BaseTypeRef<Types>) => void): void;\n    onTypeConfigOfKind<Kind extends PothosTypeConfig['kind']>(param: ConfigurableRef<Types>, kind: Kind, onConfig: (config: PothosTypeConfig & {\n        kind: Kind;\n    }) => void): void;\n    addTypeRef<T extends PothosTypeConfig>(ref: BaseTypeRef<Types, T>): void;\n    subscribeToFields(_ref: BaseTypeRef<Types>): void;\n    hasImplementation(typeName: string): boolean;\n    hasConfig(ref: ConfigurableRef<Types> | string): boolean;\n    getTypeConfig<T extends PothosTypeConfig['kind']>(ref: ConfigurableRef<Types> | string, kind?: T): Extract<PothosTypeConfig, {\n        kind: T;\n    }>;\n    getInputTypeRef(param: ConfigurableRef<Types> | string): InputRef<unknown>;\n    getOutputTypeRef(param: ConfigurableRef<Types> | string): OutputType<Types>;\n    getFields<T extends GraphQLFieldKind>(name: string, kind?: T): Map<string, Extract<PothosFieldConfig<Types>, {\n        graphqlKind: T;\n    }>>;\n    prepareForBuild(): void;\n    onPrepare(cb: () => void): void;\n    private resolveParamAssociations;\n    private describeRef;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/errors",
    "content": "declare module '@pothos/core/errors' {\nimport { GraphQLError, type GraphQLErrorOptions } from 'graphql';\nexport declare class PothosError extends GraphQLError {\n    constructor(message: string, options?: GraphQLErrorOptions);\n}\nexport declare class PothosSchemaError extends PothosError {\n    constructor(message: string, options?: GraphQLErrorOptions);\n}\nexport declare class PothosValidationError extends PothosError {\n    constructor(message: string, options?: GraphQLErrorOptions);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/base",
    "content": "declare module '@pothos/core/fieldUtils/base' {\nimport { FieldRef } from '@pothos/core/refs/field';\nimport type { FieldKind, FieldNullability, InputFieldMap, Resolver, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core/types';\nexport declare class BaseFieldUtil<Types extends SchemaTypes, ParentShape, Kind extends FieldKind> {\n    kind: Kind;\n    graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[Kind];\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: Kind, graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[Kind]);\n    protected createField<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap = {}>(options: PothosSchemaTypes.FieldOptions<Types, ParentShape, Type, Nullable, Args, any, {}> & {\n        resolve?: Resolver<unknown, {}, {}, unknown, unknown>;\n    }): FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n    protected exposeField<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Name extends string & keyof ParentShape>(name: Name, { extensions, ...options }: PothosSchemaTypes.ObjectFieldOptions<Types, ParentShape, Type, Nullable, {}, {}>): FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/builder",
    "content": "declare module '@pothos/core/fieldUtils/builder' {\nimport type { CompatibleTypes, ExposeNullability, FieldKind, FieldNullability, FieldOptionsFromKind, InferredFieldOptionKeys, NormalizeArgs, SchemaTypes, TypeParam } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class FieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends RootFieldBuilder<Types, ParentShape, Kind> {\n    /**\n     * Create a Boolean field from a boolean property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeBoolean<Name extends CompatibleTypes<Types, ParentShape, 'Boolean', true>, ResolveReturnShape, Nullable extends FieldNullability<'Boolean'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'Boolean', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'Boolean', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Boolean\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Boolean\" extends infer T ? T extends \"Boolean\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Boolean\" extends infer T_1 ? T_1 extends \"Boolean\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Boolean\" extends infer T_2 ? T_2 extends \"Boolean\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Boolean\" extends infer T_3 ? T_3 extends \"Boolean\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Float field from a numeric property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeFloat<Name extends CompatibleTypes<Types, ParentShape, 'Float', true>, ResolveReturnShape, Nullable extends FieldNullability<'Float'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'Float', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'Float', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Float\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Float\" extends infer T ? T extends \"Float\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Float\" extends infer T_1 ? T_1 extends \"Float\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Float\" extends infer T_2 ? T_2 extends \"Float\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Float\" extends infer T_3 ? T_3 extends \"Float\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create an ID field from a property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeID<Name extends CompatibleTypes<Types, ParentShape, 'ID', true>, ResolveReturnShape, Nullable extends FieldNullability<'ID'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'ID', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"ID\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"ID\" extends infer T ? T extends \"ID\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"ID\" extends infer T_1 ? T_1 extends \"ID\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"ID\" extends infer T_2 ? T_2 extends \"ID\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"ID\" extends infer T_3 ? T_3 extends \"ID\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create an Int field from a numeric property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeInt<Name extends CompatibleTypes<Types, ParentShape, 'Int', true>, ResolveReturnShape, Nullable extends FieldNullability<'Int'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'Int', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'Int', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Int\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Int\" extends infer T ? T extends \"Int\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Int\" extends infer T_1 ? T_1 extends \"Int\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Int\" extends infer T_2 ? T_2 extends \"Int\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Int\" extends infer T_3 ? T_3 extends \"Int\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a String field from a string property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeString<Name extends CompatibleTypes<Types, ParentShape, 'String', true>, ResolveReturnShape, Nullable extends FieldNullability<'String'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'String', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'String', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"String\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"String\" extends infer T ? T extends \"String\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"String\" extends infer T_1 ? T_1 extends \"String\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"String\" extends infer T_2 ? T_2 extends \"String\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"String\" extends infer T_3 ? T_3 extends \"String\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Boolean list field from a boolean[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeBooleanList<Name extends CompatibleTypes<Types, ParentShape, ['Boolean'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['Boolean']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['Boolean'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'Boolean'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"Boolean\"], Nullable>, Kind>;\n    /**\n     * Create a Float list field from a number[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeFloatList<Name extends CompatibleTypes<Types, ParentShape, ['Float'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['Float']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['Float'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'Float'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"Float\"], Nullable>, Kind>;\n    /**\n     * Create an ID list field from an id[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeIDList<Name extends CompatibleTypes<Types, ParentShape, ['ID'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['ID']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['ID'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'ID'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"ID\"], Nullable>, Kind>;\n    /**\n     * Create a Int list field from a number[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeIntList<Name extends CompatibleTypes<Types, ParentShape, ['Int'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['Int']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['Int'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'Int'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"Int\"], Nullable>, Kind>;\n    /**\n     * Create a String list field from a string[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeStringList<Name extends CompatibleTypes<Types, ParentShape, ['String'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['String']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['String'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'String'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"String\"], Nullable>, Kind>;\n    /**\n     * Create a field that resolves to a property of the corresponding type on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    expose<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, ResolveReturnShape, Name extends CompatibleTypes<Types, ParentShape, Type, Type extends [unknown] ? {\n        list: true;\n        items: true;\n    } : true>>(name: Name extends keyof ParentShape ? Name : keyof ParentShape, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, Type, ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>[\"type\"], (false & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : true | {\n        items: boolean;\n        list: true;\n    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {\n        items: true;\n        list: boolean;\n    } : {\n        items: true;\n        list: true;\n    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true) & Nullable) | (true & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : true | {\n        items: boolean;\n        list: true;\n    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {\n        items: true;\n        list: boolean;\n    } : {\n        items: true;\n        list: true;\n    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true) & Nullable) | ((Type extends [unknown] ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : boolean) & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : true | {\n        items: boolean;\n        list: true;\n    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {\n        items: true;\n        list: boolean;\n    } : {\n        items: true;\n        list: true;\n    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true) & Nullable)>, Kind>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/input",
    "content": "declare module '@pothos/core/fieldUtils/input' {\nimport { InputListRef } from '@pothos/core/refs/input-list';\nimport type { ArgBuilder, FieldRequiredness, InputOrArgRef, InputShapeFromTypeParam, InputType, InputTypeParam, NormalizeArgs, SchemaTypes } from '@pothos/core/types';\nexport declare class InputFieldBuilder<Types extends SchemaTypes, Kind extends keyof PothosSchemaTypes.InputFieldOptionsByKind> {\n    kind: Kind;\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    /**\n     * Create a Boolean input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    boolean: <Req extends FieldRequiredness<\"Boolean\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"Boolean\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"Boolean\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"Boolean\" extends infer T ? T extends \"Boolean\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Boolean\" extends infer T_1 ? T_1 extends \"Boolean\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"Boolean\" extends infer T_2 ? T_2 extends \"Boolean\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"Boolean\" extends infer T_3 ? T_3 extends \"Boolean\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a Float input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    float: <Req extends FieldRequiredness<\"Float\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"Float\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"Float\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"Float\" extends infer T ? T extends \"Float\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Float\" extends infer T_1 ? T_1 extends \"Float\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"Float\" extends infer T_2 ? T_2 extends \"Float\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"Float\" extends infer T_3 ? T_3 extends \"Float\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a ID input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    id: <Req extends FieldRequiredness<\"ID\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"ID\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"ID\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"ID\" extends infer T ? T extends \"ID\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"ID\" extends infer T_1 ? T_1 extends \"ID\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"ID\" extends infer T_2 ? T_2 extends \"ID\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"ID\" extends infer T_3 ? T_3 extends \"ID\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a Int input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    int: <Req extends FieldRequiredness<\"Int\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"Int\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"Int\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"Int\" extends infer T ? T extends \"Int\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Int\" extends infer T_1 ? T_1 extends \"Int\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"Int\" extends infer T_2 ? T_2 extends \"Int\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"Int\" extends infer T_3 ? T_3 extends \"Int\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a String input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    string: <Req extends FieldRequiredness<\"String\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"String\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"String\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"String\" extends infer T ? T extends \"String\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"String\" extends infer T_1 ? T_1 extends \"String\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"String\" extends infer T_2 ? T_2 extends \"String\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"String\" extends infer T_3 ? T_3 extends \"String\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a Boolean list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    booleanList: <Req extends FieldRequiredness<[\"Boolean\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"Boolean\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"Boolean\"], Req>, Kind>;\n    /**\n     * Create a Float list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    floatList: <Req extends FieldRequiredness<[\"Float\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"Float\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"Float\"], Req>, Kind>;\n    /**\n     * Create a ID list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    idList: <Req extends FieldRequiredness<[\"ID\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"ID\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"ID\"], Req>, Kind>;\n    /**\n     * Create a Int list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    intList: <Req extends FieldRequiredness<[\"Int\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"Int\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"Int\"], Req>, Kind>;\n    /**\n     * Create a String list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    stringList: <Req extends FieldRequiredness<[\"String\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"String\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"String\"], Req>, Kind>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: Kind);\n    listRef: <T extends InputTypeParam<Types>, Required extends boolean = true>(type: T, options?: {\n        required?: Required;\n    }) => InputListRef<Types, InputShapeFromTypeParam<Types, T, Required>[]>;\n    argBuilder(): ArgBuilder<Types>;\n    /**\n     * Create in input field or argument for the current type\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    field<Type extends InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type>>(options: PothosSchemaTypes.InputFieldOptionsByKind<Types, Type, Req>[Kind]): InputOrArgRef<Types, InputShapeFromTypeParam<Types, Type, Req>, Kind>;\n    private helper;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/interface",
    "content": "declare module '@pothos/core/fieldUtils/interface' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { FieldBuilder } from '@pothos/core/fieldUtils/builder';\nexport declare class InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Interface'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/mutation",
    "content": "declare module '@pothos/core/fieldUtils/mutation' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class MutationFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Mutation'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/object",
    "content": "declare module '@pothos/core/fieldUtils/object' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { FieldBuilder } from '@pothos/core/fieldUtils/builder';\nexport declare class ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Object'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/query",
    "content": "declare module '@pothos/core/fieldUtils/query' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class QueryFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Query'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/root",
    "content": "declare module '@pothos/core/fieldUtils/root' {\nimport { ListRef } from '@pothos/core/refs/list';\nimport type { ArgBuilder, DistributeOmit, FieldKind, FieldNullability, FieldOptionsFromKind, InputFieldMap, NormalizeArgs, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core/types';\nimport { BaseFieldUtil } from '@pothos/core/fieldUtils/base';\nexport declare class RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends BaseFieldUtil<Types, ParentShape, Kind> {\n    arg: ArgBuilder<Types>;\n    /**\n     * Create a Boolean field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    boolean<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<'Boolean'> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'Boolean', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Boolean\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Boolean\" extends infer T ? T extends \"Boolean\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Boolean\" extends infer T_1 ? T_1 extends \"Boolean\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Boolean\" extends infer T_2 ? T_2 extends \"Boolean\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Boolean\" extends infer T_3 ? T_3 extends \"Boolean\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Float field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    float<Nullable extends FieldNullability<'Float'>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'Float', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Float\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Float\" extends infer T ? T extends \"Float\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Float\" extends infer T_1 ? T_1 extends \"Float\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Float\" extends infer T_2 ? T_2 extends \"Float\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Float\" extends infer T_3 ? T_3 extends \"Float\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a ID field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    id<Nullable extends FieldNullability<'ID'>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"ID\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"ID\" extends infer T ? T extends \"ID\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"ID\" extends infer T_1 ? T_1 extends \"ID\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"ID\" extends infer T_2 ? T_2 extends \"ID\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"ID\" extends infer T_3 ? T_3 extends \"ID\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Int field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    int<Nullable extends FieldNullability<'Int'>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'Int', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Int\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Int\" extends infer T ? T extends \"Int\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Int\" extends infer T_1 ? T_1 extends \"Int\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Int\" extends infer T_2 ? T_2 extends \"Int\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Int\" extends infer T_3 ? T_3 extends \"Int\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a String field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    string<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<'String'> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'String', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"String\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"String\" extends infer T ? T extends \"String\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"String\" extends infer T_1 ? T_1 extends \"String\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"String\" extends infer T_2 ? T_2 extends \"String\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"String\" extends infer T_3 ? T_3 extends \"String\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Boolean list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    booleanList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['Boolean']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'Boolean'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"Boolean\"], Nullable>, Kind>;\n    /**\n     * Create a Float list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    floatList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['Float']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'Float'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"Float\"], Nullable>, Kind>;\n    /**\n     * Create a ID list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    idList<Nullable extends FieldNullability<['ID']>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'ID'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"ID\"], Nullable>, Kind>;\n    /**\n     * Create a Int list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    intList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['Int']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'Int'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"Int\"], Nullable>, Kind>;\n    /**\n     * Create a String list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    stringList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['String']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'String'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"String\"], Nullable>, Kind>;\n    /**\n     * create a new field for the current type\n     * @param {PothosSchemaTypes.FieldOptions} options - options for this field\n     */\n    field<Type extends TypeParam<Types>, ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<Type> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(options: FieldOptionsFromKind<Types, ParentShape, Type, Nullable, Args, Kind, ResolveShape, ResolveReturnShape>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n    listRef<T extends TypeParam<Types>, Nullable extends boolean = false>(type: T, options?: {\n        nullable?: Nullable;\n    }): ListRef<Types, ShapeFromTypeParam<Types, T, Nullable>[]>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/subscription",
    "content": "declare module '@pothos/core/fieldUtils/subscription' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Subscription'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core",
    "content": "declare module '@pothos/core' {\nimport { SchemaBuilder as SchemaBuilderClass } from '@pothos/core/builder';\nimport '@pothos/core/types/global';\nimport type { AddVersionedDefaultsToBuilderOptions, FieldKind, InputTypeParam, NormalizeSchemeBuilderOptions, PothosInputFieldConfig, PothosOutputFieldConfig, PothosTypeConfig, RootName, SchemaTypes, TypeParam } from '@pothos/core/types';\nexport * from '@pothos/core/errors';\nexport * from '@pothos/core/plugins';\nexport * from '@pothos/core/types';\nexport * from '@pothos/core/utils';\ndeclare const SchemaBuilder: {\n    registerPlugin: typeof SchemaBuilderClass.registerPlugin;\n    allowPluginReRegistration: boolean;\n    new <Types extends Partial<PothosSchemaTypes.UserSchemaTypes> = {}>(options: Types extends {\n        Defaults: \"v3\";\n    } ? AddVersionedDefaultsToBuilderOptions<PothosSchemaTypes.ExtendDefaultTypes<Types>, \"v3\"> : NormalizeSchemeBuilderOptions<PothosSchemaTypes.ExtendDefaultTypes<Types>>): PothosSchemaTypes.SchemaBuilder<PothosSchemaTypes.ExtendDefaultTypes<Types>>;\n};\nexport default SchemaBuilder;\nexport declare const FieldBuilder: new <Types extends SchemaTypes, ParentShape, Kind extends Exclude<FieldKind, RootName> = Exclude<FieldKind, RootName>>(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: FieldKind, graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[FieldKind]) => PothosSchemaTypes.FieldBuilder<Types, ParentShape, Kind>;\nexport type RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> = PothosSchemaTypes.RootFieldBuilder<Types, ParentShape, Kind>;\nexport declare const RootFieldBuilder: new <Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind>(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: FieldKind, graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[FieldKind]) => PothosSchemaTypes.RootFieldBuilder<Types, ParentShape, Kind>;\nexport type QueryFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.QueryFieldBuilder<Types, ParentShape>;\nexport declare const QueryFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.QueryFieldBuilder<Types, ParentShape>;\nexport type MutationFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.MutationFieldBuilder<Types, ParentShape>;\nexport declare const MutationFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.MutationFieldBuilder<Types, ParentShape>;\nexport type SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.SubscriptionFieldBuilder<Types, ParentShape>;\nexport declare const SubscriptionFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.SubscriptionFieldBuilder<Types, ParentShape>;\nexport type ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.ObjectFieldBuilder<Types, ParentShape>;\nexport declare const ObjectFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.ObjectFieldBuilder<Types, ParentShape>;\nexport type InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.InterfaceFieldBuilder<Types, ParentShape>;\nexport declare const InterfaceFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.InterfaceFieldBuilder<Types, ParentShape>;\nexport type InputFieldBuilder<Types extends SchemaTypes, Kind extends 'Arg' | 'InputObject' = 'Arg' | 'InputObject'> = PothosSchemaTypes.InputFieldBuilder<Types, Kind>;\nexport declare const InputFieldBuilder: new <Types extends SchemaTypes, Kind extends \"Arg\" | \"InputObject\" = \"Arg\" | \"InputObject\">(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: Kind) => PothosSchemaTypes.InputFieldBuilder<Types, Kind>;\nexport type BaseTypeRef<Types extends SchemaTypes, T> = PothosSchemaTypes.BaseTypeRef<Types, T>;\nexport declare const BaseTypeRef: new <Types extends SchemaTypes, T>(kind: \"Enum\" | \"InputObject\" | \"Interface\" | \"Object\" | \"Scalar\" | \"Union\", name: string) => PothosSchemaTypes.BaseTypeRef<Types, T>;\nexport type EnumRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.EnumRef<Types, T, P>;\nexport declare const EnumRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.EnumRef<Types, T, P>;\nexport type InputObjectRef<Types extends SchemaTypes, T> = PothosSchemaTypes.InputObjectRef<Types, T>;\nexport declare const InputObjectRef: new <Types extends SchemaTypes, T>(name: string) => PothosSchemaTypes.InputObjectRef<Types, T>;\nexport type ImplementableInputObjectRef<Types extends SchemaTypes, T extends object> = PothosSchemaTypes.ImplementableInputObjectRef<Types, T>;\nexport declare const ImplementableInputObjectRef: new <Types extends SchemaTypes, T extends object>(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string) => PothosSchemaTypes.ImplementableInputObjectRef<Types, T>;\nexport type InputListRef<Types extends SchemaTypes, T> = PothosSchemaTypes.InputListRef<Types, T>;\nexport declare const InputListRef: new <Types extends SchemaTypes, T>(listType: InputTypeParam<Types>, required: boolean) => PothosSchemaTypes.InputListRef<Types, T>;\nexport type InterfaceRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.InterfaceRef<Types, T, P>;\nexport declare const InterfaceRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.InterfaceRef<Types, T, P>;\nexport type ImplementableInterfaceRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ImplementableInterfaceRef<Types, T, P>;\nexport declare const ImplementableInterfaceRef: new <Types extends SchemaTypes, T, P = T>(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string) => PothosSchemaTypes.ImplementableInterfaceRef<Types, T, P>;\nexport type ObjectRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ObjectRef<Types, T, P>;\nexport declare const ObjectRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.ObjectRef<Types, T, P>;\nexport type ImplementableObjectRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ImplementableObjectRef<Types, T, P>;\nexport declare const ImplementableObjectRef: new <Types extends SchemaTypes, T, P = T>(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string) => PothosSchemaTypes.ImplementableObjectRef<Types, T, P>;\nexport type ScalarRef<Types extends SchemaTypes, T, U, P = T> = PothosSchemaTypes.ScalarRef<Types, T, U, P>;\nexport declare const ScalarRef: new <Types extends SchemaTypes, T, U, P = T>(name: string) => PothosSchemaTypes.ScalarRef<Types, T, U, P>;\nexport type UnionRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.UnionRef<Types, T, P>;\nexport declare const UnionRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.UnionRef<Types, T, P>;\nexport type ListRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ListRef<Types, T, P>;\nexport declare const ListRef: new <Types extends SchemaTypes, T, P = T>(listType: TypeParam<Types>, nullable: boolean) => PothosSchemaTypes.ListRef<Types, T, P>;\nexport type FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> = PothosSchemaTypes.FieldRef<Types, T, Kind>;\nexport declare const FieldRef: new <Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind>(kind: Kind, initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosOutputFieldConfig<Types>) => PothosSchemaTypes.FieldRef<Types, T, Kind>;\nexport type InputFieldRef<Types extends SchemaTypes, T> = PothosSchemaTypes.InputFieldRef<Types, T>;\nexport declare const InputFieldRef: new <Types extends SchemaTypes, T>(initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>) => PothosSchemaTypes.InputFieldRef<Types, T>;\nexport type ArgumentRef<Types extends SchemaTypes, T> = PothosSchemaTypes.ArgumentRef<Types, T>;\nexport declare const ArgumentRef: new <Types extends SchemaTypes, T>(initConfig: (name: string, field: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>) => PothosSchemaTypes.ArgumentRef<Types, T>;\nexport { BuildCache } from '@pothos/core/build-cache';\nexport { BuiltinScalarRef } from '@pothos/core/refs/builtin-scalar';\nexport { InputTypeRef } from '@pothos/core/refs/input';\nexport { MutationRef } from '@pothos/core/refs/mutation';\nexport { OutputTypeRef } from '@pothos/core/refs/output';\nexport { QueryRef } from '@pothos/core/refs/query';\nexport { SubscriptionRef } from '@pothos/core/refs/subscription';\n}"
  },
  {
    "moduleName": "@pothos/core/plugins",
    "content": "declare module '@pothos/core/plugins' {\nexport * from '@pothos/core/plugins/merge-plugins';\nexport * from '@pothos/core/plugins/plugin';\n}"
  },
  {
    "moduleName": "@pothos/core/plugins/merge-plugins",
    "content": "declare module '@pothos/core/plugins/merge-plugins' {\nimport type { GraphQLFieldResolver, GraphQLIsTypeOfFn, GraphQLSchema, GraphQLTypeResolver } from 'graphql';\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { PothosEnumValueConfig, PothosInputFieldConfig, PothosInterfaceTypeConfig, PothosObjectTypeConfig, PothosOutputFieldConfig, PothosTypeConfig, PothosUnionTypeConfig, SchemaTypes } from '@pothos/core/types';\nimport { BasePlugin } from '@pothos/core/plugins/plugin';\nexport declare class MergedPlugins<Types extends SchemaTypes> extends BasePlugin<Types> {\n    plugins: BasePlugin<Types, object>[];\n    constructor(buildCache: BuildCache<Types>, plugins: BasePlugin<Types>[]);\n    onTypeConfig(typeConfig: PothosTypeConfig): PothosTypeConfig;\n    onInputFieldConfig(fieldConfig: PothosInputFieldConfig<Types>): PothosInputFieldConfig<Types> | null;\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n    onEnumValueConfig(valueConfig: PothosEnumValueConfig<Types>): PothosEnumValueConfig<Types> | null;\n    beforeBuild(): void;\n    afterBuild(schema: GraphQLSchema): GraphQLSchema;\n    wrapResolve(resolve: GraphQLFieldResolver<unknown, Types['Context'], object>, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    wrapSubscribe(subscribe: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    wrapArgMappers(resolver: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    wrapResolveType(resolveType: GraphQLTypeResolver<unknown, Types['Context']>, typeConfig: PothosInterfaceTypeConfig | PothosUnionTypeConfig): GraphQLTypeResolver<unknown, Types[\"Context\"]>;\n    wrapIsTypeOf(isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined, typeConfig: PothosObjectTypeConfig): GraphQLIsTypeOfFn<unknown, Types[\"Context\"]> | undefined;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/plugins/plugin",
    "content": "declare module '@pothos/core/plugins/plugin' {\nimport type { GraphQLFieldResolver, GraphQLIsTypeOfFn, GraphQLSchema, GraphQLTypeResolver } from 'graphql';\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { PothosEnumValueConfig, PothosInputFieldConfig, PothosInterfaceTypeConfig, PothosObjectTypeConfig, PothosOutputFieldConfig, PothosTypeConfig, PothosUnionTypeConfig, SchemaTypes } from '@pothos/core/types';\nexport declare class BasePlugin<Types extends SchemaTypes, T extends object = object> {\n    name: never;\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    buildCache: BuildCache<Types>;\n    options: PothosSchemaTypes.BuildSchemaOptions<Types>;\n    private requestDataMap;\n    constructor(buildCache: BuildCache<Types>, name: keyof PothosSchemaTypes.Plugins<Types>);\n    /**\n     * Called for each type defined with the SchemaBuilder\n     * @param  {PothosTypeConfig} typeConfig - Config object describing the added type\n     * @return {PothosTypeConfig} Original or updated `typeConfig`\n     */\n    onTypeConfig(typeConfig: PothosTypeConfig): PothosTypeConfig;\n    /**\n     * Called for each field on an Object or Interface type\n     * @param  {PothosOutputFieldConfig} fieldConfig - Config object describing the added field\n     * @return {PothosOutputFieldConfig} Original or updated `fieldConfig`\n     */\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n    /**\n     * Called for each argument or field on an Input object defined in your schema\n     * @param  {PothosInputFieldConfig} fieldConfig - Config object describing the added field\n     * @return {PothosInputFieldConfig} Original or updated `fieldConfig`\n     */\n    onInputFieldConfig(fieldConfig: PothosInputFieldConfig<Types>): PothosInputFieldConfig<Types> | null;\n    /**\n     * Called for each Enum value defined in your schema\n     * @param  {PothosEnumValueConfig} valueConfig - Config object describing the enum value\n     * @return {PothosEnumValueConfig} Original or updated `valueConfig`\n     */\n    onEnumValueConfig(valueConfig: PothosEnumValueConfig<Types>): PothosEnumValueConfig<Types> | null;\n    /**\n     * Called before builder.toSchema() schema is called\n     */\n    beforeBuild(): void;\n    /**\n     * Called after all fields and types have been built during `builder.toSchema()`\n     * @param  {GraphQLSchema} schema - the generated schema\n     * @return {PothosEnumValueConfig} Original or updated `schema`\n     */\n    afterBuild(schema: GraphQLSchema): GraphQLSchema;\n    /**\n     * Called with the resolver for each field in the schema\n     * @param  {GraphQLFieldResolver} resolve - the resolve function\n     * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function\n     * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field\n     */\n    wrapResolve(resolver: GraphQLFieldResolver<unknown, Types['Context'], object>, _fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    /**\n     * Called with the subscribe for each field on the Subscription type\n     * @param  {GraphQLFieldResolver} subscribe - the subscribe function\n     * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this subscribe function\n     * @return {GraphQLFieldResolver} - Either the original, or a new subscribe function to use for this field\n     */\n    wrapSubscribe(subscribe: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, _fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    /**\n     * Called with resolve or subscribe functions, but wraps outside of argMappers so arg mapping errors can be handled\n     * @param  {GraphQLFieldResolver} resolve - the resolve function\n     * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function\n     * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field\n     */\n    wrapArgMappers(resolver: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, _fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    /**\n     * Called with the resolveType for each Interface or Union type\n     * @param  {GraphQLTypeResolver} resolveType - the resolveType function\n     * @param  {PothosInterfaceTypeConfig | PothosUnionTypeConfig} typeConfig - the config object for the Interface or Union type\n     * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field\n     */\n    wrapResolveType(resolveType: GraphQLTypeResolver<unknown, Types['Context']>, _typeConfig: PothosInterfaceTypeConfig | PothosUnionTypeConfig): GraphQLTypeResolver<unknown, Types['Context']>;\n    /**\n     * Called with the isTypeOf for each Object type\n     * @param  {GraphQLTypeResolver} resolveType - the resolveType function\n     * @param  {PothosObjectTypeConfig} typeConfig - the config object for the Interface or Union type\n     * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field\n     */\n    wrapIsTypeOf(isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined, _typeConfig: PothosObjectTypeConfig): GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined;\n    protected runUnique<R>(key: unknown, cb: () => R): R;\n    /**\n     * Creates a data object unique to the current request for use by this plugin\n     * @param  {Types['Context']} context - the context object for the current request\n     * @return {object} - The data object for the current request\n     */\n    protected createRequestData(_context: Types['Context']): T;\n    /**\n     * Returns a data object for the current request.  requires `createRequestData` to be implemented\n     * @param  {Types['Context']} context - the context object for the current request\n     * @return {object} - The data object for the current request\n     */\n    protected requestData(context: Types['Context']): T;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/arg",
    "content": "declare module '@pothos/core/refs/arg' {\nimport { inputFieldShapeKey, type PothosInputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class ArgumentRef<Types extends SchemaTypes, T = unknown> {\n    kind: \"Arg\";\n    fieldName?: string;\n    $inferInput: T;\n    [inputFieldShapeKey]: T;\n    protected pendingActions: ((config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | void)[];\n    private initConfig;\n    private onUseCallbacks;\n    constructor(initConfig: (name: string, field: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>);\n    onConfig(cb: (config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | void): void;\n    updateConfig(cb: (config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | void): void;\n    getConfig(name: string, field: string, typeConfig: PothosTypeConfig): PothosInputFieldConfig<Types>;\n    onFirstUse(cb: (config: PothosInputFieldConfig<Types>) => void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/base-with-fields",
    "content": "declare module '@pothos/core/refs/base-with-fields' {\nimport type { FieldMap, InterfaceParam, PothosInterfaceTypeConfig, PothosMutationTypeConfig, PothosObjectTypeConfig, PothosQueryTypeConfig, PothosSubscriptionTypeConfig, SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { FieldRef } from '@pothos/core/refs/field';\nexport type ObjectLikeConfig = PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig;\nexport declare class TypeRefWithFields<Types extends SchemaTypes, Config extends ObjectLikeConfig | PothosInterfaceTypeConfig> extends BaseTypeRef<Types, Config> {\n    private fields;\n    private fieldCbs;\n    private interfaces;\n    addFields(fields: () => FieldMap): void;\n    addInterfaces(interfaces: InterfaceParam<Types>[] | (() => InterfaceParam<Types>[])): void;\n    onField(cb: (name: string, ref: FieldRef<Types>) => void): void;\n    prepareForBuild(): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/base",
    "content": "declare module '@pothos/core/refs/base' {\nimport type { SchemaTypes } from '@pothos/core/types';\nexport declare class BaseTypeRef<Types extends SchemaTypes, T = unknown> implements PothosSchemaTypes.BaseTypeRef<Types, T> {\n    kind: \"InputObject\" | \"Enum\" | \"Scalar\" | \"List\" | \"Object\" | \"Interface\" | \"Union\" | \"InputList\";\n    name: string;\n    association: BaseTypeRef<Types, T> | string | null;\n    protected configCallbacks: Set<(config: T) => void>;\n    protected preparedForBuild: boolean;\n    private currentConfig;\n    constructor(kind: 'Enum' | 'InputList' | 'InputObject' | 'Interface' | 'List' | 'Object' | 'Scalar' | 'Union', name: string, config?: T | null);\n    toString(): string;\n    associate(ref: BaseTypeRef<Types, T> | string): void;\n    onConfig(cb: (config: T) => T | void): void;\n    updateConfig(config: T | ((oldConfig: T) => T)): void;\n    prepareForBuild(): void;\n    protected onceOnConfig(cb: (config: T) => T | void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/builtin-scalar",
    "content": "declare module '@pothos/core/refs/builtin-scalar' {\nimport type { GraphQLScalarType } from 'graphql';\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ScalarRef } from '@pothos/core/refs/scalar';\nexport declare class BuiltinScalarRef<Types extends SchemaTypes, T, U> extends ScalarRef<Types, T, U> {\n    type: GraphQLScalarType<unknown, unknown>;\n    constructor(type: GraphQLScalarType);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/enum",
    "content": "declare module '@pothos/core/refs/enum' {\nimport { type InputRef, inputShapeKey, type OutputRef, outputShapeKey, type PothosEnumTypeConfig, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class EnumRef<Types extends SchemaTypes, T, U = T> extends BaseTypeRef<Types, PothosEnumTypeConfig> implements OutputRef<T>, InputRef<U>, PothosSchemaTypes.EnumRef<Types, T, U> {\n    kind: \"Enum\";\n    $inferType: T;\n    $inferInput: U;\n    [outputShapeKey]: T;\n    [inputShapeKey]: U;\n    constructor(name: string, config?: PothosEnumTypeConfig);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/field",
    "content": "declare module '@pothos/core/refs/field' {\nimport { type FieldKind, outputFieldShapeKey, type PothosOutputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> implements PothosSchemaTypes.FieldRef<Types, T, Kind> {\n    kind: FieldKind;\n    fieldName?: string;\n    $inferType: T;\n    [outputFieldShapeKey]: T;\n    protected pendingActions: ((config: PothosOutputFieldConfig<Types>) => PothosOutputFieldConfig<Types> | undefined)[];\n    private initConfig;\n    private onUseCallbacks;\n    constructor(kind: Kind, initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosOutputFieldConfig<Types>);\n    updateConfig(cb: (config: PothosOutputFieldConfig<Types>) => PothosOutputFieldConfig<Types> | undefined): void;\n    getConfig(name: string, typeConfig: PothosTypeConfig): PothosOutputFieldConfig<Types>;\n    onFirstUse(cb: (config: PothosOutputFieldConfig<Types>) => void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input-field",
    "content": "declare module '@pothos/core/refs/input-field' {\nimport { inputFieldShapeKey, type PothosInputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class InputFieldRef<Types extends SchemaTypes, T = unknown> implements PothosSchemaTypes.InputFieldRef<Types, T> {\n    kind: \"InputObject\";\n    fieldName?: string;\n    $inferInput: T;\n    [inputFieldShapeKey]: T;\n    protected pendingActions: ((config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | undefined)[];\n    private initConfig;\n    private onUseCallbacks;\n    constructor(initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>);\n    updateConfig(cb: (config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | undefined): void;\n    getConfig(name: string, typeConfig: PothosTypeConfig): PothosInputFieldConfig<Types>;\n    onFirstUse(cb: (config: PothosInputFieldConfig<Types>) => void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input-list",
    "content": "declare module '@pothos/core/refs/input-list' {\nimport { type InputTypeParam, inputShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class InputListRef<Types extends SchemaTypes, T> extends BaseTypeRef<Types> implements PothosSchemaTypes.InputListRef<Types, T> {\n    kind: \"InputList\";\n    [inputShapeKey]: T;\n    $inferInput: T;\n    listType: InputTypeParam<Types>;\n    required: boolean;\n    constructor(listType: InputTypeParam<Types>, required: boolean);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input-object",
    "content": "declare module '@pothos/core/refs/input-object' {\nimport { type InputFieldMap, type InputFieldsFromShape, type InputRef, inputShapeKey, type PothosInputObjectTypeConfig, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { InputFieldRef } from '@pothos/core/refs/input-field';\nexport declare class InputObjectRef<Types extends SchemaTypes, T> extends BaseTypeRef<Types, PothosInputObjectTypeConfig> implements InputRef<T>, PothosSchemaTypes.InputObjectRef<Types, T> {\n    kind: \"InputObject\";\n    $inferInput: T;\n    [inputShapeKey]: T;\n    private fields;\n    private fieldCbs;\n    constructor(name: string);\n    addFields(fields: () => InputFieldMap): void;\n    onField(cb: (name: string, ref: InputFieldRef<Types>) => void): void;\n}\nexport declare class ImplementableInputObjectRef<Types extends SchemaTypes, T extends object, Resolved = T> extends InputObjectRef<Types, Resolved> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string);\n    implement(options: PothosSchemaTypes.InputObjectTypeOptions<Types, InputFieldsFromShape<Types, T, 'InputObject'>>): InputObjectRef<Types, Resolved>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input",
    "content": "declare module '@pothos/core/refs/input' {\nimport { inputShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class InputTypeRef<Types extends SchemaTypes, T> extends BaseTypeRef<Types> {\n    kind: \"InputObject\" | \"Enum\" | \"Scalar\";\n    $inferInput: T;\n    [inputShapeKey]: T;\n    constructor(kind: 'Enum' | 'InputObject' | 'Scalar', name: string);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/interface",
    "content": "declare module '@pothos/core/refs/interface' {\nimport { type InterfaceParam, type InterfaceTypeOptions, type OutputRef, outputShapeKey, type PothosInterfaceTypeConfig, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { TypeRefWithFields } from '@pothos/core/refs/base-with-fields';\nexport declare class InterfaceRef<Types extends SchemaTypes, T, P = T> extends TypeRefWithFields<Types, PothosInterfaceTypeConfig> implements OutputRef<T>, PothosSchemaTypes.InterfaceRef<Types, T, P> {\n    kind: \"Interface\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    constructor(name: string, config?: PothosInterfaceTypeConfig);\n}\nexport declare class ImplementableInterfaceRef<Types extends SchemaTypes, Shape, Parent = Shape> extends InterfaceRef<Types, Shape, Parent> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string);\n    implement<const Interfaces extends InterfaceParam<Types>[]>(options: InterfaceTypeOptions<Types, ImplementableInterfaceRef<Types, Shape, Parent>, Parent, Interfaces>): PothosSchemaTypes.InterfaceRef<Types, Shape, Parent>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/list",
    "content": "declare module '@pothos/core/refs/list' {\nimport { outputShapeKey, parentShapeKey, type SchemaTypes, type TypeParam } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class ListRef<Types extends SchemaTypes, T, P = T> extends BaseTypeRef<Types> implements PothosSchemaTypes.ListRef<Types, T, P> {\n    kind: \"List\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    listType: TypeParam<Types>;\n    nullable: boolean;\n    constructor(listType: TypeParam<Types>, nullable: boolean);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/mutation",
    "content": "declare module '@pothos/core/refs/mutation' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ObjectRef } from '@pothos/core/refs/object';\nexport declare class MutationRef<Types extends SchemaTypes> extends ObjectRef<Types, Types['Root']> {\n    kind: \"Object\";\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/object",
    "content": "declare module '@pothos/core/refs/object' {\nimport { type InterfaceParam, type ObjectTypeOptions, type OutputRef, outputShapeKey, type PothosMutationTypeConfig, type PothosObjectTypeConfig, type PothosQueryTypeConfig, type PothosSubscriptionTypeConfig, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { TypeRefWithFields } from '@pothos/core/refs/base-with-fields';\nexport type ObjectLikeConfig = PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig;\nexport declare class ObjectRef<Types extends SchemaTypes, T, P = T> extends TypeRefWithFields<Types, ObjectLikeConfig> implements OutputRef<T>, PothosSchemaTypes.ObjectRef<Types, T, P> {\n    kind: \"Object\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    constructor(name: string, config?: ObjectLikeConfig);\n}\nexport declare class ImplementableObjectRef<Types extends SchemaTypes, Shape, Parent = Shape> extends ObjectRef<Types, Shape, Parent> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string);\n    implement<const Interfaces extends InterfaceParam<Types>[]>(options: Omit<ObjectTypeOptions<Types, ImplementableObjectRef<Types, Shape, Parent>, Parent, Interfaces>, 'name'>): PothosSchemaTypes.ObjectRef<Types, Shape, Parent>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/output",
    "content": "declare module '@pothos/core/refs/output' {\nimport { outputShapeKey, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class OutputTypeRef<Types extends SchemaTypes, T, P = T> extends BaseTypeRef<Types> {\n    kind: \"Enum\" | \"Scalar\" | \"Object\" | \"Interface\" | \"Union\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    constructor(kind: 'Enum' | 'Interface' | 'Object' | 'Scalar' | 'Union', name: string);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/query",
    "content": "declare module '@pothos/core/refs/query' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ObjectRef } from '@pothos/core/refs/object';\nexport declare class QueryRef<Types extends SchemaTypes> extends ObjectRef<Types, Types['Root']> {\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/scalar",
    "content": "declare module '@pothos/core/refs/scalar' {\nimport { type InputRef, inputShapeKey, type OutputRef, outputShapeKey, type PothosScalarTypeConfig, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class ScalarRef<Types extends SchemaTypes, T, U, P = T> extends BaseTypeRef<Types, PothosScalarTypeConfig> implements OutputRef<T>, InputRef<U>, PothosSchemaTypes.ScalarRef<Types, T, U, P> {\n    kind: \"Scalar\";\n    $inferType: T;\n    $inferInput: U;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    [inputShapeKey]: U;\n    constructor(name: string, config?: PothosScalarTypeConfig);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/subscription",
    "content": "declare module '@pothos/core/refs/subscription' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ObjectRef } from '@pothos/core/refs/object';\nexport declare class SubscriptionRef<Types extends SchemaTypes> extends ObjectRef<Types, Types['Root']> {\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/union",
    "content": "declare module '@pothos/core/refs/union' {\nimport type { PothosUnionTypeConfig, SchemaTypes } from '@pothos/core/types';\nimport { type ObjectParam, type OutputRef, outputShapeKey, parentShapeKey } from '@pothos/core/types/type-params';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class UnionRef<Types extends SchemaTypes, T, P = T> extends BaseTypeRef<Types, PothosUnionTypeConfig> implements OutputRef<T>, PothosSchemaTypes.UnionRef<Types, T, P> {\n    kind: \"Union\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    private types;\n    constructor(name: string, config?: PothosUnionTypeConfig);\n    addTypes(types: ObjectParam<Types>[] | (() => ObjectParam<Types>[])): void;\n    prepareForBuild(): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/types/builder-options",
    "content": "declare module '@pothos/core/types/builder-options' {\nimport type { GraphQLResolveInfo } from 'graphql';\nimport type { ArgumentRef } from '@pothos/core/refs/arg';\nimport type { InputFieldRef } from '@pothos/core/refs/input-field';\nimport type { InterfaceRef } from '@pothos/core/refs/interface';\nimport type { ObjectRef } from '@pothos/core/refs/object';\nimport type { SchemaTypes, VersionedSchemaBuilderOptions } from '@pothos/core/types/schema-types';\nimport type { BaseEnum, EnumParam, FieldNullability, GenericFieldRef, GenericInputFieldRef, ParentShape as GetParentShape, InputRef, InterfaceParam, inputFieldShapeKey, ObjectParam, ShapeFromTypeParam, TypeParam } from '@pothos/core/types/type-params';\nimport type { MaybePromise, Merge, Normalize, NormalizeNullableFields, RemoveNeverKeys, Simplify } from '@pothos/core/types/utils';\nexport type AddVersionedDefaultsToBuilderOptions<Types extends SchemaTypes, Version extends keyof VersionedSchemaBuilderOptions<SchemaTypes>> = PothosSchemaTypes.SchemaBuilderOptions<Types> extends infer Options ? VersionedSchemaBuilderOptions<Types>[Version] extends infer Defaults ? RemoveNeverKeys<Defaults & Omit<Options, keyof Defaults>> : never : never;\nexport type NormalizeSchemeBuilderOptions<Types extends SchemaTypes> = RemoveNeverKeys<PothosSchemaTypes.SchemaBuilderOptions<Types>>;\nexport type Resolver<Parent, Args, Context, Type, Return = unknown> = (parent: Parent, args: Args, context: Context, info: GraphQLResolveInfo) => [Type] extends [readonly (infer Item)[] | null | undefined] ? ListResolveValue<Type, Item, Return> : MaybePromise<Type>;\nexport type ListResolveValue<Type, Item, Return> = unknown extends AsyncIterable<unknown> ? Return extends readonly unknown[] ? ArrayResolverResult<Type, Item, Return> : IterableResolverResult<Type, Item> & Return : Return extends AsyncIterable<unknown> ? AsyncIterableResolverResult<Type, Item> & Return : Return extends readonly unknown[] ? ArrayResolverResult<Type, Item, Return> : Return extends Iterable<unknown> ? IterableResolverResult<Type, Item> & Return : (IterableResolverResult<Type, Item> | AsyncIterableResolverResult<Type, Item>) & Return;\ntype ArrayResolverResult<Type, Item, Return> = null extends Type ? Return extends MaybePromise<readonly MaybePromise<Item>[] | null | undefined> ? Return : MaybePromise<readonly MaybePromise<Item>[]> | null | undefined : Return extends MaybePromise<readonly MaybePromise<Item>[]> ? Return : MaybePromise<readonly MaybePromise<Item>[]>;\ntype AsyncIterableResolverResult<Type, Item> = null extends Type ? MaybePromise<AsyncIterable<Item> | null | undefined> : MaybePromise<AsyncIterable<Item>>;\ntype IterableResolverResult<Type, Item> = null extends Type ? MaybePromise<Iterable<MaybePromise<Item>> | null | undefined> : MaybePromise<Iterable<MaybePromise<Item>>>;\nexport type Subscriber<Parent, Args, Context, Shape> = (parent: Parent, args: Args, context: Context, info: GraphQLResolveInfo) => MaybePromise<AsyncIterable<Shape>>;\nexport type EnumValues<Types extends SchemaTypes> = EnumValueConfigMap<Types> | readonly string[];\nexport type EnumValueConfigMap<Types extends SchemaTypes> = Record<string, PothosSchemaTypes.EnumValueConfig<Types>>;\nexport type ShapeFromEnumValues<Types extends SchemaTypes, Values extends EnumValues<Types>> = Values extends readonly string[] ? Values[number] : Values extends EnumValueConfigMap<Types> ? {\n    [K in keyof Values]: Values[K]['value'] extends number | string ? Values[K]['value'] : K;\n}[keyof Values] : never;\nexport type ObjectFieldsShape<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.ObjectFieldBuilder<Types, Shape>) => FieldMap;\nexport type InterfaceFieldsShape<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.InterfaceFieldBuilder<Types, Shape>) => FieldMap;\nexport type QueryFieldsShape<Types extends SchemaTypes> = (t: PothosSchemaTypes.QueryFieldBuilder<Types, Types['Root']>) => FieldMap;\nexport type MutationFieldsShape<Types extends SchemaTypes> = (t: PothosSchemaTypes.MutationFieldBuilder<Types, Types['Root']>) => FieldMap;\nexport type SubscriptionFieldsShape<Types extends SchemaTypes> = (t: PothosSchemaTypes.SubscriptionFieldBuilder<Types, Types['Root']>) => FieldMap;\nexport type ObjectFieldThunk<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.ObjectFieldBuilder<Types, Shape>) => GenericFieldRef<unknown>;\nexport type InterfaceFieldThunk<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.InterfaceFieldBuilder<Types, Shape>) => GenericFieldRef<unknown>;\nexport type QueryFieldThunk<Types extends SchemaTypes> = (t: PothosSchemaTypes.QueryFieldBuilder<Types, Types['Root']>) => GenericFieldRef<unknown>;\nexport type MutationFieldThunk<Types extends SchemaTypes> = (t: PothosSchemaTypes.MutationFieldBuilder<Types, Types['Root']>) => GenericFieldRef<unknown>;\nexport type SubscriptionFieldThunk<Types extends SchemaTypes> = (t: PothosSchemaTypes.SubscriptionFieldBuilder<Types, Types['Root']>) => GenericFieldRef<unknown>;\nexport type FieldMap = Record<string, GenericFieldRef<unknown>>;\nexport type InputFieldMap = Record<string, GenericInputFieldRef<unknown>>;\nexport type FieldOptionsFromKind<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, Kind extends FieldKind, ResolveShape, ResolveReturnShape> = PothosSchemaTypes.FieldOptionsByKind<Types, ParentShape, Type, Nullable, Args, ResolveShape, ResolveReturnShape>[Kind];\nexport type ObjectTypeOptions<Types extends SchemaTypes, Param extends ObjectParam<Types>, Shape, Interfaces extends InterfaceParam<Types>[]> = Normalize<(Param extends string ? {} : Param extends ObjectRef<Types, unknown> ? {\n    name?: string;\n} : {\n    name: string;\n}) & (PothosSchemaTypes.ObjectTypeOptions<Types, Shape> | PothosSchemaTypes.ObjectTypeWithInterfaceOptions<Types, Shape, Interfaces>)>;\nexport type InterfaceTypeOptions<Types extends SchemaTypes, Param extends InterfaceParam<Types>, Shape, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[], ResolveType = unknown> = PothosSchemaTypes.InterfaceTypeOptions<Types, Shape, Interfaces, ResolveType> & (Param extends string ? {} : Param extends InterfaceRef<Types, unknown> ? {\n    name?: string;\n} : {\n    name: string;\n});\nexport type EnumTypeOptions<Types extends SchemaTypes, Param extends EnumParam, Values extends EnumValues<Types>> = Param extends BaseEnum ? Merge<Omit<PothosSchemaTypes.EnumTypeOptions<Types, Values>, 'values'> & {\n    name: string;\n    values?: Partial<Record<keyof Param, Omit<PothosSchemaTypes.EnumValueConfig<Types>, 'value'>>>;\n}> : PothosSchemaTypes.EnumTypeOptions<Types, Values>;\nexport type ArgBuilder<Types extends SchemaTypes> = Omit<PothosSchemaTypes.InputFieldBuilder<Types, 'Arg'>, 'field'> & PothosSchemaTypes.InputFieldBuilder<Types, 'Arg'>['field'];\nexport type ValidateInterfaces<Shape, Types extends SchemaTypes, Interfaces extends InterfaceParam<Types>> = Interfaces extends InterfaceParam<Types> ? Shape extends GetParentShape<Types, Interfaces> ? Interfaces : 'Object shape must extend interface shape' : never;\nexport type OneOfInputShapeFromFields<Fields extends InputFieldMap> = keyof Fields extends infer K extends keyof Fields ? K extends unknown ? Simplify<{\n    [Name in K]: NonNullable<InputShapeFromField<Fields[K]>>;\n} & {\n    [Name in keyof Fields as Name extends K ? never : Name]?: never;\n}> : never : never;\nexport type InputShapeFromFields<Fields extends InputFieldMap> = NormalizeNullableFields<{\n    [K in string & keyof Fields]: InputShapeFromField<Fields[K]>;\n}>;\nexport type InputFieldsFromShape<Types extends SchemaTypes, Shape, Kind extends 'Arg' | 'InputObject'> = {\n    [K in keyof Shape]: Kind extends 'Arg' ? ArgumentRef<Types, Shape[K]> : Kind extends 'InputObject' ? InputFieldRef<Types, Shape[K]> : never;\n};\nexport type InputShapeFromField<Field extends GenericInputFieldRef> = Field extends {\n    [inputFieldShapeKey]: infer T;\n} ? T : never;\nexport type FieldKind = keyof PothosSchemaTypes.FieldOptionsByKind<SchemaTypes, {}, TypeParam<SchemaTypes>, boolean, {}, {}, {}> & keyof PothosSchemaTypes.PothosKindToGraphQLType;\nexport type InputFieldKind = keyof PothosSchemaTypes.InputFieldOptionsByKind<SchemaTypes, InputRef<unknown>, boolean>;\nexport type CompatibleTypes<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>> = {\n    [K in keyof ParentShape]-?: Awaited<ParentShape[K]> extends ShapeFromTypeParam<Types, Type, Nullable> ? K : never;\n}[keyof ParentShape] & string;\nexport type ExposeNullability<Types extends SchemaTypes, Type extends TypeParam<Types>, ParentShape, Name extends keyof ParentShape, Nullable extends FieldNullability<Type>> = Awaited<ParentShape[Name]> extends ShapeFromTypeParam<Types, Type, Nullable> ? {\n    nullable?: ExposeNullableOption<Types, Type, ParentShape, Name> & Nullable;\n} : {\n    nullable: ExposeNullableOption<Types, Type, ParentShape, Name> & Nullable;\n};\nexport type ExposeNullableOption<Types extends SchemaTypes, Type extends TypeParam<Types>, ParentShape, Name extends keyof ParentShape> = FieldNullability<Type> & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean | {\n    items: boolean;\n    list: boolean;\n} : true | {\n    items: boolean;\n    list: true;\n} : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? {\n    items: true;\n    list: boolean;\n} : {\n    items: true;\n    list: true;\n} : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true);\nexport type InferredFieldOptionsKind<Types extends SchemaTypes = SchemaTypes> = keyof PothosSchemaTypes.InferredFieldOptions<Types>;\nexport type InferredFieldOptionsByKind<Types extends SchemaTypes, Kind extends InferredFieldOptionsKind, ResolveShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveReturnShape = unknown> = PothosSchemaTypes.InferredFieldOptions<Types, ResolveShape, Type, Nullable, Args, ResolveReturnShape>[Kind];\nexport type InferredFieldOptionKeys<Kind extends InferredFieldOptionsKind = InferredFieldOptionsKind> = PothosSchemaTypes.InferredFieldOptions<SchemaTypes>[Kind] extends infer Options ? Options extends unknown ? keyof Options : never : never;\nexport {};\n}"
  },
  {
    "moduleName": "@pothos/core/types/configs",
    "content": "declare module '@pothos/core/types/configs' {\nimport type { GraphQLEnumType, GraphQLEnumTypeConfig, GraphQLEnumValueConfig, GraphQLFieldConfig, GraphQLInputFieldConfig, GraphQLInputObjectType, GraphQLInputObjectTypeConfig, GraphQLInterfaceType, GraphQLInterfaceTypeConfig, GraphQLObjectType, GraphQLObjectTypeConfig, GraphQLScalarType, GraphQLScalarTypeConfig, GraphQLUnionType, GraphQLUnionTypeConfig } from 'graphql';\nimport type { FieldKind, FieldOptionsFromKind, InputFieldMap } from '@pothos/core/types/builder-options';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nimport type { FieldNullability, FieldRequiredness, InputType, InputTypeParam, InterfaceParam, ObjectParam, OutputType, TypeParam } from '@pothos/core/types/type-params';\nimport type { MaybePromise, Merge, MergeUnion, PartialResolveInfo } from '@pothos/core/types/utils';\nexport interface PothosQueryTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Query';\n    graphqlKind: 'Object';\n    pothosOptions: PothosSchemaTypes.QueryTypeOptions;\n}\nexport interface PothosMutationTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Mutation';\n    graphqlKind: 'Object';\n    pothosOptions: PothosSchemaTypes.MutationTypeOptions;\n}\nexport interface PothosSubscriptionTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Subscription';\n    graphqlKind: 'Object';\n    pothosOptions: PothosSchemaTypes.SubscriptionTypeOptions;\n}\nexport interface PothosObjectTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Object';\n    graphqlKind: 'Object';\n    interfaces: InterfaceParam<SchemaTypes>[];\n    pothosOptions: PothosSchemaTypes.ObjectTypeOptions;\n}\nexport interface PothosInterfaceTypeConfig extends Omit<GraphQLInterfaceTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Interface';\n    graphqlKind: 'Interface';\n    interfaces: InterfaceParam<SchemaTypes>[];\n    pothosOptions: PothosSchemaTypes.InterfaceTypeOptions;\n}\nexport interface PothosUnionTypeConfig extends Omit<GraphQLUnionTypeConfig<unknown, object>, 'types'> {\n    kind: 'Union';\n    graphqlKind: 'Union';\n    types: ObjectParam<SchemaTypes>[];\n    pothosOptions: PothosSchemaTypes.UnionTypeOptions;\n}\nexport interface PothosEnumTypeConfig extends GraphQLEnumTypeConfig {\n    kind: 'Enum';\n    graphqlKind: 'Enum';\n    pothosOptions: PothosSchemaTypes.EnumTypeOptions;\n}\nexport interface PothosScalarTypeConfig extends GraphQLScalarTypeConfig<unknown, unknown> {\n    kind: 'Scalar';\n    graphqlKind: 'Scalar';\n    pothosOptions: PothosSchemaTypes.ScalarTypeOptions;\n}\nexport interface PothosInputObjectTypeConfig extends Omit<GraphQLInputObjectTypeConfig, 'fields'> {\n    kind: 'InputObject';\n    graphqlKind: 'InputObject';\n    pothosOptions: PothosSchemaTypes.InputObjectTypeOptions;\n}\nexport type PothosTypeConfig = PothosEnumTypeConfig | PothosInputObjectTypeConfig | PothosInterfaceTypeConfig | PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosScalarTypeConfig | PothosSubscriptionTypeConfig | PothosUnionTypeConfig;\nexport type PothosTypeKind = PothosTypeConfig['kind'];\nexport type PothosKindToGraphQLTypeClass<T extends PothosTypeKind> = {\n    Object: GraphQLObjectType;\n    Interface: GraphQLInterfaceType;\n    Union: GraphQLUnionType;\n    Enum: GraphQLEnumType;\n    Scalar: GraphQLScalarType;\n    InputObject: GraphQLInputObjectType;\n}[PothosSchemaTypes.PothosKindToGraphQLType[T]];\nexport type PothosFieldKindToConfig<Types extends SchemaTypes, Kind extends FieldKind> = {\n    [K in FieldKind]: Merge<Omit<GraphQLFieldConfig<unknown, object>, 'args' | 'type'> & {\n        kind: K;\n        graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[K];\n        parentType: string;\n        name: string;\n        type: PothosOutputFieldType<Types>;\n        args: Record<string, PothosInputFieldConfig<Types>>;\n        argMappers: ((args: Record<string, unknown>, context: Types['Context'], info: PartialResolveInfo) => MaybePromise<Record<string, unknown>>)[];\n        pothosOptions: FieldOptionsFromKind<Types, unknown, TypeParam<Types>, FieldNullability<[unknown]>, InputFieldMap, K, unknown, unknown> & MergeUnion<{\n            [K in keyof PothosSchemaTypes.InferredFieldOptions<SchemaTypes>]: PothosSchemaTypes.InferredFieldOptions<SchemaTypes>[K];\n        }[keyof PothosSchemaTypes.InferredFieldOptions<SchemaTypes>]>;\n    }>;\n}[Kind];\nexport interface PothosInputFieldConfig<Types extends SchemaTypes> extends Omit<GraphQLInputFieldConfig, 'type'> {\n    kind: 'Arg' | 'InputObject';\n    graphqlKind: 'Arg' | 'InputObject';\n    name: string;\n    parentField: string | undefined;\n    parentType: string;\n    type: PothosInputFieldType<Types>;\n    pothosOptions: PothosSchemaTypes.InputFieldOptionsByKind<Types, InputTypeParam<Types>, FieldRequiredness<[unknown]>>[keyof PothosSchemaTypes.InputFieldOptionsByKind];\n}\nexport interface PothosEnumValueConfig<Types extends SchemaTypes> extends GraphQLEnumValueConfig {\n    pothosOptions: PothosSchemaTypes.EnumValueConfig<Types>;\n}\nexport type PothosOutputFieldConfig<Types extends SchemaTypes> = PothosFieldKindToConfig<Types, FieldKind>;\nexport type PothosFieldConfig<Types extends SchemaTypes> = PothosInputFieldConfig<Types> | PothosOutputFieldConfig<Types>;\nexport type GraphQLFieldKind = PothosFieldConfig<SchemaTypes>['graphqlKind'];\nexport type PothosOutputFieldType<Types extends SchemaTypes> = {\n    kind: 'Enum' | 'Interface' | 'Object' | 'Scalar' | 'Union';\n    ref: OutputType<Types>;\n    nullable: boolean;\n} | {\n    kind: 'List';\n    type: PothosOutputFieldType<Types>;\n    nullable: boolean;\n};\nexport type PothosNameOutputFieldType<Types extends SchemaTypes> = Exclude<PothosOutputFieldType<Types>, {\n    kind: 'List';\n}>;\nexport type PothosInputFieldType<Types extends SchemaTypes> = {\n    kind: 'Enum' | 'InputObject' | 'Scalar';\n    ref: InputType<Types>;\n    required: boolean;\n} | {\n    kind: 'List';\n    type: PothosInputFieldType<Types>;\n    required: boolean;\n};\nexport type PothosNameInputFieldType<Types extends SchemaTypes> = Exclude<PothosInputFieldType<Types>, {\n    kind: 'List';\n}>;\n}"
  },
  {
    "moduleName": "@pothos/core/types/global",
    "content": "declare module '@pothos/core/types/global' {\nimport '@pothos/core/types/global/type-options';\nimport '@pothos/core/types/global/field-options';\nimport '@pothos/core/types/global/classes';\nimport '@pothos/core/types/global/schema-types';\n}"
  },
  {
    "moduleName": "@pothos/core/types",
    "content": "declare module '@pothos/core/types' {\nimport '@pothos/core/types/global';\nexport * from '@pothos/core/types/builder-options';\nexport * from '@pothos/core/types/configs';\nexport * from '@pothos/core/types/plugins';\nexport * from '@pothos/core/types/schema-types';\nexport * from '@pothos/core/types/type-params';\nexport * from '@pothos/core/types/utils';\n}"
  },
  {
    "moduleName": "@pothos/core/types/plugins",
    "content": "declare module '@pothos/core/types/plugins' {\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { BasePlugin } from '@pothos/core/plugins/plugin';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nexport type PluginConstructorMap<Types extends SchemaTypes> = {\n    [K in keyof PothosSchemaTypes.Plugins<SchemaTypes>]: new (buildCache: BuildCache<SchemaTypes>, name: K) => BasePlugin<Types> & PothosSchemaTypes.Plugins<Types>[K];\n};\nexport type PluginMap<Types extends SchemaTypes> = {\n    [K in keyof PluginConstructorMap<Types>]: InstanceType<PluginConstructorMap<Types>[K]>;\n};\nexport type PluginName = keyof PluginConstructorMap<SchemaTypes>;\n}"
  },
  {
    "moduleName": "@pothos/core/types/schema-types",
    "content": "declare module '@pothos/core/types/schema-types' {\nimport type { InferredFieldOptionsKind } from '@pothos/core/types/builder-options';\nexport interface SchemaTypes extends PothosSchemaTypes.UserSchemaTypes {\n    outputShapes: {\n        String: unknown;\n        ID: unknown;\n        Int: unknown;\n        Float: unknown;\n        Boolean: unknown;\n    };\n    inputShapes: {\n        String: unknown;\n        ID: unknown;\n        Int: unknown;\n        Float: unknown;\n        Boolean: unknown;\n    };\n    Objects: {};\n    Inputs: {};\n    Interfaces: {};\n    Scalars: {\n        String: {\n            Input: unknown;\n            Output: unknown;\n        };\n        ID: {\n            Input: unknown;\n            Output: unknown;\n        };\n        Int: {\n            Input: unknown;\n            Output: unknown;\n        };\n        Float: {\n            Input: unknown;\n            Output: unknown;\n        };\n        Boolean: {\n            Input: unknown;\n            Output: unknown;\n        };\n    };\n    DefaultFieldNullability: boolean;\n    DefaultInputFieldRequiredness: boolean;\n    InferredFieldOptionsKind: InferredFieldOptionsKind;\n    Root: object;\n    Context: object;\n}\nexport type MergedScalars<PartialTypes extends Partial<PothosSchemaTypes.UserSchemaTypes>> = (PartialTypes['Defaults'] extends 'v3' ? V3DefaultScalars : DefaultScalars) extends infer Defaults ? SchemaTypes['Scalars'] & {\n    [K in keyof Defaults | keyof PartialTypes['Scalars']]: K extends keyof PartialTypes['Scalars'] ? PartialTypes['Scalars'][K] : K extends keyof Defaults ? Defaults[K] : never;\n} : never;\nexport interface VersionedSchemaBuilderOptions<Types extends SchemaTypes> {\n    v3: PothosSchemaTypes.V3SchemaBuilderOptions<Types>;\n}\nexport interface DefaultsByVersion {\n    v3: PothosSchemaTypes.V3DefaultSchemaTypes;\n}\nexport interface DefaultScalars {\n    String: {\n        Input: string;\n        Output: string;\n    };\n    ID: {\n        Input: string;\n        Output: bigint | number | string;\n    };\n    Int: {\n        Input: number;\n        Output: number;\n    };\n    Float: {\n        Input: number;\n        Output: number;\n    };\n    Boolean: {\n        Input: boolean;\n        Output: boolean;\n    };\n}\nexport interface V3DefaultScalars {\n    String: {\n        Input: string;\n        Output: string;\n    };\n    ID: {\n        Input: number | string;\n        Output: number | string;\n    };\n    Int: {\n        Input: number;\n        Output: number;\n    };\n    Float: {\n        Input: number;\n        Output: number;\n    };\n    Boolean: {\n        Input: boolean;\n        Output: boolean;\n    };\n}\nexport type BaseScalarNames = 'Boolean' | 'Float' | 'ID' | 'Int' | 'String';\nexport type ScalarName<Types extends SchemaTypes> = string & (BaseScalarNames | keyof Types['Scalars']);\nexport type RootName = 'Mutation' | 'Query' | 'Subscription';\n}"
  },
  {
    "moduleName": "@pothos/core/types/type-params",
    "content": "declare module '@pothos/core/types/type-params' {\nimport type { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { InterfaceRef } from '@pothos/core/refs/interface';\nimport type { ObjectRef } from '@pothos/core/refs/object';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nexport declare const outputShapeKey: unique symbol;\nexport declare const parentShapeKey: unique symbol;\nexport declare const abstractReturnShapeKey: unique symbol;\nexport declare const inputShapeKey: unique symbol;\nexport declare const inputFieldShapeKey: unique symbol;\nexport declare const outputFieldShapeKey: unique symbol;\nexport declare const typeBrandKey: unique symbol;\nexport type OutputShape<Types extends SchemaTypes, T> = T extends {\n    [outputShapeKey]: infer U;\n} ? U : T extends new (...args: any[]) => infer U ? U extends {\n    [outputShapeKey]: infer V;\n} ? V : U : T extends keyof Types['outputShapes'] ? Types['outputShapes'][T] : T extends BaseEnum ? ValuesFromEnum<T> : never;\nexport type ParentShape<Types extends SchemaTypes, T> = T extends {\n    [parentShapeKey]: infer U;\n} ? U : OutputShape<Types, T>;\nexport type AbstractReturnShape<Types extends SchemaTypes, T, ResolveType = unknown> = unknown extends ResolveType ? T extends {\n    [abstractReturnShapeKey]: infer U;\n} ? U : OutputShape<Types, T> : OutputShape<Types, T>;\nexport type InputShape<Types extends SchemaTypes, T> = T extends {\n    [inputShapeKey]: infer U;\n} ? U : T extends new (...args: any[]) => infer U ? U extends {\n    [inputShapeKey]: infer V;\n} ? V : U : T extends keyof Types['inputShapes'] ? Types['inputShapes'][T] : T extends BaseEnum ? ValuesFromEnum<T> : never;\nexport interface OutputRefShape<T> {\n    [outputShapeKey]: T;\n}\nexport interface InputRefShape<T> {\n    [inputShapeKey]: T;\n}\nexport interface OutputRef<T = unknown> {\n    [outputShapeKey]: T;\n    name: string;\n    kind: 'Enum' | 'Interface' | 'Object' | 'Scalar' | 'Union';\n}\nexport interface InputRef<T = unknown> {\n    [inputShapeKey]: T;\n    name: string;\n    kind: 'Enum' | 'InputList' | 'InputObject' | 'Scalar';\n}\nexport type OutputType<Types extends SchemaTypes> = BaseEnum | keyof Types['outputShapes'] | (new (...args: any[]) => any) | {\n    [outputShapeKey]: unknown;\n};\nexport type InputType<Types extends SchemaTypes> = BaseEnum | keyof Types['inputShapes'] | {\n    [inputShapeKey]: unknown;\n};\nexport type ConfigurableRef<Types extends SchemaTypes> = BaseTypeRef<Types, unknown> | InputType<Types> | OutputType<Types>;\nexport type TypeParam<Types extends SchemaTypes> = OutputType<Types> | [OutputType<Types>];\nexport type InputTypeParam<Types extends SchemaTypes> = InputType<Types> | [InputType<Types>];\nexport type ObjectParam<Types extends SchemaTypes> = Extract<OutputType<Types>, keyof Types['Objects']> | ObjectRef<Types, unknown> | (new (...args: any[]) => any);\nexport type InterfaceParam<Types extends SchemaTypes> = Extract<OutputType<Types>, keyof Types['Interfaces']> | InterfaceRef<Types, unknown> | (new (...args: any[]) => unknown);\nexport interface BaseEnum {\n    [s: string]: number | string;\n    [s: number]: string;\n}\nexport type ValuesFromEnum<T extends BaseEnum> = T[keyof T];\nexport type EnumParam = BaseEnum | string;\nexport type ShapeWithNullability<Types extends SchemaTypes, Shape, Nullable extends boolean> = boolean extends Nullable ? Types['DefaultFieldNullability'] extends true ? Shape | null | undefined : Shape : Nullable extends true ? Shape | null | undefined : Shape;\nexport type ShapeFromTypeParam<Types extends SchemaTypes, Param extends TypeParam<Types>, Nullable extends FieldNullability<Param>> = Param extends [OutputType<Types>] ? ShapeFromListTypeParam<Types, Param, Nullable> : FieldNullability<Param> extends Nullable ? Types['DefaultFieldNullability'] extends true ? OutputShape<Types, Param> | null | undefined : OutputShape<Types, Param> : Nullable extends true ? OutputShape<Types, Param> | null | undefined : OutputShape<Types, Param>;\nexport type ShapeFromListTypeParam<Types extends SchemaTypes, Param extends [OutputType<Types>], Nullable extends FieldNullability<Param>> = FieldNullability<Param> extends Nullable ? Types['DefaultFieldNullability'] extends true ? readonly OutputShape<Types, Param[0]>[] | null | undefined : readonly OutputShape<Types, Param[0]>[] : Nullable extends true ? readonly OutputShape<Types, Param[0]>[] | null | undefined : Nullable extends false ? readonly OutputShape<Types, Param[0]>[] : Nullable extends {\n    list: infer List;\n    items: infer Items;\n} ? Items extends boolean ? List extends true ? readonly ShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] | null | undefined : readonly ShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] : never : never;\nexport type FieldNullability<Param> = boolean | (Param extends [unknown] ? boolean | {\n    items: boolean;\n    list: boolean;\n} : boolean);\nexport type InputShapeFromTypeParam<Types extends SchemaTypes, Param extends InputTypeParam<Types>, Required extends FieldRequiredness<Param>> = Param extends [InputType<Types>] ? InputShapeFromListTypeParam<Types, Param, Required> : FieldRequiredness<Param> extends Required ? Types['DefaultInputFieldRequiredness'] extends false ? InputShape<Types, Param> | null | undefined : InputShape<Types, Param> : Required extends true ? InputShape<Types, Param> : InputShape<Types, Param> | null | undefined;\nexport type InputShapeFromListTypeParam<Types extends SchemaTypes, Param extends [InputType<Types>], Required extends FieldRequiredness<Param>> = FieldRequiredness<Param> extends Required ? Types['DefaultInputFieldRequiredness'] extends false ? InputShape<Types, Param[0]>[] | null | undefined : InputShape<Types, Param[0]>[] : Required extends true ? InputShape<Types, Param[0]>[] : Required extends false ? InputShape<Types, Param[0]>[] | null | undefined : FieldRequiredness<Param> extends Required ? InputShape<Types, Param[0]>[] | null | undefined : Required extends boolean | {\n    list: infer List;\n    items: infer Items;\n} ? Items extends boolean ? List extends true ? InputShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] : InputShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] | null | undefined : never : never;\nexport type FieldRequiredness<Param> = boolean | (Param extends [unknown] ? boolean | {\n    items: boolean;\n    list: boolean;\n} : boolean);\nexport type InputOrArgRef<Types extends SchemaTypes, T, Kind extends 'Arg' | 'InputObject'> = Kind extends 'Arg' ? PothosSchemaTypes.ArgumentRef<Types, T> : Kind extends 'InputObject' ? PothosSchemaTypes.InputFieldRef<Types, T> : never;\nexport interface GenericFieldRef<T = unknown> {\n    [outputFieldShapeKey]: T;\n}\nexport interface GenericInputFieldRef<T = unknown> {\n    [inputFieldShapeKey]: T;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/types/utils",
    "content": "declare module '@pothos/core/types/utils' {\nimport type { GraphQLResolveInfo } from 'graphql';\nexport type MaybePromise<T> = Promise<T> | T;\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\nexport type RequiredKeys<T extends object> = Exclude<keyof T, OptionalKeys<T>>;\nexport type OptionalKeys<T extends object> = {\n    [K in keyof T]: T[K] | undefined extends T[K] ? K : T[K] | null extends T[K] ? K : never;\n}[keyof T];\nexport type NonEmptyKeys<T extends object> = undefined extends {} ? never : {\n    [K in keyof T]: {} extends T[K] ? never : T[K] extends NonNullable<T[K]> ? K : never;\n}[keyof T];\nexport type EmptyKeys<T extends object> = {\n    [K in keyof T]: {} extends T[K] ? K : T[K] extends NonNullable<T[K]> ? never : K;\n}[keyof T];\nexport type Normalize<T> = T extends object ? {\n    [K in keyof T]: T[K];\n} : T;\nexport type NullableToOptional<T> = T extends object ? Normalize<{\n    [K in OptionalKeys<T>]?: T[K];\n} & {\n    [K in RequiredKeys<T>]: T[K];\n}> : T;\nexport type EmptyToOptional<T> = T extends object ? Normalize<{\n    [K in EmptyKeys<T> | OptionalKeys<T>]?: T[K];\n} & {\n    [K in NonEmptyKeys<T>]: T[K];\n}> : T;\nexport type NormalizeNullable<T> = undefined extends T ? T | null | undefined : null extends T ? T | null | undefined : T;\nexport type NormalizeNullableFields<T extends object> = Normalize<{\n    [K in OptionalKeys<T>]?: T[K] | null | undefined;\n} & {\n    [K in RequiredKeys<T>]: T[K];\n}>;\nexport type IsSimpleRecord<T> = ([\n    T\n] extends [\n    Record<string, any>\n] ? keyof T extends infer K ? K extends string ? T[K] extends (...args: any[]) => unknown ? [\n    1\n] extends [T[K]] ? never : false : never : never : false : false) extends never ? true : false;\nexport type RecursivelyNormalizeNullableFields<T> = T extends null | undefined ? null | undefined : T extends (infer L)[] ? RecursivelyNormalizeNullableFields<L>[] : T extends (...args: any[]) => unknown ? T : keyof T extends string ? IsSimpleRecord<T> extends true ? Normalize<{\n    [K in OptionalKeys<T & object>]?: K extends string ? RecursivelyNormalizeNullableFields<NonNullable<T[K]>> | null | undefined : T[K];\n} & {\n    [K in RequiredKeys<T & object>]: RecursivelyNormalizeNullableFields<NonNullable<T[K]>>;\n}> : T : T;\nexport type RemoveNeverKeys<T extends {}> = {\n    [K in keyof T as [T[K]] extends [never] ? never : K]: T[K];\n};\nexport type Merge<T> = {\n    [K in keyof T]: T[K];\n} & {};\nexport type MergeUnion<T, Keys extends keyof T = T extends unknown ? keyof T : never> = Merge<T extends unknown ? {\n    [K in Keys as K extends keyof T ? never : K]?: never;\n} & {\n    [K in Keys as K extends keyof T ? K : never]: T[K & keyof T];\n} : never>;\nexport interface Path {\n    prev: Path | undefined;\n    key: number | string;\n    typename: string | undefined;\n}\nexport type LastIndex<T extends unknown[]> = T extends [unknown, ...infer U] ? U['length'] : 0;\nexport type NormalizeArgs<T extends unknown[], Index extends keyof T = LastIndex<T>> = undefined extends T[Index] ? {} extends T[Index] ? undefined extends {} ? {\n    [K in keyof T]?: T[K];\n} : T : {\n    [K in keyof T]-?: T[K];\n} : {} extends T[Index] ? {\n    [K in keyof T]?: T[K];\n} : T;\nexport type IsStrictMode = undefined extends {} ? false : true;\nexport interface PartialResolveInfo {\n    fragments: GraphQLResolveInfo['fragments'];\n    variableValues: GraphQLResolveInfo['variableValues'];\n    schema: GraphQLResolveInfo['schema'];\n}\nexport type Simplify<T> = {\n    [KeyType in keyof T]: T[KeyType];\n} & {};\nexport type DistributeOmit<T, K> = T extends {} ? {\n    [K2 in keyof T as K2 extends K ? never : K2]: T[K2];\n} & {} : T;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/base64",
    "content": "declare module '@pothos/core/utils/base64' {\nexport declare function encodeBase64(value: string): string;\nexport declare function decodeBase64(value: string): string;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/context-cache",
    "content": "declare module '@pothos/core/utils/context-cache' {\nexport declare const contextCacheSymbol: unique symbol;\nexport declare function initContextCache(): {\n    [contextCacheSymbol]: {};\n};\nexport interface ContextCache<T, C extends object, Args extends unknown[]> {\n    (context: C, ...args: Args): T;\n    delete: (context: C) => void;\n}\nexport declare function createContextCache<T, C extends object = object, Args extends unknown[] = []>(create: (context: C, ...args: Args) => T): ContextCache<T, C, Args>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/enums",
    "content": "declare module '@pothos/core/utils/enums' {\nimport type { BaseEnum, EnumValues, PothosEnumValueConfig, SchemaTypes } from '@pothos/core/types';\nexport declare function normalizeEnumValues<Types extends SchemaTypes>(values: EnumValues<SchemaTypes>): Record<string, PothosEnumValueConfig<Types>>;\nexport declare function valuesFromEnum<Types extends SchemaTypes>(Enum: BaseEnum, values?: Record<string, Omit<PothosSchemaTypes.EnumValueConfig<Types>, 'value'>>): Record<string, PothosEnumValueConfig<Types>>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils",
    "content": "declare module '@pothos/core/utils' {\nimport { type DirectiveNode, type FieldNode, type GraphQLDirective, type GraphQLField } from 'graphql';\nimport { type InputType, type InputTypeParam, type MaybePromise, type OutputType, type PartialResolveInfo, type SchemaTypes, type TypeParam } from '@pothos/core/types';\nexport * from '@pothos/core/utils/base64';\nexport * from '@pothos/core/utils/context-cache';\nexport * from '@pothos/core/utils/enums';\nexport * from '@pothos/core/utils/input';\nexport * from '@pothos/core/utils/params';\nexport * from '@pothos/core/utils/sort-classes';\nexport declare function assertNever(value: never): never;\nexport declare function assertArray(value: unknown): value is unknown[];\nexport declare function isThenable(value: unknown): value is PromiseLike<unknown>;\nexport declare function verifyRef(ref: unknown): void;\nexport declare function verifyInterfaces(interfaces: unknown): void;\nexport declare function brandWithType<Types extends SchemaTypes>(val: unknown, type: OutputType<Types>): void;\nexport declare function getTypeBrand(val: unknown): OutputType<SchemaTypes> | null;\nexport declare function unwrapListParam<Types extends SchemaTypes>(param: InputTypeParam<Types> | TypeParam<Types>): InputType<Types> | OutputType<Types>;\nexport declare function unwrapOutputListParam<Types extends SchemaTypes>(param: TypeParam<Types>): OutputType<Types>;\nexport declare function unwrapInputListParam<Types extends SchemaTypes>(param: InputTypeParam<Types>): InputType<Types>;\n/**\n * Helper for allowing plugins to fulfill the return of the `next` resolver, without paying the cost of the\n * Promise if not required.\n */\nexport declare function completeValue<T, R>(valOrPromise: PromiseLike<T> | T, onSuccess: (completedVal: T) => PromiseLike<R> | R, onError?: (errVal: unknown) => PromiseLike<R> | R): Promise<Awaited<R>> | Awaited<R>;\nexport declare function getMappedArgumentValues(def: GraphQLDirective | GraphQLField<unknown, unknown>, node: DirectiveNode | FieldNode, context: object, info: PartialResolveInfo): MaybePromise<{\n    [argument: string]: unknown;\n}>;\nexport declare function reduceMaybeAsync<T, R>(items: T[], initialValue: R, fn: (value: R, item: T, i: number) => MaybePromise<R>): MaybePromise<R>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/input",
    "content": "declare module '@pothos/core/utils/input' {\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { PothosInputFieldConfig, PothosInputFieldType, PothosTypeConfig, SchemaTypes } from '@pothos/core/types';\nexport interface InputTypeFieldsMapping<Types extends SchemaTypes, T> {\n    configs: Record<string, PothosInputFieldConfig<Types>>;\n    map: InputFieldsMapping<Types, T> | null;\n}\nexport type InputFieldMapping<Types extends SchemaTypes, T> = {\n    kind: 'Enum';\n    isList: boolean;\n    listDepth: number;\n    config: PothosInputFieldConfig<Types>;\n    value: T;\n} | {\n    kind: 'InputObject';\n    config: PothosInputFieldConfig<Types>;\n    isList: boolean;\n    listDepth: number;\n    value: T | null;\n    fields: InputTypeFieldsMapping<Types, T>;\n} | {\n    kind: 'Scalar';\n    isList: boolean;\n    listDepth: number;\n    config: PothosInputFieldConfig<Types>;\n    value: T;\n};\nexport type InputFieldsMapping<Types extends SchemaTypes, T> = Map<string, InputFieldMapping<Types, T>>;\nexport declare function resolveInputTypeConfig<Types extends SchemaTypes>(type: PothosInputFieldType<Types>, buildCache: BuildCache<Types>): Extract<PothosTypeConfig, {\n    kind: 'Enum' | 'InputObject' | 'Scalar';\n}>;\nexport declare function mapInputFields<Types extends SchemaTypes, T>(inputs: Record<string, PothosInputFieldConfig<Types>>, buildCache: BuildCache<Types>, mapper: (config: PothosInputFieldConfig<Types>) => T | null, cache?: Map<string, InputTypeFieldsMapping<Types, T>>): InputFieldsMapping<Types, T> | null;\nexport declare function createInputValueMapper<Types extends SchemaTypes, T, Args extends unknown[] = []>(argMap: InputFieldsMapping<Types, T>, mapValue: (val: unknown, mapping: InputFieldMapping<Types, T>, ...args: Args) => unknown): (obj: object, map?: InputFieldsMapping<Types, T>, ...args: Args) => Record<string, unknown>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/params",
    "content": "declare module '@pothos/core/utils/params' {\nimport type { ConfigStore } from '@pothos/core/config-store';\nimport type { FieldNullability, FieldRequiredness, InputType, InputTypeParam, OutputType, PothosInputFieldType, PothosOutputFieldType, SchemaTypes, TypeParam } from '@pothos/core/types';\nexport declare function unwrapOutputFieldType<Types extends SchemaTypes>(type: PothosOutputFieldType<Types>): OutputType<Types>;\nexport declare function typeFromParam<Types extends SchemaTypes>(param: TypeParam<Types>, configStore: ConfigStore<Types>, nullableOption: FieldNullability<[unknown]>): PothosOutputFieldType<Types>;\nexport declare function unwrapInputFieldType<Types extends SchemaTypes>(type: PothosInputFieldType<Types>): InputType<Types>;\nexport declare function inputTypeFromParam<Types extends SchemaTypes>(param: InputTypeParam<Types>, configStore: ConfigStore<Types>, requiredOption: FieldRequiredness<[unknown]>): PothosInputFieldType<Types>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/sort-classes",
    "content": "declare module '@pothos/core/utils/sort-classes' {\nexport declare function classDepth(obj: {}): number;\nexport declare function sortClasses<T extends new (...args: any[]) => unknown>(classes: T[]): T[];\n}"
  }
];

export function getTypeDefinitions(): TypeDefinition[] {
  return pothosTypeDefinitions;
}
