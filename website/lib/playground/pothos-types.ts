// Auto-generated Pothos type definitions for Monaco editor
// Generated at: 2025-12-06T04:18:06.429Z
//
// Core types are loaded immediately
// Plugin types are loaded dynamically based on imports

export interface TypeDefinition {
  moduleName: string;
  content: string;
}

// Core Pothos types (always loaded)
export const coreTypeDefinitions: TypeDefinition[] = [
  {
    "moduleName": "@pothos/core/types/global/classes",
    "content": "import type { SchemaBuilder as Builder } from '@pothos/core/builder';\nimport type { FieldBuilder as InternalFieldBuilder } from '@pothos/core/fieldUtils/builder';\nimport type { InputFieldBuilder as InternalInputFieldBuilder } from '@pothos/core/fieldUtils/input';\nimport type { RootFieldBuilder as InternalRootFieldBuilder } from '@pothos/core/fieldUtils/root';\nimport type { ArgumentRef as InternalArgumentRef } from '@pothos/core/refs/arg';\nimport type { BaseTypeRef as InternalBaseRef } from '@pothos/core/refs/base';\nimport type { EnumRef as InternalEnumRef } from '@pothos/core/refs/enum';\nimport type { FieldRef as InternalFieldRef } from '@pothos/core/refs/field';\nimport type { InputFieldRef as InternalInputFieldRef } from '@pothos/core/refs/input-field';\nimport type { InputListRef as InternalInputListRef } from '@pothos/core/refs/input-list';\nimport type { ImplementableInputObjectRef as InternalImplementableInputObjectRef, InputObjectRef as InternalInputObjectRef } from '@pothos/core/refs/input-object';\nimport type { ImplementableInterfaceRef as InternalImplementableInterfaceRef, InterfaceRef as InternalInterfaceRef } from '@pothos/core/refs/interface';\nimport type { ListRef as InternalListRef } from '@pothos/core/refs/list';\nimport type { ImplementableObjectRef as InternalImplementableObjectRef, ObjectRef as InternalObjectRef } from '@pothos/core/refs/object';\nimport type { ScalarRef as InternalScalarRef } from '@pothos/core/refs/scalar';\nimport type { UnionRef as InternalUnionRef } from '@pothos/core/refs/union';\nimport type { FieldKind } from '@pothos/core/types/builder-options';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface SchemaBuilder<Types extends SchemaTypes> extends Builder<Types> {\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends InternalRootFieldBuilder<Types, ParentShape, Kind> {\n        }\n        interface FieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends InternalFieldBuilder<Types, ParentShape, Kind>, RootFieldBuilder<Types, ParentShape, Kind> {\n        }\n        interface QueryFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Query'> {\n        }\n        interface MutationFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Mutation'> {\n        }\n        interface SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Subscription'> {\n        }\n        interface ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Object'> {\n        }\n        interface InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Interface'> {\n        }\n        interface InputFieldBuilder<Types extends SchemaTypes, Kind extends 'Arg' | 'InputObject'> extends InternalInputFieldBuilder<Types, Kind> {\n        }\n        interface BaseTypeRef<Types extends SchemaTypes, T> extends InternalBaseRef<Types, T> {\n        }\n        interface EnumRef<Types extends SchemaTypes, T, U = T> extends InternalEnumRef<Types, T, U> {\n        }\n        interface InputObjectRef<Types extends SchemaTypes, T> extends InternalInputObjectRef<Types, T> {\n        }\n        interface ImplementableInputObjectRef<Types extends SchemaTypes, T extends object, Resolved = T> extends InternalImplementableInputObjectRef<Types, T, Resolved> {\n        }\n        interface InputListRef<Types extends SchemaTypes, T> extends InternalInputListRef<Types, T> {\n        }\n        interface InterfaceRef<Types extends SchemaTypes, T, P = T> extends InternalInterfaceRef<Types, T, P> {\n        }\n        interface ImplementableInterfaceRef<Types extends SchemaTypes, T, P = T> extends InternalImplementableInterfaceRef<Types, T, P> {\n        }\n        interface ObjectRef<Types extends SchemaTypes, T, P = T> extends InternalObjectRef<Types, T, P> {\n        }\n        interface ImplementableObjectRef<Types extends SchemaTypes, T, P = T> extends InternalImplementableObjectRef<Types, T, P> {\n        }\n        interface ScalarRef<Types extends SchemaTypes, T, U, P = T> extends InternalScalarRef<Types, T, U, P> {\n        }\n        interface UnionRef<Types extends SchemaTypes, T, P = T> extends InternalUnionRef<Types, T, P> {\n        }\n        interface ListRef<Types extends SchemaTypes, T, P = T> extends InternalListRef<Types, T, P> {\n        }\n        interface FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> extends InternalFieldRef<Types, T, Kind> {\n        }\n        interface InputFieldRef<Types extends SchemaTypes, T> extends InternalInputFieldRef<Types, T> {\n        }\n        interface ArgumentRef<Types extends SchemaTypes, T> extends InternalArgumentRef<Types, T> {\n        }\n    }\n}"
  },
  {
    "moduleName": "@pothos/core/types/global/field-options",
    "content": "import type { GraphQLFieldExtensions } from 'graphql';\nimport type { InferredFieldOptionsByKind, InputFieldMap, InputShapeFromFields, Resolver, Subscriber } from '@pothos/core/types/builder-options';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nimport type { FieldNullability, FieldRequiredness, InputShapeFromTypeParam, InputType, ShapeFromTypeParam, TypeParam } from '@pothos/core/types/type-params';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface InferredFieldOptions<Types extends SchemaTypes, ResolveShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveReturnShape = unknown> {\n            Resolve: {\n                /**\n                 * Resolver function for this field\n                 * @param parent - The parent object for the current type\n                 * @param {object} args - args object based on the args defined for this field\n                 * @param {object} context - the context object for the current query, based on `Context` type provided to the SchemaBuilder\n                 * @param {GraphQLResolveInfo} info - info about how this field was queried\n                 */\n                resolve: Resolver<ResolveShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, Type, Nullable>, ResolveReturnShape>;\n            };\n        }\n        interface FieldOptions<Types extends SchemaTypes = SchemaTypes, ParentShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveShape = unknown, ResolveReturnShape = unknown> {\n            /** The type for this field */\n            type: Type;\n            /** arguments for this field (created via `t.args`) */\n            args?: Args;\n            /** determines if this field can return null */\n            nullable?: Nullable;\n            /** text description for this field.  This will be added into your schema file and visable in tools like graphql-playground */\n            description?: string;\n            /** When present marks this field as deprecated */\n            deprecationReason?: string;\n            /** extensions for this field for use by directives, server plugins or other tools that depend on extensions */\n            extensions?: GraphQLFieldExtensions<ParentShape, Types['Context'], InputShapeFromFields<Args>>;\n        }\n        interface ObjectFieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, ParentShape, Type, Nullable, Args, ParentShape, ResolveReturnShape> {\n        }\n        interface QueryFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, Types['Root'], Type, Nullable, Args, Types['Root'], ResolveReturnShape> {\n        }\n        interface MutationFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, Types['Root'], Type, Nullable, Args, Types['Root'], ResolveReturnShape> {\n        }\n        interface InterfaceFieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, ParentShape, Type, Nullable, Args, ParentShape, ResolveReturnShape> {\n        }\n        interface SubscriptionFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> extends FieldOptions<Types, Types['Root'], Type, Nullable, Args, ResolveShape, ResolveReturnShape> {\n            /**\n             * Resolver function for this field\n             * @param root - The root object for this request\n             * @param {object} args - args object based on the args defined for this field\n             * @param {object} context - the context object for the current query, based on `Context` type provided to the SchemaBuilder\n             * @param {GraphQLResolveInfo} info - info about how this field was queried\n             */\n            subscribe: Subscriber<Types['Root'], InputShapeFromFields<Args>, Types['Context'], ResolveShape>;\n        }\n        interface FieldOptionsByKind<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> {\n            Query: QueryFieldOptions<Types, Type, Nullable, Args, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], Types['Root'], Type, Nullable, Args, ResolveReturnShape>;\n            Mutation: MutationFieldOptions<Types, Type, Nullable, Args, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], Types['Root'], Type, Nullable, Args, ResolveReturnShape>;\n            Subscription: SubscriptionFieldOptions<Types, Type, Nullable, Args, ResolveShape, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], ResolveShape, Type, Nullable, Args, ResolveReturnShape>;\n            Object: ObjectFieldOptions<Types, ParentShape, Type, Nullable, Args, ResolveReturnShape> & InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], ParentShape, Type, Nullable, Args, ResolveReturnShape>;\n            Interface: InterfaceFieldOptions<Types, ParentShape, Type, Nullable, Args, ResolveReturnShape> & Partial<InferredFieldOptionsByKind<Types, Types['InferredFieldOptionsKind'], ParentShape, Type, Nullable, Args, ResolveReturnShape>>;\n        }\n        interface InputFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            /** The type for this field */\n            type: Type;\n            /** text description for this field.  This will be added into your schema file and visable in tools like graphql-playground */\n            description?: string;\n            /** When present marks this field as deprecated */\n            deprecationReason?: string;\n            /** determines if this field can be omitted (or set as null) */\n            required?: Req;\n            /** default value if this field is not included in the query */\n            defaultValue?: InputShapeFromTypeParam<Types, Type, Req>;\n            /** extensions for this field for use by directives, server plugins or other tools that depend on extensions */\n            extensions?: Readonly<Record<string, unknown>>;\n        }\n        interface ArgFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> extends InputFieldOptions<Types, Type, Req> {\n        }\n        interface InputObjectFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> extends InputFieldOptions<Types, Type, Req> {\n        }\n        interface InputFieldOptionsByKind<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            Arg: ArgFieldOptions<Types, Type, Req>;\n            InputObject: InputObjectFieldOptions<Types, Type, Req>;\n        }\n    }\n}"
  },
  {
    "moduleName": "@pothos/core/types/global/schema-types",
    "content": "import type { GraphQLDirective } from 'graphql';\nimport type { InferredFieldOptionsKind } from '@pothos/core/types/builder-options';\nimport type { PluginConstructorMap } from '@pothos/core/types/plugins';\nimport type { MergedScalars, SchemaTypes, V3DefaultScalars } from '@pothos/core/types/schema-types';\nimport type { IsStrictMode, RecursivelyNormalizeNullableFields } from '@pothos/core/types/utils';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            plugins?: (keyof PluginConstructorMap<Types>)[];\n            defaultFieldNullability: Types['Defaults'] extends 'v3' ? false extends Types['DefaultFieldNullability'] ? never : Types['DefaultFieldNullability'] : true extends Types['DefaultFieldNullability'] ? never : Types['DefaultFieldNullability'];\n            defaultInputFieldRequiredness: false extends Types['DefaultInputFieldRequiredness'] ? never : Types['DefaultInputFieldRequiredness'];\n            notStrict: IsStrictMode extends true ? never : 'Pothos may not work correctly when strict mode is not enabled in tsconfig.json';\n            defaults: SchemaTypes['Defaults'] extends Types['Defaults'] ? never : Types['Defaults'];\n        }\n        interface V3SchemaBuilderOptions<Types extends SchemaTypes> {\n        }\n        interface V3DefaultSchemaTypes {\n            Scalars: V3DefaultScalars;\n        }\n        interface BuildSchemaOptions<Types extends SchemaTypes> {\n            directives?: readonly GraphQLDirective[];\n            extensions?: Record<string, unknown>;\n            sortSchema?: boolean;\n        }\n        interface Plugins<Types extends SchemaTypes> {\n        }\n        interface PothosKindToGraphQLType {\n            Object: 'Object';\n            Query: 'Object';\n            Mutation: 'Object';\n            Subscription: 'Object';\n            Interface: 'Interface';\n            Union: 'Union';\n            Enum: 'Enum';\n            Scalar: 'Scalar';\n            InputObject: 'InputObject';\n        }\n        interface UserSchemaTypes {\n            Defaults: 'v3' | 'v4';\n            Scalars: Record<string, {\n                Input: unknown;\n                Output: unknown;\n            }>;\n            Objects: {};\n            Inputs: {};\n            Interfaces: {};\n            Root: object;\n            Context: object;\n            DefaultFieldNullability: boolean;\n            DefaultInputFieldRequiredness: boolean;\n            InferredFieldOptionsKind: InferredFieldOptionsKind;\n        }\n        interface ExtendDefaultTypes<PartialTypes extends Partial<UserSchemaTypes>> extends SchemaTypes {\n            Defaults: PartialTypes['Defaults'] & SchemaTypes['Defaults'];\n            Scalars: MergedScalars<PartialTypes>;\n            Objects: PartialTypes['Objects'] & {};\n            Inputs: PartialTypes['Inputs'] & {};\n            Interfaces: PartialTypes['Interfaces'] & {};\n            Root: PartialTypes['Root'] & {};\n            Context: PartialTypes['Context'] & {};\n            InferredFieldOptionsKind: PartialTypes['InferredFieldOptionsKind'] extends InferredFieldOptionsKind ? PartialTypes['InferredFieldOptionsKind'] : 'Resolve';\n            DefaultFieldNullability: PartialTypes['Defaults'] extends 'v3' ? PartialTypes['DefaultFieldNullability'] extends true ? true : false : PartialTypes['DefaultFieldNullability'] extends false ? false : true;\n            DefaultInputFieldRequiredness: PartialTypes['DefaultInputFieldRequiredness'] extends true ? true : false;\n            outputShapes: {\n                [K in keyof MergedScalars<PartialTypes>]: MergedScalars<PartialTypes>[K] extends {\n                    Output: infer T;\n                } ? T : never;\n            } & {\n                [K in keyof PartialTypes['Objects']]: PartialTypes['Objects'][K];\n            } & {\n                [K in keyof PartialTypes['Interfaces']]: PartialTypes['Interfaces'][K];\n            };\n            inputShapes: {\n                [K in keyof MergedScalars<PartialTypes>]: MergedScalars<PartialTypes>[K] extends {\n                    Input: infer T;\n                } ? T : never;\n            } & {\n                [K in keyof PartialTypes['Inputs']]: RecursivelyNormalizeNullableFields<PartialTypes['Inputs'][K]>;\n            };\n        }\n    }\n}"
  },
  {
    "moduleName": "@pothos/core/types/global/type-options",
    "content": "import type { GraphQLIsTypeOfFn, GraphQLResolveInfo, GraphQLScalarLiteralParser, GraphQLScalarValueParser, GraphQLUnionType } from 'graphql';\nimport type { EnumValues, InputFieldMap, InterfaceFieldsShape, MutationFieldsShape, ObjectFieldsShape, QueryFieldsShape, SubscriptionFieldsShape, ValidateInterfaces } from '@pothos/core/types/builder-options';\nimport type { RootName, SchemaTypes } from '@pothos/core/types/schema-types';\nimport type { InterfaceParam, ObjectParam, ParentShape } from '@pothos/core/types/type-params';\nimport type { MaybePromise } from '@pothos/core/types/utils';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface BaseTypeOptions<Types extends SchemaTypes = SchemaTypes> {\n            description?: string;\n            extensions?: Readonly<Record<string, unknown>>;\n        }\n        interface EnumTypeOptions<Types extends SchemaTypes = SchemaTypes, Values extends EnumValues<Types> = EnumValues<Types>> extends BaseTypeOptions<Types> {\n            values: Values;\n        }\n        interface ObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown> extends BaseTypeOptions<Types> {\n            fields?: ObjectFieldsShape<Types, Shape>;\n            interfaces?: undefined;\n            isTypeOf?: GraphQLIsTypeOfFn<unknown, Types['Context']>;\n        }\n        interface ObjectTypeWithInterfaceOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[]> extends Omit<ObjectTypeOptions<Types, Shape>, 'interfaces'> {\n            interfaces?: (() => Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]) | (Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]);\n        }\n        interface RootTypeOptions<Types extends SchemaTypes, Type extends RootName> extends BaseTypeOptions<Types> {\n            name?: string;\n        }\n        interface QueryTypeOptions<Types extends SchemaTypes = SchemaTypes> extends RootTypeOptions<Types, 'Query'> {\n            fields?: QueryFieldsShape<Types>;\n        }\n        interface MutationTypeOptions<Types extends SchemaTypes = SchemaTypes> extends RootTypeOptions<Types, 'Mutation'> {\n            fields?: MutationFieldsShape<Types>;\n        }\n        interface SubscriptionTypeOptions<Types extends SchemaTypes = SchemaTypes> extends RootTypeOptions<Types, 'Subscription'> {\n            fields?: SubscriptionFieldsShape<Types>;\n        }\n        interface InputObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Fields extends InputFieldMap = InputFieldMap> extends BaseTypeOptions<Types> {\n            isOneOf?: boolean;\n            fields: (t: InputFieldBuilder<Types, 'InputObject'>) => Fields;\n        }\n        interface InterfaceTypeOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[], ResolveType = unknown> extends BaseTypeOptions<Types> {\n            fields?: InterfaceFieldsShape<Types, Shape>;\n            interfaces?: (() => Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]) | (Interfaces & ValidateInterfaces<Shape, Types, Interfaces[number]>[]);\n            resolveType?: ResolveType & ((parent: Shape, context: Types['Context'], info: GraphQLResolveInfo, type: GraphQLUnionType) => MaybePromise<ObjectParam<Types> | string | null | undefined>);\n        }\n        interface UnionTypeOptions<Types extends SchemaTypes = SchemaTypes, Member extends ObjectParam<Types> = ObjectParam<Types>, ResolveType = unknown> extends BaseTypeOptions<Types> {\n            types: Member[] | (() => Member[]);\n            resolveType?: ResolveType & ((parent: ParentShape<Types, Member>, context: Types['Context'], info: GraphQLResolveInfo, type: GraphQLUnionType) => MaybePromise<Member | string | null | undefined>);\n        }\n        interface ScalarTypeOptions<Types extends SchemaTypes = SchemaTypes, ScalarInputShape = unknown, ScalarOutputShape = unknown> extends BaseTypeOptions<Types> {\n            serialize: (outputValue: ScalarOutputShape) => unknown;\n            parseValue?: GraphQLScalarValueParser<ScalarInputShape>;\n            parseLiteral?: GraphQLScalarLiteralParser<ScalarInputShape>;\n        }\n        interface EnumValueConfig<Types extends SchemaTypes> {\n            description?: string;\n            value?: number | string;\n            deprecationReason?: string;\n            extensions?: Readonly<Record<string, unknown>>;\n        }\n    }\n}"
  },
  {
    "moduleName": "graphql",
    "content": "declare module 'graphql' {\n/** Conveniently represents flow's \"Maybe\" type https://flow.org/en/docs/types/maybe/ */\nexport declare type Maybe<T> = null | undefined | T;\n\n\nexport interface ObjMap<T> {\n  [key: string]: T;\n}\nexport declare type ObjMapLike<T> =\n  | ObjMap<T>\n  | {\n      [key: string]: T;\n    };\nexport interface ReadOnlyObjMap<T> {\n  readonly [key: string]: T;\n}\nexport declare type ReadOnlyObjMapLike<T> =\n  | ReadOnlyObjMap<T>\n  | {\n      readonly [key: string]: T;\n    };\n\n\n\nexport interface Path {\n  readonly prev: Path | undefined;\n  readonly key: string | number;\n  readonly typename: string | undefined;\n}\n/**\n * Given a Path and a key, return a new Path containing the new key.\n */\nexport declare function addPath(\n  prev: Readonly<Path> | undefined,\n  key: string | number,\n  typename: string | undefined,\n): Path;\n/**\n * Given a Path, return an Array of the path keys.\n */\nexport declare function pathToArray(\n  path: Maybe<Readonly<Path>>,\n): Array<string | number>;\n\n\nexport declare type PromiseOrValue<T> = Promise<T> | T;\n\n\n\n\n\n/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\nexport declare class Location {\n  /**\n   * The character offset at which this Node begins.\n   */\n  readonly start: number;\n  /**\n   * The character offset at which this Node ends.\n   */\n  readonly end: number;\n  /**\n   * The Token at which this Node begins.\n   */\n  readonly startToken: Token;\n  /**\n   * The Token at which this Node ends.\n   */\n  readonly endToken: Token;\n  /**\n   * The Source document the AST represents.\n   */\n  readonly source: Source;\n  constructor(startToken: Token, endToken: Token, source: Source);\n  get [Symbol.toStringTag](): string;\n  toJSON(): {\n    start: number;\n    end: number;\n  };\n}\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\nexport declare class Token {\n  /**\n   * The kind of Token.\n   */\n  readonly kind: TokenKind;\n  /**\n   * The character offset at which this Node begins.\n   */\n  readonly start: number;\n  /**\n   * The character offset at which this Node ends.\n   */\n  readonly end: number;\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n  readonly line: number;\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n  readonly column: number;\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   *\n   * Note: is undefined for punctuation tokens, but typed as string for\n   * convenience in the parser.\n   */\n  readonly value: string;\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  readonly prev: Token | null;\n  readonly next: Token | null;\n  constructor(\n    kind: TokenKind,\n    start: number,\n    end: number,\n    line: number,\n    column: number,\n    value?: string,\n  );\n  get [Symbol.toStringTag](): string;\n  toJSON(): {\n    kind: TokenKind;\n    value?: string;\n    line: number;\n    column: number;\n  };\n}\n/**\n * The list of all possible AST node types.\n */\nexport declare type ASTNode =\n  | NameNode\n  | DocumentNode\n  | OperationDefinitionNode\n  | VariableDefinitionNode\n  | VariableNode\n  | SelectionSetNode\n  | FieldNode\n  | ArgumentNode\n  | FragmentSpreadNode\n  | InlineFragmentNode\n  | FragmentDefinitionNode\n  | IntValueNode\n  | FloatValueNode\n  | StringValueNode\n  | BooleanValueNode\n  | NullValueNode\n  | EnumValueNode\n  | ListValueNode\n  | ObjectValueNode\n  | ObjectFieldNode\n  | DirectiveNode\n  | NamedTypeNode\n  | ListTypeNode\n  | NonNullTypeNode\n  | SchemaDefinitionNode\n  | OperationTypeDefinitionNode\n  | ScalarTypeDefinitionNode\n  | ObjectTypeDefinitionNode\n  | FieldDefinitionNode\n  | InputValueDefinitionNode\n  | InterfaceTypeDefinitionNode\n  | UnionTypeDefinitionNode\n  | EnumTypeDefinitionNode\n  | EnumValueDefinitionNode\n  | InputObjectTypeDefinitionNode\n  | DirectiveDefinitionNode\n  | SchemaExtensionNode\n  | ScalarTypeExtensionNode\n  | ObjectTypeExtensionNode\n  | InterfaceTypeExtensionNode\n  | UnionTypeExtensionNode\n  | EnumTypeExtensionNode\n  | InputObjectTypeExtensionNode\n  | TypeCoordinateNode\n  | MemberCoordinateNode\n  | ArgumentCoordinateNode\n  | DirectiveCoordinateNode\n  | DirectiveArgumentCoordinateNode;\n/**\n * Utility type listing all nodes indexed by their kind.\n */\nexport declare type ASTKindToNode = {\n  [NodeT in ASTNode as NodeT['kind']]: NodeT;\n};\n/**\n * @internal\n */\nexport declare const QueryDocumentKeys: {\n  [NodeT in ASTNode as NodeT['kind']]: ReadonlyArray<keyof NodeT>;\n};\n/**\n * @internal\n */\nexport declare function isNode(maybeNode: any): maybeNode is ASTNode;\n/** Name */\nexport interface NameNode {\n  readonly kind: Kind.NAME;\n  readonly loc?: Location;\n  readonly value: string;\n}\n/** Document */\nexport interface DocumentNode {\n  readonly kind: Kind.DOCUMENT;\n  readonly loc?: Location;\n  readonly definitions: ReadonlyArray<DefinitionNode>;\n  readonly tokenCount?: number | undefined;\n}\nexport declare type DefinitionNode =\n  | ExecutableDefinitionNode\n  | TypeSystemDefinitionNode\n  | TypeSystemExtensionNode;\nexport declare type ExecutableDefinitionNode =\n  | OperationDefinitionNode\n  | FragmentDefinitionNode;\nexport interface OperationDefinitionNode {\n  readonly kind: Kind.OPERATION_DEFINITION;\n  readonly description?: StringValueNode;\n  readonly loc?: Location;\n  readonly operation: OperationTypeNode;\n  readonly name?: NameNode;\n  readonly variableDefinitions?: ReadonlyArray<VariableDefinitionNode>;\n  readonly directives?: ReadonlyArray<DirectiveNode>;\n  readonly selectionSet: SelectionSetNode;\n}\ndeclare enum OperationTypeNode {\n  QUERY = 'query',\n  MUTATION = 'mutation',\n  SUBSCRIPTION = 'subscription',\n}\nexport { OperationTypeNode };\nexport interface VariableDefinitionNode {\n  readonly kind: Kind.VARIABLE_DEFINITION;\n  readonly description?: StringValueNode;\n  readonly loc?: Location;\n  readonly variable: VariableNode;\n  readonly type: TypeNode;\n  readonly defaultValue?: ConstValueNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n}\nexport interface VariableNode {\n  readonly kind: Kind.VARIABLE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n}\nexport interface SelectionSetNode {\n  kind: Kind.SELECTION_SET;\n  loc?: Location;\n  selections: ReadonlyArray<SelectionNode>;\n}\nexport declare type SelectionNode =\n  | FieldNode\n  | FragmentSpreadNode\n  | InlineFragmentNode;\nexport interface FieldNode {\n  readonly kind: Kind.FIELD;\n  readonly loc?: Location;\n  readonly alias?: NameNode;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<ArgumentNode>;\n  readonly directives?: ReadonlyArray<DirectiveNode>;\n  readonly selectionSet?: SelectionSetNode;\n}\nexport interface ArgumentNode {\n  readonly kind: Kind.ARGUMENT;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly value: ValueNode;\n}\nexport interface ConstArgumentNode {\n  readonly kind: Kind.ARGUMENT;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly value: ConstValueNode;\n}\n/** Fragments */\nexport interface FragmentSpreadNode {\n  readonly kind: Kind.FRAGMENT_SPREAD;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<DirectiveNode>;\n}\nexport interface InlineFragmentNode {\n  readonly kind: Kind.INLINE_FRAGMENT;\n  readonly loc?: Location;\n  readonly typeCondition?: NamedTypeNode;\n  readonly directives?: ReadonlyArray<DirectiveNode>;\n  readonly selectionSet: SelectionSetNode;\n}\nexport interface FragmentDefinitionNode {\n  readonly kind: Kind.FRAGMENT_DEFINITION;\n  readonly description?: StringValueNode;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  /** @deprecated variableDefinitions will be removed in v17.0.0 */\n  readonly variableDefinitions?: ReadonlyArray<VariableDefinitionNode>;\n  readonly typeCondition: NamedTypeNode;\n  readonly directives?: ReadonlyArray<DirectiveNode>;\n  readonly selectionSet: SelectionSetNode;\n}\n/** Values */\nexport declare type ValueNode =\n  | VariableNode\n  | IntValueNode\n  | FloatValueNode\n  | StringValueNode\n  | BooleanValueNode\n  | NullValueNode\n  | EnumValueNode\n  | ListValueNode\n  | ObjectValueNode;\nexport declare type ConstValueNode =\n  | IntValueNode\n  | FloatValueNode\n  | StringValueNode\n  | BooleanValueNode\n  | NullValueNode\n  | EnumValueNode\n  | ConstListValueNode\n  | ConstObjectValueNode;\nexport interface IntValueNode {\n  readonly kind: Kind.INT;\n  readonly loc?: Location;\n  readonly value: string;\n}\nexport interface FloatValueNode {\n  readonly kind: Kind.FLOAT;\n  readonly loc?: Location;\n  readonly value: string;\n}\nexport interface StringValueNode {\n  readonly kind: Kind.STRING;\n  readonly loc?: Location;\n  readonly value: string;\n  readonly block?: boolean;\n}\nexport interface BooleanValueNode {\n  readonly kind: Kind.BOOLEAN;\n  readonly loc?: Location;\n  readonly value: boolean;\n}\nexport interface NullValueNode {\n  readonly kind: Kind.NULL;\n  readonly loc?: Location;\n}\nexport interface EnumValueNode {\n  readonly kind: Kind.ENUM;\n  readonly loc?: Location;\n  readonly value: string;\n}\nexport interface ListValueNode {\n  readonly kind: Kind.LIST;\n  readonly loc?: Location;\n  readonly values: ReadonlyArray<ValueNode>;\n}\nexport interface ConstListValueNode {\n  readonly kind: Kind.LIST;\n  readonly loc?: Location;\n  readonly values: ReadonlyArray<ConstValueNode>;\n}\nexport interface ObjectValueNode {\n  readonly kind: Kind.OBJECT;\n  readonly loc?: Location;\n  readonly fields: ReadonlyArray<ObjectFieldNode>;\n}\nexport interface ConstObjectValueNode {\n  readonly kind: Kind.OBJECT;\n  readonly loc?: Location;\n  readonly fields: ReadonlyArray<ConstObjectFieldNode>;\n}\nexport interface ObjectFieldNode {\n  readonly kind: Kind.OBJECT_FIELD;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly value: ValueNode;\n}\nexport interface ConstObjectFieldNode {\n  readonly kind: Kind.OBJECT_FIELD;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly value: ConstValueNode;\n}\n/** Directives */\nexport interface DirectiveNode {\n  readonly kind: Kind.DIRECTIVE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<ArgumentNode>;\n}\nexport interface ConstDirectiveNode {\n  readonly kind: Kind.DIRECTIVE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<ConstArgumentNode>;\n}\n/** Type Reference */\nexport declare type TypeNode = NamedTypeNode | ListTypeNode | NonNullTypeNode;\nexport interface NamedTypeNode {\n  readonly kind: Kind.NAMED_TYPE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n}\nexport interface ListTypeNode {\n  readonly kind: Kind.LIST_TYPE;\n  readonly loc?: Location;\n  readonly type: TypeNode;\n}\nexport interface NonNullTypeNode {\n  readonly kind: Kind.NON_NULL_TYPE;\n  readonly loc?: Location;\n  readonly type: NamedTypeNode | ListTypeNode;\n}\n/** Type System Definition */\nexport declare type TypeSystemDefinitionNode =\n  | SchemaDefinitionNode\n  | TypeDefinitionNode\n  | DirectiveDefinitionNode;\nexport interface SchemaDefinitionNode {\n  readonly kind: Kind.SCHEMA_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly operationTypes: ReadonlyArray<OperationTypeDefinitionNode>;\n}\nexport interface OperationTypeDefinitionNode {\n  readonly kind: Kind.OPERATION_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly operation: OperationTypeNode;\n  readonly type: NamedTypeNode;\n}\n/** Type Definition */\nexport declare type TypeDefinitionNode =\n  | ScalarTypeDefinitionNode\n  | ObjectTypeDefinitionNode\n  | InterfaceTypeDefinitionNode\n  | UnionTypeDefinitionNode\n  | EnumTypeDefinitionNode\n  | InputObjectTypeDefinitionNode;\nexport interface ScalarTypeDefinitionNode {\n  readonly kind: Kind.SCALAR_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n}\nexport interface ObjectTypeDefinitionNode {\n  readonly kind: Kind.OBJECT_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode>;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode>;\n}\nexport interface FieldDefinitionNode {\n  readonly kind: Kind.FIELD_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<InputValueDefinitionNode>;\n  readonly type: TypeNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n}\nexport interface InputValueDefinitionNode {\n  readonly kind: Kind.INPUT_VALUE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly type: TypeNode;\n  readonly defaultValue?: ConstValueNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n}\nexport interface InterfaceTypeDefinitionNode {\n  readonly kind: Kind.INTERFACE_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode>;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode>;\n}\nexport interface UnionTypeDefinitionNode {\n  readonly kind: Kind.UNION_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly types?: ReadonlyArray<NamedTypeNode>;\n}\nexport interface EnumTypeDefinitionNode {\n  readonly kind: Kind.ENUM_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly values?: ReadonlyArray<EnumValueDefinitionNode>;\n}\nexport interface EnumValueDefinitionNode {\n  readonly kind: Kind.ENUM_VALUE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n}\nexport interface InputObjectTypeDefinitionNode {\n  readonly kind: Kind.INPUT_OBJECT_TYPE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly fields?: ReadonlyArray<InputValueDefinitionNode>;\n}\n/** Directive Definitions */\nexport interface DirectiveDefinitionNode {\n  readonly kind: Kind.DIRECTIVE_DEFINITION;\n  readonly loc?: Location;\n  readonly description?: StringValueNode;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<InputValueDefinitionNode>;\n  readonly repeatable: boolean;\n  readonly locations: ReadonlyArray<NameNode>;\n}\n/** Type System Extensions */\nexport declare type TypeSystemExtensionNode =\n  | SchemaExtensionNode\n  | TypeExtensionNode;\nexport interface SchemaExtensionNode {\n  readonly kind: Kind.SCHEMA_EXTENSION;\n  readonly loc?: Location;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly operationTypes?: ReadonlyArray<OperationTypeDefinitionNode>;\n}\n/** Type Extensions */\nexport declare type TypeExtensionNode =\n  | ScalarTypeExtensionNode\n  | ObjectTypeExtensionNode\n  | InterfaceTypeExtensionNode\n  | UnionTypeExtensionNode\n  | EnumTypeExtensionNode\n  | InputObjectTypeExtensionNode;\nexport interface ScalarTypeExtensionNode {\n  readonly kind: Kind.SCALAR_TYPE_EXTENSION;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n}\nexport interface ObjectTypeExtensionNode {\n  readonly kind: Kind.OBJECT_TYPE_EXTENSION;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode>;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode>;\n}\nexport interface InterfaceTypeExtensionNode {\n  readonly kind: Kind.INTERFACE_TYPE_EXTENSION;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode>;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode>;\n}\nexport interface UnionTypeExtensionNode {\n  readonly kind: Kind.UNION_TYPE_EXTENSION;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly types?: ReadonlyArray<NamedTypeNode>;\n}\nexport interface EnumTypeExtensionNode {\n  readonly kind: Kind.ENUM_TYPE_EXTENSION;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly values?: ReadonlyArray<EnumValueDefinitionNode>;\n}\nexport interface InputObjectTypeExtensionNode {\n  readonly kind: Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode>;\n  readonly fields?: ReadonlyArray<InputValueDefinitionNode>;\n}\n/** Schema Coordinates */\nexport declare type SchemaCoordinateNode =\n  | TypeCoordinateNode\n  | MemberCoordinateNode\n  | ArgumentCoordinateNode\n  | DirectiveCoordinateNode\n  | DirectiveArgumentCoordinateNode;\nexport interface TypeCoordinateNode {\n  readonly kind: Kind.TYPE_COORDINATE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n}\nexport interface MemberCoordinateNode {\n  readonly kind: Kind.MEMBER_COORDINATE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly memberName: NameNode;\n}\nexport interface ArgumentCoordinateNode {\n  readonly kind: Kind.ARGUMENT_COORDINATE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly fieldName: NameNode;\n  readonly argumentName: NameNode;\n}\nexport interface DirectiveCoordinateNode {\n  readonly kind: Kind.DIRECTIVE_COORDINATE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n}\nexport interface DirectiveArgumentCoordinateNode {\n  readonly kind: Kind.DIRECTIVE_ARGUMENT_COORDINATE;\n  readonly loc?: Location;\n  readonly name: NameNode;\n  readonly argumentName: NameNode;\n}\n\n\n/**\n * The set of allowed kind values for AST nodes.\n */\ndeclare enum Kind {\n  /** Name */\n  NAME = 'Name',\n  /** Document */\n  DOCUMENT = 'Document',\n  OPERATION_DEFINITION = 'OperationDefinition',\n  VARIABLE_DEFINITION = 'VariableDefinition',\n  SELECTION_SET = 'SelectionSet',\n  FIELD = 'Field',\n  ARGUMENT = 'Argument',\n  /** Fragments */\n  FRAGMENT_SPREAD = 'FragmentSpread',\n  INLINE_FRAGMENT = 'InlineFragment',\n  FRAGMENT_DEFINITION = 'FragmentDefinition',\n  /** Values */\n  VARIABLE = 'Variable',\n  INT = 'IntValue',\n  FLOAT = 'FloatValue',\n  STRING = 'StringValue',\n  BOOLEAN = 'BooleanValue',\n  NULL = 'NullValue',\n  ENUM = 'EnumValue',\n  LIST = 'ListValue',\n  OBJECT = 'ObjectValue',\n  OBJECT_FIELD = 'ObjectField',\n  /** Directives */\n  DIRECTIVE = 'Directive',\n  /** Types */\n  NAMED_TYPE = 'NamedType',\n  LIST_TYPE = 'ListType',\n  NON_NULL_TYPE = 'NonNullType',\n  /** Type System Definitions */\n  SCHEMA_DEFINITION = 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition',\n  /** Type Definitions */\n  SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition',\n  FIELD_DEFINITION = 'FieldDefinition',\n  INPUT_VALUE_DEFINITION = 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION = 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION = 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION = 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition',\n  /** Directive Definitions */\n  DIRECTIVE_DEFINITION = 'DirectiveDefinition',\n  /** Type System Extensions */\n  SCHEMA_EXTENSION = 'SchemaExtension',\n  /** Type Extensions */\n  SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION = 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION = 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension',\n  /** Schema Coordinates */\n  TYPE_COORDINATE = 'TypeCoordinate',\n  MEMBER_COORDINATE = 'MemberCoordinate',\n  ARGUMENT_COORDINATE = 'ArgumentCoordinate',\n  DIRECTIVE_COORDINATE = 'DirectiveCoordinate',\n  DIRECTIVE_ARGUMENT_COORDINATE = 'DirectiveArgumentCoordinate',\n}\nexport { Kind };\n/**\n * The enum type representing the possible kind values of AST nodes.\n *\n * @deprecated Please use `Kind`. Will be remove in v17.\n */\nexport declare type KindEnum = typeof Kind;\n\n\n\n/**\n * Represents a location in a Source.\n */\nexport interface SourceLocation {\n  readonly line: number;\n  readonly column: number;\n}\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport declare function getLocation(\n  source: Source,\n  position: number,\n): SourceLocation;\n\n\ninterface Location {\n  line: number;\n  column: number;\n}\n/**\n * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are\n * optional, but they are useful for clients who store GraphQL documents in source files.\n * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might\n * be useful for `name` to be `\"Foo.graphql\"` and location to be `{ line: 40, column: 1 }`.\n * The `line` and `column` properties in `locationOffset` are 1-indexed.\n */\nexport declare class Source {\n  body: string;\n  name: string;\n  locationOffset: Location;\n  constructor(body: string, name?: string, locationOffset?: Location);\n  get [Symbol.toStringTag](): string;\n}\n/**\n * Test if the given value is a Source object.\n *\n * @internal\n */\nexport declare function isSource(source: unknown): source is Source;\nexport {};\n\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\ndeclare enum TokenKind {\n  SOF = '<SOF>',\n  EOF = '<EOF>',\n  BANG = '!',\n  DOLLAR = '$',\n  AMP = '&',\n  PAREN_L = '(',\n  PAREN_R = ')',\n  DOT = '.',\n  SPREAD = '...',\n  COLON = ':',\n  EQUALS = '=',\n  AT = '@',\n  BRACKET_L = '[',\n  BRACKET_R = ']',\n  BRACE_L = '{',\n  PIPE = '|',\n  BRACE_R = '}',\n  NAME = 'Name',\n  INT = 'Int',\n  FLOAT = 'Float',\n  STRING = 'String',\n  BLOCK_STRING = 'BlockString',\n  COMMENT = 'Comment',\n}\nexport { TokenKind };\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\nexport declare type TokenKindEnum = typeof TokenKind;\n\n\n/**\n * The set of allowed directive location values.\n */\ndeclare enum DirectiveLocation {\n  /** Request Definitions */\n  QUERY = 'QUERY',\n  MUTATION = 'MUTATION',\n  SUBSCRIPTION = 'SUBSCRIPTION',\n  FIELD = 'FIELD',\n  FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD = 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT = 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION = 'VARIABLE_DEFINITION',\n  /** Type System Definitions */\n  SCHEMA = 'SCHEMA',\n  SCALAR = 'SCALAR',\n  OBJECT = 'OBJECT',\n  FIELD_DEFINITION = 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION',\n  INTERFACE = 'INTERFACE',\n  UNION = 'UNION',\n  ENUM = 'ENUM',\n  ENUM_VALUE = 'ENUM_VALUE',\n  INPUT_OBJECT = 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION',\n}\nexport { DirectiveLocation };\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\nexport declare type DirectiveLocationEnum = typeof DirectiveLocation;\n\n\n\nexport declare function isDefinitionNode(node: ASTNode): node is DefinitionNode;\nexport declare function isExecutableDefinitionNode(\n  node: ASTNode,\n): node is ExecutableDefinitionNode;\nexport declare function isSelectionNode(node: ASTNode): node is SelectionNode;\nexport declare function isValueNode(node: ASTNode): node is ValueNode;\nexport declare function isConstValueNode(node: ASTNode): node is ConstValueNode;\nexport declare function isTypeNode(node: ASTNode): node is TypeNode;\nexport declare function isTypeSystemDefinitionNode(\n  node: ASTNode,\n): node is TypeSystemDefinitionNode;\nexport declare function isTypeDefinitionNode(\n  node: ASTNode,\n): node is TypeDefinitionNode;\nexport declare function isTypeSystemExtensionNode(\n  node: ASTNode,\n): node is TypeSystemExtensionNode;\nexport declare function isTypeExtensionNode(\n  node: ASTNode,\n): node is TypeExtensionNode;\nexport declare function isSchemaCoordinateNode(\n  node: ASTNode,\n): node is SchemaCoordinateNode;\n\n\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nexport declare function print(ast: ASTNode): string;\n\n\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\nexport declare type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\ndeclare type KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?:\n    | ASTVisitFn<NodeT>\n    | EnterLeaveVisitor<NodeT>;\n};\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode>;\n  readonly leave?: ASTVisitFn<TVisitedNode>;\n}\n/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\nexport declare type ASTVisitFn<TVisitedNode extends ASTNode> = (\n  /** The current node being visiting. */\n  node: TVisitedNode,\n  /** The index or key to this node from the parent node or Array. */\n  key: string | number | undefined,\n  /** The parent immediately above this node, which may be an Array. */\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  /** The key path to get to this node from the root node. */\n  path: ReadonlyArray<string | number>,\n  /**\n   * All nodes and Arrays visited before reaching parent of this node.\n   * These correspond to array indices in `path`.\n   * Note: ancestors includes arrays which contain the parent of visited node.\n   */\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>,\n) => any;\n/**\n * A reducer is comprised of reducer functions which convert AST nodes into\n * another form.\n */\nexport declare type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\ndeclare type ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  /** The current node being visiting. */\n  node: {\n    [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R>;\n  },\n  /** The index or key to this node from the parent node or Array. */\n  key: string | number | undefined,\n  /** The parent immediately above this node, which may be an Array. */\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  /** The key path to get to this node from the root node. */\n  path: ReadonlyArray<string | number>,\n  /**\n   * All nodes and Arrays visited before reaching parent of this node.\n   * These correspond to array indices in `path`.\n   * Note: ancestors includes arrays which contain the parent of visited node.\n   */\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>,\n) => R;\ndeclare type ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n  ? ReadonlyArray<R>\n  : R;\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n *\n * @deprecated Please inline it. Will be removed in v17\n */\nexport declare type ASTVisitorKeyMap = {\n  [NodeT in ASTNode as NodeT['kind']]?: ReadonlyArray<keyof NodeT>;\n};\nexport declare const BREAK: unknown;\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\nexport declare function visit<N extends ASTNode>(\n  root: N,\n  visitor: ASTVisitor,\n  visitorKeys?: ASTVisitorKeyMap,\n): N;\nexport declare function visit<R>(\n  root: ASTNode,\n  visitor: ASTReducer<R>,\n  visitorKeys?: ASTVisitorKeyMap,\n): R;\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nexport declare function visitInParallel(\n  visitors: ReadonlyArray<ASTVisitor>,\n): ASTVisitor;\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\nexport declare function getEnterLeaveForKind(\n  visitor: ASTVisitor,\n  kind: Kind,\n): EnterLeaveVisitor<ASTNode>;\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */\nexport declare function getVisitFn(\n  visitor: ASTVisitor,\n  kind: Kind,\n  isLeaving: boolean,\n): ASTVisitFn<ASTNode> | undefined;\nexport {};\n\n\n\n\n\n\n\n\n/**\n * These are all of the possible kinds of types.\n */\nexport declare type GraphQLType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType\n  | GraphQLInputObjectType\n  | GraphQLList<GraphQLType>\n  | GraphQLNonNull<\n      | GraphQLScalarType\n      | GraphQLObjectType\n      | GraphQLInterfaceType\n      | GraphQLUnionType\n      | GraphQLEnumType\n      | GraphQLInputObjectType\n      | GraphQLList<GraphQLType>\n    >;\nexport declare function isType(type: unknown): type is GraphQLType;\nexport declare function assertType(type: unknown): GraphQLType;\n/**\n * There are predicates for each kind of GraphQL type.\n */\nexport declare function isScalarType(type: unknown): type is GraphQLScalarType;\nexport declare function assertScalarType(type: unknown): GraphQLScalarType;\nexport declare function isObjectType(type: unknown): type is GraphQLObjectType;\nexport declare function assertObjectType(type: unknown): GraphQLObjectType;\nexport declare function isInterfaceType(\n  type: unknown,\n): type is GraphQLInterfaceType;\nexport declare function assertInterfaceType(\n  type: unknown,\n): GraphQLInterfaceType;\nexport declare function isUnionType(type: unknown): type is GraphQLUnionType;\nexport declare function assertUnionType(type: unknown): GraphQLUnionType;\nexport declare function isEnumType(type: unknown): type is GraphQLEnumType;\nexport declare function assertEnumType(type: unknown): GraphQLEnumType;\nexport declare function isInputObjectType(\n  type: unknown,\n): type is GraphQLInputObjectType;\nexport declare function assertInputObjectType(\n  type: unknown,\n): GraphQLInputObjectType;\nexport declare function isListType(\n  type: GraphQLInputType,\n): type is GraphQLList<GraphQLInputType>;\nexport declare function isListType(\n  type: GraphQLOutputType,\n): type is GraphQLList<GraphQLOutputType>;\nexport declare function isListType(\n  type: unknown,\n): type is GraphQLList<GraphQLType>;\nexport declare function assertListType(type: unknown): GraphQLList<GraphQLType>;\nexport declare function isNonNullType(\n  type: GraphQLInputType,\n): type is GraphQLNonNull<GraphQLInputType>;\nexport declare function isNonNullType(\n  type: GraphQLOutputType,\n): type is GraphQLNonNull<GraphQLOutputType>;\nexport declare function isNonNullType(\n  type: unknown,\n): type is GraphQLNonNull<GraphQLType>;\nexport declare function assertNonNullType(\n  type: unknown,\n): GraphQLNonNull<GraphQLType>;\n/**\n * These types may be used as input types for arguments and directives.\n */\nexport declare type GraphQLInputType =\n  | GraphQLScalarType\n  | GraphQLEnumType\n  | GraphQLInputObjectType\n  | GraphQLList<GraphQLInputType>\n  | GraphQLNonNull<\n      | GraphQLScalarType\n      | GraphQLEnumType\n      | GraphQLInputObjectType\n      | GraphQLList<GraphQLInputType>\n    >;\nexport declare function isInputType(type: unknown): type is GraphQLInputType;\nexport declare function assertInputType(type: unknown): GraphQLInputType;\n/**\n * These types may be used as output types as the result of fields.\n */\nexport declare type GraphQLOutputType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType\n  | GraphQLList<GraphQLOutputType>\n  | GraphQLNonNull<\n      | GraphQLScalarType\n      | GraphQLObjectType\n      | GraphQLInterfaceType\n      | GraphQLUnionType\n      | GraphQLEnumType\n      | GraphQLList<GraphQLOutputType>\n    >;\nexport declare function isOutputType(type: unknown): type is GraphQLOutputType;\nexport declare function assertOutputType(type: unknown): GraphQLOutputType;\n/**\n * These types may describe types which may be leaf values.\n */\nexport declare type GraphQLLeafType = GraphQLScalarType | GraphQLEnumType;\nexport declare function isLeafType(type: unknown): type is GraphQLLeafType;\nexport declare function assertLeafType(type: unknown): GraphQLLeafType;\n/**\n * These types may describe the parent context of a selection set.\n */\nexport declare type GraphQLCompositeType =\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType;\nexport declare function isCompositeType(\n  type: unknown,\n): type is GraphQLCompositeType;\nexport declare function assertCompositeType(\n  type: unknown,\n): GraphQLCompositeType;\n/**\n * These types may describe the parent context of a selection set.\n */\nexport declare type GraphQLAbstractType =\n  | GraphQLInterfaceType\n  | GraphQLUnionType;\nexport declare function isAbstractType(\n  type: unknown,\n): type is GraphQLAbstractType;\nexport declare function assertAbstractType(type: unknown): GraphQLAbstractType;\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\nexport declare class GraphQLList<T extends GraphQLType> {\n  readonly ofType: T;\n  constructor(ofType: T);\n  get [Symbol.toStringTag](): string;\n  toString(): string;\n  toJSON(): string;\n}\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\nexport declare class GraphQLNonNull<T extends GraphQLNullableType> {\n  readonly ofType: T;\n  constructor(ofType: T);\n  get [Symbol.toStringTag](): string;\n  toString(): string;\n  toJSON(): string;\n}\n/**\n * These types wrap and modify other types\n */\nexport declare type GraphQLWrappingType =\n  | GraphQLList<GraphQLType>\n  | GraphQLNonNull<GraphQLType>;\nexport declare function isWrappingType(\n  type: unknown,\n): type is GraphQLWrappingType;\nexport declare function assertWrappingType(type: unknown): GraphQLWrappingType;\n/**\n * These types can all accept null as a value.\n */\nexport declare type GraphQLNullableType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType\n  | GraphQLInputObjectType\n  | GraphQLList<GraphQLType>;\nexport declare function isNullableType(\n  type: unknown,\n): type is GraphQLNullableType;\nexport declare function assertNullableType(type: unknown): GraphQLNullableType;\nexport declare function getNullableType(type: undefined | null): void;\nexport declare function getNullableType<T extends GraphQLNullableType>(\n  type: T | GraphQLNonNull<T>,\n): T;\nexport declare function getNullableType(\n  type: Maybe<GraphQLType>,\n): GraphQLNullableType | undefined;\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nexport declare type GraphQLNamedType =\n  | GraphQLNamedInputType\n  | GraphQLNamedOutputType;\nexport declare type GraphQLNamedInputType =\n  | GraphQLScalarType\n  | GraphQLEnumType\n  | GraphQLInputObjectType;\nexport declare type GraphQLNamedOutputType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType;\nexport declare function isNamedType(type: unknown): type is GraphQLNamedType;\nexport declare function assertNamedType(type: unknown): GraphQLNamedType;\nexport declare function getNamedType(type: undefined | null): void;\nexport declare function getNamedType(\n  type: GraphQLInputType,\n): GraphQLNamedInputType;\nexport declare function getNamedType(\n  type: GraphQLOutputType,\n): GraphQLNamedOutputType;\nexport declare function getNamedType(type: GraphQLType): GraphQLNamedType;\nexport declare function getNamedType(\n  type: Maybe<GraphQLType>,\n): GraphQLNamedType | undefined;\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\nexport declare type ThunkReadonlyArray<T> =\n  | (() => ReadonlyArray<T>)\n  | ReadonlyArray<T>;\nexport declare type ThunkObjMap<T> = (() => ObjMap<T>) | ObjMap<T>;\nexport declare function resolveReadonlyArrayThunk<T>(\n  thunk: ThunkReadonlyArray<T>,\n): ReadonlyArray<T>;\nexport declare function resolveObjMapThunk<T>(thunk: ThunkObjMap<T>): ObjMap<T>;\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLScalarTypeExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function returns `null` or does not return a value\n * (i.e. it returns `undefined`) then an error will be raised and a `null`\n * value will be returned in the response. It is always better to validate\n *\n * Example:\n *\n * ```ts\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   serialize(value) {\n *     if (!Number.isFinite(value)) {\n *       throw new Error(\n *         `Scalar \"Odd\" cannot represent \"${value}\" since it is not a finite number.`,\n *       );\n *     }\n *\n *     if (value % 2 === 0) {\n *       throw new Error(`Scalar \"Odd\" cannot represent \"${value}\" since it is even.`);\n *     }\n *     return value;\n *   }\n * });\n * ```\n */\nexport declare class GraphQLScalarType<\n  TInternal = unknown,\n  TExternal = TInternal,\n> {\n  name: string;\n  description: Maybe<string>;\n  specifiedByURL: Maybe<string>;\n  serialize: GraphQLScalarSerializer<TExternal>;\n  parseValue: GraphQLScalarValueParser<TInternal>;\n  parseLiteral: GraphQLScalarLiteralParser<TInternal>;\n  extensions: Readonly<GraphQLScalarTypeExtensions>;\n  astNode: Maybe<ScalarTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;\n  constructor(config: Readonly<GraphQLScalarTypeConfig<TInternal, TExternal>>);\n  get [Symbol.toStringTag](): string;\n  toConfig(): GraphQLScalarTypeNormalizedConfig<TInternal, TExternal>;\n  toString(): string;\n  toJSON(): string;\n}\nexport declare type GraphQLScalarSerializer<TExternal> = (\n  outputValue: unknown,\n) => TExternal;\nexport declare type GraphQLScalarValueParser<TInternal> = (\n  inputValue: unknown,\n) => TInternal;\nexport declare type GraphQLScalarLiteralParser<TInternal> = (\n  valueNode: ValueNode,\n  variables?: Maybe<ObjMap<unknown>>,\n) => TInternal;\nexport interface GraphQLScalarTypeConfig<TInternal, TExternal> {\n  name: string;\n  description?: Maybe<string>;\n  specifiedByURL?: Maybe<string>;\n  /** Serializes an internal value to include in a response. */\n  serialize?: GraphQLScalarSerializer<TExternal>;\n  /** Parses an externally provided value to use as an input. */\n  parseValue?: GraphQLScalarValueParser<TInternal>;\n  /** Parses an externally provided literal value to use as an input. */\n  parseLiteral?: GraphQLScalarLiteralParser<TInternal>;\n  extensions?: Maybe<Readonly<GraphQLScalarTypeExtensions>>;\n  astNode?: Maybe<ScalarTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<ScalarTypeExtensionNode>>;\n}\ninterface GraphQLScalarTypeNormalizedConfig<TInternal, TExternal>\n  extends GraphQLScalarTypeConfig<TInternal, TExternal> {\n  serialize: GraphQLScalarSerializer<TExternal>;\n  parseValue: GraphQLScalarValueParser<TInternal>;\n  parseLiteral: GraphQLScalarLiteralParser<TInternal>;\n  extensions: Readonly<GraphQLScalarTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n *\n * We've provided these template arguments because this is an open type and\n * you may find them useful.\n */\nexport interface GraphQLObjectTypeExtensions<_TSource = any, _TContext = any> {\n  [attributeName: string]: unknown;\n}\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\nexport declare class GraphQLObjectType<TSource = any, TContext = any> {\n  name: string;\n  description: Maybe<string>;\n  isTypeOf: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;\n  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;\n  astNode: Maybe<ObjectTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;\n  private _fields;\n  private _interfaces;\n  constructor(config: Readonly<GraphQLObjectTypeConfig<TSource, TContext>>);\n  get [Symbol.toStringTag](): string;\n  getFields(): GraphQLFieldMap<TSource, TContext>;\n  getInterfaces(): ReadonlyArray<GraphQLInterfaceType>;\n  toConfig(): GraphQLObjectTypeNormalizedConfig<TSource, TContext>;\n  toString(): string;\n  toJSON(): string;\n}\nexport declare function defineArguments(\n  config: GraphQLFieldConfigArgumentMap,\n): ReadonlyArray<GraphQLArgument>;\n/**\n * @internal\n */\nexport declare function argsToArgsConfig(\n  args: ReadonlyArray<GraphQLArgument>,\n): GraphQLFieldConfigArgumentMap;\nexport interface GraphQLObjectTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType>;\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;\n  isTypeOf?: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>>;\n  astNode?: Maybe<ObjectTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<ObjectTypeExtensionNode>>;\n}\ninterface GraphQLObjectTypeNormalizedConfig<TSource, TContext>\n  extends GraphQLObjectTypeConfig<any, any> {\n  interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  fields: GraphQLFieldConfigMap<any, any>;\n  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;\n  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;\n}\nexport declare type GraphQLTypeResolver<TSource, TContext> = (\n  value: TSource,\n  context: TContext,\n  info: GraphQLResolveInfo,\n  abstractType: GraphQLAbstractType,\n) => PromiseOrValue<string | undefined>;\nexport declare type GraphQLIsTypeOfFn<TSource, TContext> = (\n  source: TSource,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => PromiseOrValue<boolean>;\nexport declare type GraphQLFieldResolver<\n  TSource,\n  TContext,\n  TArgs = any,\n  TResult = unknown,\n> = (\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => TResult;\nexport interface GraphQLResolveInfo {\n  readonly fieldName: string;\n  readonly fieldNodes: ReadonlyArray<FieldNode>;\n  readonly returnType: GraphQLOutputType;\n  readonly parentType: GraphQLObjectType;\n  readonly path: Path;\n  readonly schema: GraphQLSchema;\n  readonly fragments: ObjMap<FragmentDefinitionNode>;\n  readonly rootValue: unknown;\n  readonly operation: OperationDefinitionNode;\n  readonly variableValues: {\n    [variable: string]: unknown;\n  };\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n *\n * We've provided these template arguments because this is an open type and\n * you may find them useful.\n */\nexport interface GraphQLFieldExtensions<_TSource, _TContext, _TArgs = any> {\n  [attributeName: string]: unknown;\n}\nexport interface GraphQLFieldConfig<TSource, TContext, TArgs = any> {\n  description?: Maybe<string>;\n  type: GraphQLOutputType;\n  args?: GraphQLFieldConfigArgumentMap;\n  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>;\n  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<\n    Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>\n  >;\n  astNode?: Maybe<FieldDefinitionNode>;\n}\nexport declare type GraphQLFieldConfigArgumentMap =\n  ObjMap<GraphQLArgumentConfig>;\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLArgumentExtensions {\n  [attributeName: string]: unknown;\n}\nexport interface GraphQLArgumentConfig {\n  description?: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue?: unknown;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLArgumentExtensions>>;\n  astNode?: Maybe<InputValueDefinitionNode>;\n}\nexport declare type GraphQLFieldConfigMap<TSource, TContext> = ObjMap<\n  GraphQLFieldConfig<TSource, TContext>\n>;\nexport interface GraphQLField<TSource, TContext, TArgs = any> {\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLOutputType;\n  args: ReadonlyArray<GraphQLArgument>;\n  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>;\n  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>;\n  astNode: Maybe<FieldDefinitionNode>;\n}\nexport interface GraphQLArgument {\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue: unknown;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLArgumentExtensions>;\n  astNode: Maybe<InputValueDefinitionNode>;\n}\nexport declare function isRequiredArgument(arg: GraphQLArgument): boolean;\nexport declare type GraphQLFieldMap<TSource, TContext> = ObjMap<\n  GraphQLField<TSource, TContext>\n>;\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInterfaceTypeExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\nexport declare class GraphQLInterfaceType {\n  name: string;\n  description: Maybe<string>;\n  resolveType: Maybe<GraphQLTypeResolver<any, any>>;\n  extensions: Readonly<GraphQLInterfaceTypeExtensions>;\n  astNode: Maybe<InterfaceTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;\n  private _fields;\n  private _interfaces;\n  constructor(config: Readonly<GraphQLInterfaceTypeConfig<any, any>>);\n  get [Symbol.toStringTag](): string;\n  getFields(): GraphQLFieldMap<any, any>;\n  getInterfaces(): ReadonlyArray<GraphQLInterfaceType>;\n  toConfig(): GraphQLInterfaceTypeNormalizedConfig;\n  toString(): string;\n  toJSON(): string;\n}\nexport interface GraphQLInterfaceTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType>;\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLInterfaceTypeExtensions>>;\n  astNode?: Maybe<InterfaceTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<InterfaceTypeExtensionNode>>;\n}\nexport interface GraphQLInterfaceTypeNormalizedConfig\n  extends GraphQLInterfaceTypeConfig<any, any> {\n  interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  fields: GraphQLFieldConfigMap<any, any>;\n  extensions: Readonly<GraphQLInterfaceTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLUnionTypeExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\nexport declare class GraphQLUnionType {\n  name: string;\n  description: Maybe<string>;\n  resolveType: Maybe<GraphQLTypeResolver<any, any>>;\n  extensions: Readonly<GraphQLUnionTypeExtensions>;\n  astNode: Maybe<UnionTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;\n  private _types;\n  constructor(config: Readonly<GraphQLUnionTypeConfig<any, any>>);\n  get [Symbol.toStringTag](): string;\n  getTypes(): ReadonlyArray<GraphQLObjectType>;\n  toConfig(): GraphQLUnionTypeNormalizedConfig;\n  toString(): string;\n  toJSON(): string;\n}\nexport interface GraphQLUnionTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  types: ThunkReadonlyArray<GraphQLObjectType>;\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLUnionTypeExtensions>>;\n  astNode?: Maybe<UnionTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<UnionTypeExtensionNode>>;\n}\ninterface GraphQLUnionTypeNormalizedConfig\n  extends GraphQLUnionTypeConfig<any, any> {\n  types: ReadonlyArray<GraphQLObjectType>;\n  extensions: Readonly<GraphQLUnionTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLEnumTypeExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport declare class GraphQLEnumType {\n  name: string;\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLEnumTypeExtensions>;\n  astNode: Maybe<EnumTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;\n  private _values;\n  private _valueLookup;\n  private _nameLookup;\n  constructor(config: Readonly<GraphQLEnumTypeConfig>);\n  get [Symbol.toStringTag](): string;\n  getValues(): ReadonlyArray<GraphQLEnumValue>;\n  getValue(name: string): Maybe<GraphQLEnumValue>;\n  serialize(outputValue: unknown): Maybe<string>;\n  parseValue(inputValue: unknown): Maybe<any>;\n  parseLiteral(\n    valueNode: ValueNode,\n    _variables: Maybe<ObjMap<unknown>>,\n  ): Maybe<any>;\n  toConfig(): GraphQLEnumTypeNormalizedConfig;\n  toString(): string;\n  toJSON(): string;\n}\nexport interface GraphQLEnumTypeConfig {\n  name: string;\n  description?: Maybe<string>;\n  values: ThunkObjMap<GraphQLEnumValueConfig>;\n  extensions?: Maybe<Readonly<GraphQLEnumTypeExtensions>>;\n  astNode?: Maybe<EnumTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<EnumTypeExtensionNode>>;\n}\ninterface GraphQLEnumTypeNormalizedConfig extends GraphQLEnumTypeConfig {\n  values: ObjMap<GraphQLEnumValueConfig>;\n  extensions: Readonly<GraphQLEnumTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;\n}\nexport declare type GraphQLEnumValueConfigMap = ObjMap<GraphQLEnumValueConfig>;\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLEnumValueExtensions {\n  [attributeName: string]: unknown;\n}\nexport interface GraphQLEnumValueConfig {\n  description?: Maybe<string>;\n  value?: any;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLEnumValueExtensions>>;\n  astNode?: Maybe<EnumValueDefinitionNode>;\n}\nexport interface GraphQLEnumValue {\n  name: string;\n  description: Maybe<string>;\n  value: any;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLEnumValueExtensions>;\n  astNode: Maybe<EnumValueDefinitionNode>;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInputObjectTypeExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\nexport declare class GraphQLInputObjectType {\n  name: string;\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLInputObjectTypeExtensions>;\n  astNode: Maybe<InputObjectTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;\n  isOneOf: boolean;\n  private _fields;\n  constructor(config: Readonly<GraphQLInputObjectTypeConfig>);\n  get [Symbol.toStringTag](): string;\n  getFields(): GraphQLInputFieldMap;\n  toConfig(): GraphQLInputObjectTypeNormalizedConfig;\n  toString(): string;\n  toJSON(): string;\n}\nexport interface GraphQLInputObjectTypeConfig {\n  name: string;\n  description?: Maybe<string>;\n  fields: ThunkObjMap<GraphQLInputFieldConfig>;\n  extensions?: Maybe<Readonly<GraphQLInputObjectTypeExtensions>>;\n  astNode?: Maybe<InputObjectTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<InputObjectTypeExtensionNode>>;\n  isOneOf?: boolean;\n}\ninterface GraphQLInputObjectTypeNormalizedConfig\n  extends GraphQLInputObjectTypeConfig {\n  fields: GraphQLInputFieldConfigMap;\n  extensions: Readonly<GraphQLInputObjectTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInputFieldExtensions {\n  [attributeName: string]: unknown;\n}\nexport interface GraphQLInputFieldConfig {\n  description?: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue?: unknown;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLInputFieldExtensions>>;\n  astNode?: Maybe<InputValueDefinitionNode>;\n}\nexport declare type GraphQLInputFieldConfigMap =\n  ObjMap<GraphQLInputFieldConfig>;\nexport interface GraphQLInputField {\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue: unknown;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLInputFieldExtensions>;\n  astNode: Maybe<InputValueDefinitionNode>;\n}\nexport declare function isRequiredInputField(field: GraphQLInputField): boolean;\nexport declare type GraphQLInputFieldMap = ObjMap<GraphQLInputField>;\nexport {};\n\n\n\n\n\n\n\n\n\n/**\n * Test if the given value is a GraphQL schema.\n */\nexport declare function isSchema(schema: unknown): schema is GraphQLSchema;\nexport declare function assertSchema(schema: unknown): GraphQLSchema;\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLSchemaExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nexport declare class GraphQLSchema {\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLSchemaExtensions>;\n  astNode: Maybe<SchemaDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<SchemaExtensionNode>;\n  __validationErrors: Maybe<ReadonlyArray<GraphQLError>>;\n  private _queryType;\n  private _mutationType;\n  private _subscriptionType;\n  private _directives;\n  private _typeMap;\n  private _subTypeMap;\n  private _implementationsMap;\n  constructor(config: Readonly<GraphQLSchemaConfig>);\n  get [Symbol.toStringTag](): string;\n  getQueryType(): Maybe<GraphQLObjectType>;\n  getMutationType(): Maybe<GraphQLObjectType>;\n  getSubscriptionType(): Maybe<GraphQLObjectType>;\n  getRootType(operation: OperationTypeNode): Maybe<GraphQLObjectType>;\n  getTypeMap(): TypeMap;\n  getType(name: string): GraphQLNamedType | undefined;\n  getPossibleTypes(\n    abstractType: GraphQLAbstractType,\n  ): ReadonlyArray<GraphQLObjectType>;\n  getImplementations(interfaceType: GraphQLInterfaceType): {\n    objects: ReadonlyArray<GraphQLObjectType>;\n    interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  };\n  isSubType(\n    abstractType: GraphQLAbstractType,\n    maybeSubType: GraphQLObjectType | GraphQLInterfaceType,\n  ): boolean;\n  getDirectives(): ReadonlyArray<GraphQLDirective>;\n  getDirective(name: string): Maybe<GraphQLDirective>;\n  toConfig(): GraphQLSchemaNormalizedConfig;\n}\ndeclare type TypeMap = ObjMap<GraphQLNamedType>;\nexport interface GraphQLSchemaValidationOptions {\n  /**\n   * When building a schema from a GraphQL service's introspection result, it\n   * might be safe to assume the schema is valid. Set to true to assume the\n   * produced schema is valid.\n   *\n   * Default: false\n   */\n  assumeValid?: boolean;\n}\nexport interface GraphQLSchemaConfig extends GraphQLSchemaValidationOptions {\n  description?: Maybe<string>;\n  query?: Maybe<GraphQLObjectType>;\n  mutation?: Maybe<GraphQLObjectType>;\n  subscription?: Maybe<GraphQLObjectType>;\n  types?: Maybe<ReadonlyArray<GraphQLNamedType>>;\n  directives?: Maybe<ReadonlyArray<GraphQLDirective>>;\n  extensions?: Maybe<Readonly<GraphQLSchemaExtensions>>;\n  astNode?: Maybe<SchemaDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<SchemaExtensionNode>>;\n}\n/**\n * @internal\n */\nexport interface GraphQLSchemaNormalizedConfig extends GraphQLSchemaConfig {\n  description: Maybe<string>;\n  types: ReadonlyArray<GraphQLNamedType>;\n  directives: ReadonlyArray<GraphQLDirective>;\n  extensions: Readonly<GraphQLSchemaExtensions>;\n  extensionASTNodes: ReadonlyArray<SchemaExtensionNode>;\n  assumeValid: boolean;\n}\nexport {};\n\n\n\n\n\n\n/**\n * Test if the given value is a GraphQL directive.\n */\nexport declare function isDirective(\n  directive: unknown,\n): directive is GraphQLDirective;\nexport declare function assertDirective(directive: unknown): GraphQLDirective;\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLDirectiveExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Directives are used by the GraphQL runtime as a way of modifying execution\n * behavior. Type system creators will usually not create these directly.\n */\nexport declare class GraphQLDirective {\n  name: string;\n  description: Maybe<string>;\n  locations: ReadonlyArray<DirectiveLocation>;\n  args: ReadonlyArray<GraphQLArgument>;\n  isRepeatable: boolean;\n  extensions: Readonly<GraphQLDirectiveExtensions>;\n  astNode: Maybe<DirectiveDefinitionNode>;\n  constructor(config: Readonly<GraphQLDirectiveConfig>);\n  get [Symbol.toStringTag](): string;\n  toConfig(): GraphQLDirectiveNormalizedConfig;\n  toString(): string;\n  toJSON(): string;\n}\nexport interface GraphQLDirectiveConfig {\n  name: string;\n  description?: Maybe<string>;\n  locations: ReadonlyArray<DirectiveLocation>;\n  args?: Maybe<GraphQLFieldConfigArgumentMap>;\n  isRepeatable?: Maybe<boolean>;\n  extensions?: Maybe<Readonly<GraphQLDirectiveExtensions>>;\n  astNode?: Maybe<DirectiveDefinitionNode>;\n}\ninterface GraphQLDirectiveNormalizedConfig extends GraphQLDirectiveConfig {\n  args: GraphQLFieldConfigArgumentMap;\n  isRepeatable: boolean;\n  extensions: Readonly<GraphQLDirectiveExtensions>;\n}\n/**\n * Used to conditionally include fields or fragments.\n */\nexport declare const GraphQLIncludeDirective: GraphQLDirective;\n/**\n * Used to conditionally skip (exclude) fields or fragments.\n */\nexport declare const GraphQLSkipDirective: GraphQLDirective;\n/**\n * Constant string used for default reason for a deprecation.\n */\nexport declare const DEFAULT_DEPRECATION_REASON = 'No longer supported';\n/**\n * Used to declare element of a GraphQL schema as deprecated.\n */\nexport declare const GraphQLDeprecatedDirective: GraphQLDirective;\n/**\n * Used to provide a URL for specifying the behavior of custom scalar definitions.\n */\nexport declare const GraphQLSpecifiedByDirective: GraphQLDirective;\n/**\n * Used to indicate an Input Object is a OneOf Input Object.\n */\nexport declare const GraphQLOneOfDirective: GraphQLDirective;\n/**\n * The full list of specified directives.\n */\nexport declare const specifiedDirectives: ReadonlyArray<GraphQLDirective>;\nexport declare function isSpecifiedDirective(\n  directive: GraphQLDirective,\n): boolean;\nexport {};\n\n\n\n\n/**\n * Maximum possible Int value as per GraphQL Spec (32-bit signed integer).\n * n.b. This differs from JavaScript's numbers that are IEEE 754 doubles safe up-to 2^53 - 1\n * */\nexport declare const GRAPHQL_MAX_INT = 2147483647;\n/**\n * Minimum possible Int value as per GraphQL Spec (32-bit signed integer).\n * n.b. This differs from JavaScript's numbers that are IEEE 754 doubles safe starting at -(2^53 - 1)\n * */\nexport declare const GRAPHQL_MIN_INT = -2147483648;\nexport declare const GraphQLInt: GraphQLScalarType<number, number>;\nexport declare const GraphQLFloat: GraphQLScalarType<number, number>;\nexport declare const GraphQLString: GraphQLScalarType<string, string>;\nexport declare const GraphQLBoolean: GraphQLScalarType<boolean, boolean>;\nexport declare const GraphQLID: GraphQLScalarType<string, string>;\nexport declare const specifiedScalarTypes: ReadonlyArray<GraphQLScalarType>;\nexport declare function isSpecifiedScalarType(type: GraphQLNamedType): boolean;\n\n\n\n\nexport declare const __Schema: GraphQLObjectType;\nexport declare const __Directive: GraphQLObjectType;\nexport declare const __DirectiveLocation: GraphQLEnumType;\nexport declare const __Type: GraphQLObjectType;\nexport declare const __Field: GraphQLObjectType;\nexport declare const __InputValue: GraphQLObjectType;\nexport declare const __EnumValue: GraphQLObjectType;\ndeclare enum TypeKind {\n  SCALAR = 'SCALAR',\n  OBJECT = 'OBJECT',\n  INTERFACE = 'INTERFACE',\n  UNION = 'UNION',\n  ENUM = 'ENUM',\n  INPUT_OBJECT = 'INPUT_OBJECT',\n  LIST = 'LIST',\n  NON_NULL = 'NON_NULL',\n}\nexport { TypeKind };\nexport declare const __TypeKind: GraphQLEnumType;\n/**\n * Note that these are GraphQLField and not GraphQLFieldConfig,\n * so the format for args is different.\n */\nexport declare const SchemaMetaFieldDef: GraphQLField<unknown, unknown>;\nexport declare const TypeMetaFieldDef: GraphQLField<unknown, unknown>;\nexport declare const TypeNameMetaFieldDef: GraphQLField<unknown, unknown>;\nexport declare const introspectionTypes: ReadonlyArray<GraphQLNamedType>;\nexport declare function isIntrospectionType(type: GraphQLNamedType): boolean;\n\n\n\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nexport declare function validateSchema(\n  schema: GraphQLSchema,\n): ReadonlyArray<GraphQLError>;\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\nexport declare function assertValidSchema(schema: GraphQLSchema): void;\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\nexport interface ExecutionContext {\n  schema: GraphQLSchema;\n  fragments: ObjMap<FragmentDefinitionNode>;\n  rootValue: unknown;\n  contextValue: unknown;\n  operation: OperationDefinitionNode;\n  variableValues: {\n    [variable: string]: unknown;\n  };\n  fieldResolver: GraphQLFieldResolver<any, any>;\n  typeResolver: GraphQLTypeResolver<any, any>;\n  subscribeFieldResolver: GraphQLFieldResolver<any, any>;\n  errors: Array<GraphQLError>;\n}\n/**\n * The result of GraphQL execution.\n *\n *   - `errors` is included when any errors occurred as a non-empty array.\n *   - `data` is the result of a successful execution of the query.\n *   - `extensions` is reserved for adding non-standard properties.\n */\nexport interface ExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  errors?: ReadonlyArray<GraphQLError>;\n  data?: TData | null;\n  extensions?: TExtensions;\n}\nexport interface FormattedExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  errors?: ReadonlyArray<GraphQLFormattedError>;\n  data?: TData | null;\n  extensions?: TExtensions;\n}\nexport interface ExecutionArgs {\n  schema: GraphQLSchema;\n  document: DocumentNode;\n  rootValue?: unknown;\n  contextValue?: unknown;\n  variableValues?: Maybe<{\n    readonly [variable: string]: unknown;\n  }>;\n  operationName?: Maybe<string>;\n  fieldResolver?: Maybe<GraphQLFieldResolver<any, any>>;\n  typeResolver?: Maybe<GraphQLTypeResolver<any, any>>;\n  subscribeFieldResolver?: Maybe<GraphQLFieldResolver<any, any>>;\n  /** Additional execution options. */\n  options?: {\n    /** Set the maximum number of errors allowed for coercing (defaults to 50). */\n    maxCoercionErrors?: number;\n  };\n}\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport declare function execute(\n  args: ExecutionArgs,\n): PromiseOrValue<ExecutionResult>;\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\nexport declare function executeSync(args: ExecutionArgs): ExecutionResult;\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\nexport declare function assertValidExecutionArguments(\n  schema: GraphQLSchema,\n  document: DocumentNode,\n  rawVariableValues: Maybe<{\n    readonly [variable: string]: unknown;\n  }>,\n): void;\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\nexport declare function buildExecutionContext(\n  args: ExecutionArgs,\n): ReadonlyArray<GraphQLError> | ExecutionContext;\n/**\n * @internal\n */\nexport declare function buildResolveInfo(\n  exeContext: ExecutionContext,\n  fieldDef: GraphQLField<unknown, unknown>,\n  fieldNodes: ReadonlyArray<FieldNode>,\n  parentType: GraphQLObjectType,\n  path: Path,\n): GraphQLResolveInfo;\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\nexport declare const defaultTypeResolver: GraphQLTypeResolver<unknown, unknown>;\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\nexport declare const defaultFieldResolver: GraphQLFieldResolver<\n  unknown,\n  unknown\n>;\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\nexport declare function getFieldDef(\n  schema: GraphQLSchema,\n  parentType: GraphQLObjectType,\n  fieldNode: FieldNode,\n): Maybe<GraphQLField<unknown, unknown>>;\n\n\n\n\n\n\n\n\n\ndeclare type CoercedVariableValues =\n  | {\n      errors: ReadonlyArray<GraphQLError>;\n      coerced?: never;\n    }\n  | {\n      coerced: {\n        [variable: string]: unknown;\n      };\n      errors?: never;\n    };\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport declare function getVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: {\n    readonly [variable: string]: unknown;\n  },\n  options?: {\n    maxErrors?: number;\n  },\n): CoercedVariableValues;\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport declare function getArgumentValues(\n  def: GraphQLField<unknown, unknown> | GraphQLDirective,\n  node: FieldNode | DirectiveNode,\n  variableValues?: Maybe<ObjMap<unknown>>,\n): {\n  [argument: string]: unknown;\n};\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport declare function getDirectiveValues(\n  directiveDef: GraphQLDirective,\n  node: {\n    readonly directives?: ReadonlyArray<DirectiveNode>;\n  },\n  variableValues?: Maybe<ObjMap<unknown>>,\n):\n  | undefined\n  | {\n      [argument: string]: unknown;\n    };\nexport {};\n\n\n\n\n\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLErrorExtensions {\n  [attributeName: string]: unknown;\n}\n/**\n * Custom formatted extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLFormattedErrorExtensions {\n  [attributeName: string]: unknown;\n}\nexport interface GraphQLErrorOptions {\n  nodes?: ReadonlyArray<ASTNode> | ASTNode | null;\n  source?: Maybe<Source>;\n  positions?: Maybe<ReadonlyArray<number>>;\n  path?: Maybe<ReadonlyArray<string | number>>;\n  originalError?: Maybe<\n    Error & {\n      readonly extensions?: unknown;\n    }\n  >;\n  extensions?: Maybe<GraphQLErrorExtensions>;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\nexport declare class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n  readonly locations: ReadonlyArray<SourceLocation> | undefined;\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n  readonly path: ReadonlyArray<string | number> | undefined;\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n  readonly nodes: ReadonlyArray<ASTNode> | undefined;\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n  readonly source: Source | undefined;\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n  readonly positions: ReadonlyArray<number> | undefined;\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n  readonly originalError: Error | undefined;\n  /**\n   * Extension fields to add to the formatted error.\n   */\n  readonly extensions: GraphQLErrorExtensions;\n  constructor(message: string, options?: GraphQLErrorOptions);\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<\n      Error & {\n        readonly extensions?: unknown;\n      }\n    >,\n    extensions?: Maybe<GraphQLErrorExtensions>,\n  );\n  get [Symbol.toStringTag](): string;\n  toString(): string;\n  toJSON(): GraphQLFormattedError;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\nexport interface GraphQLFormattedError {\n  /**\n   * A short, human-readable summary of the problem that **SHOULD NOT** change\n   * from occurrence to occurrence of the problem, except for purposes of\n   * localization.\n   */\n  readonly message: string;\n  /**\n   * If an error can be associated to a particular point in the requested\n   * GraphQL document, it should contain a list of locations.\n   */\n  readonly locations?: ReadonlyArray<SourceLocation>;\n  /**\n   * If an error can be associated to a particular field in the GraphQL result,\n   * it _must_ contain an entry with the key `path` that details the path of\n   * the response field which experienced the error. This allows clients to\n   * identify whether a null result is intentional or caused by a runtime error.\n   */\n  readonly path?: ReadonlyArray<string | number>;\n  /**\n   * Reserved for implementors to extend the protocol however they see fit,\n   * and hence there are no additional restrictions on its contents.\n   */\n  readonly extensions?: GraphQLFormattedErrorExtensions;\n}\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport declare function printError(error: GraphQLError): string;\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toJSON` instead. Will be removed in v17\n */\nexport declare function formatError(error: GraphQLError): GraphQLFormattedError;\n\n}"
  },
  {
    "moduleName": "@pothos/core/build-cache",
    "content": "declare module '@pothos/core/build-cache' {\nimport { GraphQLInterfaceType, type GraphQLNamedType } from 'graphql';\nimport type { SchemaBuilder } from '@pothos/core/builder';\nimport { type BasePlugin } from '@pothos/core/plugins';\nimport { type InputType, type OutputType, type PothosInputFieldConfig, type PothosObjectTypeConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class BuildCache<Types extends SchemaTypes> {\n    types: Map<string, GraphQLNamedType>;\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    plugin: BasePlugin<Types>;\n    options: PothosSchemaTypes.BuildSchemaOptions<Types>;\n    private configStore;\n    private pluginList;\n    private implementers;\n    private typeConfigs;\n    private enumValueConfigs;\n    private outputFieldConfigs;\n    private inputFieldConfigs;\n    constructor(builder: SchemaBuilder<Types>, options: PothosSchemaTypes.BuildSchemaOptions<Types>);\n    getTypeConfig<T extends PothosTypeConfig['kind']>(ref: InputType<Types> | OutputType<Types> | string, kind?: T): Extract<PothosTypeConfig, {\n        kind: T;\n    }>;\n    getInputTypeFieldConfigs(ref: InputType<Types>): Record<string, PothosInputFieldConfig<Types>>;\n    getImplementers(iface: GraphQLInterfaceType): PothosObjectTypeConfig[];\n    buildAll(): void;\n    buildTypeFromConfig(baseConfig: PothosTypeConfig): void;\n    private addType;\n    private buildOutputTypeParam;\n    private buildInputTypeParam;\n    private buildFields;\n    private buildInputFields;\n    private getInterfaceFields;\n    private getObjectFields;\n    private getRootFields;\n    private getFields;\n    private getInputFields;\n    private getType;\n    private getOutputType;\n    private getInputType;\n    private getTypeOfKind;\n    private buildObject;\n    private buildInterface;\n    private buildUnion;\n    private buildInputObject;\n    private buildScalar;\n    private buildEnum;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/builder",
    "content": "declare module '@pothos/core/builder' {\nimport { type GraphQLScalarSerializer, type GraphQLScalarType, GraphQLSchema } from 'graphql';\nimport { ConfigStore } from '@pothos/core/config-store';\nimport { InputObjectRef } from '@pothos/core/refs/input-object';\nimport { MutationRef } from '@pothos/core/refs/mutation';\nimport { QueryRef } from '@pothos/core/refs/query';\nimport { SubscriptionRef } from '@pothos/core/refs/subscription';\nimport type { AbstractReturnShape, AddVersionedDefaultsToBuilderOptions, BaseEnum, EnumParam, EnumTypeOptions, EnumValues, InputFieldMap, InputFieldsFromShape, InputShape, InputShapeFromFields, InterfaceFieldsShape, InterfaceFieldThunk, InterfaceParam, InterfaceTypeOptions, MutationFieldsShape, MutationFieldThunk, NormalizeArgs, NormalizeSchemeBuilderOptions, ObjectFieldsShape, ObjectFieldThunk, ObjectParam, ObjectTypeOptions, OneOfInputShapeFromFields, OutputShape, ParentShape, PluginConstructorMap, QueryFieldsShape, QueryFieldThunk, RecursivelyNormalizeNullableFields, ScalarName, SchemaTypes, ShapeFromEnumValues, SubscriptionFieldsShape, SubscriptionFieldThunk, ValuesFromEnum } from '@pothos/core/types';\nexport declare class SchemaBuilder<Types extends SchemaTypes> {\n    $inferSchemaTypes: Types;\n    private queryRef;\n    private mutationRef;\n    private subscriptionRef;\n    static plugins: Partial<PluginConstructorMap<SchemaTypes>>;\n    static optionNormalizers: Map<string, {\n        v3?: (options: AddVersionedDefaultsToBuilderOptions<SchemaTypes, 'v3'>) => Partial<NormalizeSchemeBuilderOptions<SchemaTypes>>;\n        v4?: undefined;\n    }>;\n    static allowPluginReRegistration: boolean;\n    configStore: ConfigStore<Types>;\n    options: PothosSchemaTypes.SchemaBuilderOptions<Types>;\n    defaultFieldNullability: boolean;\n    defaultInputFieldRequiredness: boolean;\n    constructor(options: PothosSchemaTypes.SchemaBuilderOptions<Types>);\n    static registerPlugin<T extends keyof PluginConstructorMap<SchemaTypes>>(name: T, plugin: PluginConstructorMap<SchemaTypes>[T], normalizeOptions?: {\n        v3?: (options: AddVersionedDefaultsToBuilderOptions<SchemaTypes, 'v3'>) => Partial<NormalizeSchemeBuilderOptions<SchemaTypes>>;\n    }): void;\n    objectType<const Interfaces extends InterfaceParam<Types>[], Param extends ObjectParam<Types>>(param: Param, options: ObjectTypeOptions<Types, Param, ParentShape<Types, Param>, Interfaces>, fields?: ObjectFieldsShape<Types, ParentShape<Types, Param>>): PothosSchemaTypes.ObjectRef<Types, OutputShape<Types, Param>, ParentShape<Types, Param>>;\n    objectFields<Type extends ObjectParam<Types>>(param: Type, fields: ObjectFieldsShape<Types, ParentShape<Types, Type>>): void;\n    objectField<Type extends ObjectParam<Types>>(param: Type, fieldName: string, field: ObjectFieldThunk<Types, ParentShape<Types, Type>>): void;\n    queryType(...args: NormalizeArgs<[\n        options: PothosSchemaTypes.QueryTypeOptions<Types>,\n        fields?: QueryFieldsShape<Types>\n    ], 0>): QueryRef<Types>;\n    queryFields(fields: QueryFieldsShape<Types>): void;\n    queryField(name: string, field: QueryFieldThunk<Types>): void;\n    mutationType(...args: NormalizeArgs<[\n        options: PothosSchemaTypes.MutationTypeOptions<Types>,\n        fields?: MutationFieldsShape<Types>\n    ], 0>): MutationRef<Types>;\n    mutationFields(fields: MutationFieldsShape<Types>): void;\n    mutationField(name: string, field: MutationFieldThunk<Types>): void;\n    subscriptionType(...args: NormalizeArgs<[\n        options: PothosSchemaTypes.SubscriptionTypeOptions<Types>,\n        fields?: SubscriptionFieldsShape<Types>\n    ], 0>): SubscriptionRef<Types>;\n    subscriptionFields(fields: SubscriptionFieldsShape<Types>): void;\n    subscriptionField(name: string, field: SubscriptionFieldThunk<Types>): void;\n    args<Shape extends InputFieldMap>(fields: (t: PothosSchemaTypes.InputFieldBuilder<Types, 'Arg'>) => Shape): Shape;\n    interfaceType<Param extends InterfaceParam<Types>, const Interfaces extends InterfaceParam<Types>[], ResolveType>(param: Param, options: InterfaceTypeOptions<Types, Param, ParentShape<Types, Param>, Interfaces, ResolveType>, fields?: InterfaceFieldsShape<Types, ParentShape<Types, Param>>): PothosSchemaTypes.InterfaceRef<Types, AbstractReturnShape<Types, Param, ResolveType>, ParentShape<Types, Param>>;\n    interfaceFields<Type extends InterfaceParam<Types>>(ref: Type, fields: InterfaceFieldsShape<Types, ParentShape<Types, Type>>): void;\n    interfaceField<Type extends InterfaceParam<Types>>(ref: Type, fieldName: string, field: InterfaceFieldThunk<Types, ParentShape<Types, Type>>): void;\n    unionType<Member extends ObjectParam<Types>, ResolveType>(name: string, options: PothosSchemaTypes.UnionTypeOptions<Types, Member, ResolveType>): PothosSchemaTypes.UnionRef<Types, AbstractReturnShape<Types, Member, ResolveType>, ParentShape<Types, Member>>;\n    enumType<Param extends EnumParam, const Values extends EnumValues<Types>>(param: Param, options: EnumTypeOptions<Types, Param, Values>): PothosSchemaTypes.EnumRef<Types, Param extends BaseEnum ? ValuesFromEnum<Param> : ShapeFromEnumValues<Types, Values>>;\n    scalarType<Name extends ScalarName<Types>>(name: Name, options: PothosSchemaTypes.ScalarTypeOptions<Types, InputShape<Types, Name>, ParentShape<Types, Name>>): PothosSchemaTypes.ScalarRef<Types, InputShape<Types, Name>, ParentShape<Types, Name>>;\n    addScalarType<Name extends ScalarName<Types>>(name: Name, scalar: GraphQLScalarType, ...args: NormalizeArgs<[\n        options: Omit<PothosSchemaTypes.ScalarTypeOptions<Types, InputShape<Types, Name>, OutputShape<Types, Name>>, 'serialize'> & {\n            serialize?: GraphQLScalarSerializer<OutputShape<Types, Name>>;\n        }\n    ]>): PothosSchemaTypes.ScalarRef<Types, InputShape<Types, Name>, ParentShape<Types, Name>, InputShape<Types, Name>>;\n    inputType<Param extends InputObjectRef<Types, unknown> | string, Fields extends Param extends PothosSchemaTypes.InputObjectRef<Types, unknown> ? InputFieldsFromShape<Types, InputShape<Types, Param> & object, 'InputObject'> : Param extends keyof Types['Inputs'] ? InputFieldsFromShape<Types, InputShape<Types, Param> & object, 'InputObject'> : InputFieldMap, IsOneOf extends boolean = boolean>(param: Param, options: PothosSchemaTypes.InputObjectTypeOptions<Types, Fields> & {\n        isOneOf?: IsOneOf;\n    }): PothosSchemaTypes.InputObjectRef<Types, [\n        IsOneOf\n    ] extends [true] ? OneOfInputShapeFromFields<Fields> : InputShapeFromFields<Fields>>;\n    inputRef<T extends object, Normalize = true>(name: string): PothosSchemaTypes.ImplementableInputObjectRef<Types, RecursivelyNormalizeNullableFields<T>, Normalize extends false ? T : RecursivelyNormalizeNullableFields<T>>;\n    objectRef<T>(name: string): PothosSchemaTypes.ImplementableObjectRef<Types, T>;\n    interfaceRef<T>(name: string): PothosSchemaTypes.ImplementableInterfaceRef<Types, T>;\n    toSchema(...args: NormalizeArgs<[options?: PothosSchemaTypes.BuildSchemaOptions<Types>]>): GraphQLSchema;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/config-store",
    "content": "declare module '@pothos/core/config-store' {\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { ConfigurableRef, FieldMap, GraphQLFieldKind, InputFieldMap, InputRef, OutputType, PothosFieldConfig, PothosTypeConfig, SchemaTypes } from '@pothos/core/types';\nexport declare class ConfigStore<Types extends SchemaTypes> {\n    typeConfigs: Map<string, PothosTypeConfig>;\n    private fields;\n    private refs;\n    private implementors;\n    private pendingActions;\n    private paramAssociations;\n    private pendingTypeConfigResolutions;\n    private pending;\n    private builder;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n    addFields(param: ConfigurableRef<Types>, fields: () => FieldMap): void;\n    addInputFields(param: ConfigurableRef<Types>, fields: () => InputFieldMap): void;\n    associateParamWithRef<T>(param: ConfigurableRef<Types>, ref: BaseTypeRef<Types, T> | string): void;\n    onTypeConfig(param: ConfigurableRef<Types>, onConfig: (config: PothosTypeConfig, ref: BaseTypeRef<Types>) => void): void;\n    onTypeConfigOfKind<Kind extends PothosTypeConfig['kind']>(param: ConfigurableRef<Types>, kind: Kind, onConfig: (config: PothosTypeConfig & {\n        kind: Kind;\n    }) => void): void;\n    addTypeRef<T extends PothosTypeConfig>(ref: BaseTypeRef<Types, T>): void;\n    subscribeToFields(_ref: BaseTypeRef<Types>): void;\n    hasImplementation(typeName: string): boolean;\n    hasConfig(ref: ConfigurableRef<Types> | string): boolean;\n    getTypeConfig<T extends PothosTypeConfig['kind']>(ref: ConfigurableRef<Types> | string, kind?: T): Extract<PothosTypeConfig, {\n        kind: T;\n    }>;\n    getInputTypeRef(param: ConfigurableRef<Types> | string): InputRef<unknown>;\n    getOutputTypeRef(param: ConfigurableRef<Types> | string): OutputType<Types>;\n    getFields<T extends GraphQLFieldKind>(name: string, kind?: T): Map<string, Extract<PothosFieldConfig<Types>, {\n        graphqlKind: T;\n    }>>;\n    prepareForBuild(): void;\n    onPrepare(cb: () => void): void;\n    private resolveParamAssociations;\n    private describeRef;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/errors",
    "content": "declare module '@pothos/core/errors' {\nimport { GraphQLError, type GraphQLErrorOptions } from 'graphql';\nexport declare class PothosError extends GraphQLError {\n    constructor(message: string, options?: GraphQLErrorOptions);\n}\nexport declare class PothosSchemaError extends PothosError {\n    constructor(message: string, options?: GraphQLErrorOptions);\n}\nexport declare class PothosValidationError extends PothosError {\n    constructor(message: string, options?: GraphQLErrorOptions);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/base",
    "content": "declare module '@pothos/core/fieldUtils/base' {\nimport { FieldRef } from '@pothos/core/refs/field';\nimport type { FieldKind, FieldNullability, InputFieldMap, Resolver, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core/types';\nexport declare class BaseFieldUtil<Types extends SchemaTypes, ParentShape, Kind extends FieldKind> {\n    kind: Kind;\n    graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[Kind];\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: Kind, graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[Kind]);\n    protected createField<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap = {}>(options: PothosSchemaTypes.FieldOptions<Types, ParentShape, Type, Nullable, Args, any, {}> & {\n        resolve?: Resolver<unknown, {}, {}, unknown, unknown>;\n    }): FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n    protected exposeField<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Name extends string & keyof ParentShape>(name: Name, { extensions, ...options }: PothosSchemaTypes.ObjectFieldOptions<Types, ParentShape, Type, Nullable, {}, {}>): FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/builder",
    "content": "declare module '@pothos/core/fieldUtils/builder' {\nimport type { CompatibleTypes, ExposeNullability, FieldKind, FieldNullability, FieldOptionsFromKind, InferredFieldOptionKeys, NormalizeArgs, SchemaTypes, TypeParam } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class FieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends RootFieldBuilder<Types, ParentShape, Kind> {\n    /**\n     * Create a Boolean field from a boolean property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeBoolean<Name extends CompatibleTypes<Types, ParentShape, 'Boolean', true>, ResolveReturnShape, Nullable extends FieldNullability<'Boolean'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'Boolean', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'Boolean', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Boolean\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Boolean\" extends infer T ? T extends \"Boolean\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Boolean\" extends infer T_1 ? T_1 extends \"Boolean\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Boolean\" extends infer T_2 ? T_2 extends \"Boolean\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Boolean\" extends infer T_3 ? T_3 extends \"Boolean\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Float field from a numeric property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeFloat<Name extends CompatibleTypes<Types, ParentShape, 'Float', true>, ResolveReturnShape, Nullable extends FieldNullability<'Float'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'Float', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'Float', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Float\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Float\" extends infer T ? T extends \"Float\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Float\" extends infer T_1 ? T_1 extends \"Float\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Float\" extends infer T_2 ? T_2 extends \"Float\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Float\" extends infer T_3 ? T_3 extends \"Float\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create an ID field from a property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeID<Name extends CompatibleTypes<Types, ParentShape, 'ID', true>, ResolveReturnShape, Nullable extends FieldNullability<'ID'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'ID', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"ID\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"ID\" extends infer T ? T extends \"ID\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"ID\" extends infer T_1 ? T_1 extends \"ID\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"ID\" extends infer T_2 ? T_2 extends \"ID\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"ID\" extends infer T_3 ? T_3 extends \"ID\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create an Int field from a numeric property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeInt<Name extends CompatibleTypes<Types, ParentShape, 'Int', true>, ResolveReturnShape, Nullable extends FieldNullability<'Int'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'Int', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'Int', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Int\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Int\" extends infer T ? T extends \"Int\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Int\" extends infer T_1 ? T_1 extends \"Int\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Int\" extends infer T_2 ? T_2 extends \"Int\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Int\" extends infer T_3 ? T_3 extends \"Int\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a String field from a string property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeString<Name extends CompatibleTypes<Types, ParentShape, 'String', true>, ResolveReturnShape, Nullable extends FieldNullability<'String'> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, 'String', ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, 'String', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"String\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"String\" extends infer T ? T extends \"String\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"String\" extends infer T_1 ? T_1 extends \"String\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"String\" extends infer T_2 ? T_2 extends \"String\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"String\" extends infer T_3 ? T_3 extends \"String\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Boolean list field from a boolean[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeBooleanList<Name extends CompatibleTypes<Types, ParentShape, ['Boolean'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['Boolean']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['Boolean'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'Boolean'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"Boolean\"], Nullable>, Kind>;\n    /**\n     * Create a Float list field from a number[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeFloatList<Name extends CompatibleTypes<Types, ParentShape, ['Float'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['Float']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['Float'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'Float'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"Float\"], Nullable>, Kind>;\n    /**\n     * Create an ID list field from an id[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeIDList<Name extends CompatibleTypes<Types, ParentShape, ['ID'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['ID']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['ID'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'ID'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"ID\"], Nullable>, Kind>;\n    /**\n     * Create a Int list field from a number[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeIntList<Name extends CompatibleTypes<Types, ParentShape, ['Int'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['Int']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['Int'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'Int'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"Int\"], Nullable>, Kind>;\n    /**\n     * Create a String list field from a string[] property on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    exposeStringList<Name extends CompatibleTypes<Types, ParentShape, ['String'], {\n        list: true;\n        items: true;\n    }>, ResolveReturnShape, Nullable extends FieldNullability<['String']> = Types['DefaultFieldNullability']>(name: Name, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, ['String'], ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, [\n            'String'\n        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, [\"String\"], Nullable>, Kind>;\n    /**\n     * Create a field that resolves to a property of the corresponding type on the parent object\n     * @param {string} name - the name of the property on the source object (does not need to match the field name).\n     * @param {object} [options={}] - Options for this field\n     */\n    expose<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, ResolveReturnShape, Name extends CompatibleTypes<Types, ParentShape, Type, Type extends [unknown] ? {\n        list: true;\n        items: true;\n    } : true>>(name: Name extends keyof ParentShape ? Name : keyof ParentShape, ...args: NormalizeArgs<[\n        options: ExposeNullability<Types, Type, ParentShape, Name, Nullable> & Omit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'nullable' | InferredFieldOptionKeys>\n    ]>): import(\"../refs/field\").FieldRef<Types, import(\"..\").ShapeFromTypeParam<Types, FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>[\"type\"], (false & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : true | {\n        items: boolean;\n        list: true;\n    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {\n        items: true;\n        list: boolean;\n    } : {\n        items: true;\n        list: true;\n    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true) & Nullable) | (true & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : true | {\n        items: boolean;\n        list: true;\n    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {\n        items: true;\n        list: boolean;\n    } : {\n        items: true;\n        list: true;\n    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true) & Nullable) | ((Type extends [unknown] ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : boolean) & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {\n        items: boolean;\n        list: boolean;\n    } : true | {\n        items: boolean;\n        list: true;\n    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {\n        items: true;\n        list: boolean;\n    } : {\n        items: true;\n        list: true;\n    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true) & Nullable)>, Kind>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/input",
    "content": "declare module '@pothos/core/fieldUtils/input' {\nimport { InputListRef } from '@pothos/core/refs/input-list';\nimport type { ArgBuilder, FieldRequiredness, InputOrArgRef, InputShapeFromTypeParam, InputType, InputTypeParam, NormalizeArgs, SchemaTypes } from '@pothos/core/types';\nexport declare class InputFieldBuilder<Types extends SchemaTypes, Kind extends keyof PothosSchemaTypes.InputFieldOptionsByKind> {\n    kind: Kind;\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    /**\n     * Create a Boolean input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    boolean: <Req extends FieldRequiredness<\"Boolean\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"Boolean\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"Boolean\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"Boolean\" extends infer T ? T extends \"Boolean\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Boolean\" extends infer T_1 ? T_1 extends \"Boolean\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"Boolean\" extends infer T_2 ? T_2 extends \"Boolean\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"Boolean\" extends infer T_3 ? T_3 extends \"Boolean\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a Float input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    float: <Req extends FieldRequiredness<\"Float\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"Float\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"Float\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"Float\" extends infer T ? T extends \"Float\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Float\" extends infer T_1 ? T_1 extends \"Float\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"Float\" extends infer T_2 ? T_2 extends \"Float\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"Float\" extends infer T_3 ? T_3 extends \"Float\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a ID input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    id: <Req extends FieldRequiredness<\"ID\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"ID\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"ID\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"ID\" extends infer T ? T extends \"ID\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"ID\" extends infer T_1 ? T_1 extends \"ID\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"ID\" extends infer T_2 ? T_2 extends \"ID\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"ID\" extends infer T_3 ? T_3 extends \"ID\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a Int input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    int: <Req extends FieldRequiredness<\"Int\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"Int\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"Int\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"Int\" extends infer T ? T extends \"Int\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Int\" extends infer T_1 ? T_1 extends \"Int\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"Int\" extends infer T_2 ? T_2 extends \"Int\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"Int\" extends infer T_3 ? T_3 extends \"Int\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a String input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    string: <Req extends FieldRequiredness<\"String\">>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, \"String\", Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, FieldRequiredness<\"String\"> extends Req ? Types[\"DefaultInputFieldRequiredness\"] extends false ? (\"String\" extends infer T ? T extends \"String\" ? T extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"String\" extends infer T_1 ? T_1 extends \"String\" ? T_1 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Req extends true ? \"String\" extends infer T_2 ? T_2 extends \"String\" ? T_2 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never : (\"String\" extends infer T_3 ? T_3 extends \"String\" ? T_3 extends keyof Types[\"inputShapes\"] ? Types[\"inputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never) | null | undefined, Kind>;\n    /**\n     * Create a Boolean list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    booleanList: <Req extends FieldRequiredness<[\"Boolean\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"Boolean\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"Boolean\"], Req>, Kind>;\n    /**\n     * Create a Float list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    floatList: <Req extends FieldRequiredness<[\"Float\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"Float\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"Float\"], Req>, Kind>;\n    /**\n     * Create a ID list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    idList: <Req extends FieldRequiredness<[\"ID\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"ID\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"ID\"], Req>, Kind>;\n    /**\n     * Create a Int list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    intList: <Req extends FieldRequiredness<[\"Int\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"Int\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"Int\"], Req>, Kind>;\n    /**\n     * Create a String list input field\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    stringList: <Req extends FieldRequiredness<[\"String\"]>>(...args: NormalizeArgs<[options: Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, [\"String\"], Req>[Kind], \"type\">], 0>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\"String\"], Req>, Kind>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: Kind);\n    listRef: <T extends InputTypeParam<Types>, Required extends boolean = true>(type: T, options?: {\n        required?: Required;\n    }) => InputListRef<Types, InputShapeFromTypeParam<Types, T, Required>[]>;\n    argBuilder(): ArgBuilder<Types>;\n    /**\n     * Create in input field or argument for the current type\n     * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field\n     */\n    field<Type extends InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type>>(options: PothosSchemaTypes.InputFieldOptionsByKind<Types, Type, Req>[Kind]): InputOrArgRef<Types, InputShapeFromTypeParam<Types, Type, Req>, Kind>;\n    private helper;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/interface",
    "content": "declare module '@pothos/core/fieldUtils/interface' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { FieldBuilder } from '@pothos/core/fieldUtils/builder';\nexport declare class InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Interface'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/mutation",
    "content": "declare module '@pothos/core/fieldUtils/mutation' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class MutationFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Mutation'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/object",
    "content": "declare module '@pothos/core/fieldUtils/object' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { FieldBuilder } from '@pothos/core/fieldUtils/builder';\nexport declare class ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> extends FieldBuilder<Types, ParentShape, 'Object'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/query",
    "content": "declare module '@pothos/core/fieldUtils/query' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class QueryFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Query'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/root",
    "content": "declare module '@pothos/core/fieldUtils/root' {\nimport { ListRef } from '@pothos/core/refs/list';\nimport type { ArgBuilder, DistributeOmit, FieldKind, FieldNullability, FieldOptionsFromKind, InputFieldMap, NormalizeArgs, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core/types';\nimport { BaseFieldUtil } from '@pothos/core/fieldUtils/base';\nexport declare class RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends BaseFieldUtil<Types, ParentShape, Kind> {\n    arg: ArgBuilder<Types>;\n    /**\n     * Create a Boolean field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    boolean<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<'Boolean'> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'Boolean', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Boolean\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Boolean\" extends infer T ? T extends \"Boolean\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Boolean\" extends infer T_1 ? T_1 extends \"Boolean\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Boolean\" extends infer T_2 ? T_2 extends \"Boolean\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Boolean\" extends infer T_3 ? T_3 extends \"Boolean\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Float field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    float<Nullable extends FieldNullability<'Float'>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'Float', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Float\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Float\" extends infer T ? T extends \"Float\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Float\" extends infer T_1 ? T_1 extends \"Float\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Float\" extends infer T_2 ? T_2 extends \"Float\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Float\" extends infer T_3 ? T_3 extends \"Float\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a ID field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    id<Nullable extends FieldNullability<'ID'>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"ID\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"ID\" extends infer T ? T extends \"ID\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"ID\" extends infer T_1 ? T_1 extends \"ID\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"ID\" extends infer T_2 ? T_2 extends \"ID\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"ID\" extends infer T_3 ? T_3 extends \"ID\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Int field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    int<Nullable extends FieldNullability<'Int'>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'Int', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"Int\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"Int\" extends infer T ? T extends \"Int\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"Int\" extends infer T_1 ? T_1 extends \"Int\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"Int\" extends infer T_2 ? T_2 extends \"Int\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"Int\" extends infer T_3 ? T_3 extends \"Int\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a String field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    string<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<'String'> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, 'String', Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, FieldNullability<\"String\"> extends Nullable ? Types[\"DefaultFieldNullability\"] extends true ? (\"String\" extends infer T ? T extends \"String\" ? T extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T] : T extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T> : never : never : never) | null | undefined : \"String\" extends infer T_1 ? T_1 extends \"String\" ? T_1 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_1] : T_1 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? (\"String\" extends infer T_2 ? T_2 extends \"String\" ? T_2 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_2] : T_2 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_2> : never : never : never) | null | undefined : \"String\" extends infer T_3 ? T_3 extends \"String\" ? T_3 extends keyof Types[\"outputShapes\"] ? Types[\"outputShapes\"][T_3] : T_3 extends import(\"..\").BaseEnum ? import(\"..\").ValuesFromEnum<T_3> : never : never : never, Kind>;\n    /**\n     * Create a Boolean list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    booleanList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['Boolean']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'Boolean'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"Boolean\"], Nullable>, Kind>;\n    /**\n     * Create a Float list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    floatList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['Float']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'Float'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"Float\"], Nullable>, Kind>;\n    /**\n     * Create a ID list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    idList<Nullable extends FieldNullability<['ID']>, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'ID'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"ID\"], Nullable>, Kind>;\n    /**\n     * Create a Int list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    intList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['Int']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'Int'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"Int\"], Nullable>, Kind>;\n    /**\n     * Create a String list field\n     * @param {PothosSchemaTypes.FieldOptions} options - Options for this field\n     */\n    stringList<ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<['String']> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(...args: NormalizeArgs<[\n        options: DistributeOmit<FieldOptionsFromKind<Types, ParentShape, [\n            'String'\n        ], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type'>\n    ]>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, [\"String\"], Nullable>, Kind>;\n    /**\n     * create a new field for the current type\n     * @param {PothosSchemaTypes.FieldOptions} options - options for this field\n     */\n    field<Type extends TypeParam<Types>, ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<Type> = Types['DefaultFieldNullability'], Args extends InputFieldMap = {}>(options: FieldOptionsFromKind<Types, ParentShape, Type, Nullable, Args, Kind, ResolveShape, ResolveReturnShape>): import(\"../refs/field\").FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n    listRef<T extends TypeParam<Types>, Nullable extends boolean = false>(type: T, options?: {\n        nullable?: Nullable;\n    }): ListRef<Types, ShapeFromTypeParam<Types, T, Nullable>[]>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/fieldUtils/subscription",
    "content": "declare module '@pothos/core/fieldUtils/subscription' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { RootFieldBuilder } from '@pothos/core/fieldUtils/root';\nexport declare class SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> extends RootFieldBuilder<Types, ParentShape, 'Subscription'> {\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>);\n}\n}"
  },
  {
    "moduleName": "@pothos/core",
    "content": "declare module '@pothos/core' {\nimport { SchemaBuilder as SchemaBuilderClass } from '@pothos/core/builder';\nimport '@pothos/core/types/global';\nimport type { AddVersionedDefaultsToBuilderOptions, FieldKind, InputTypeParam, NormalizeSchemeBuilderOptions, PothosInputFieldConfig, PothosOutputFieldConfig, PothosTypeConfig, RootName, SchemaTypes, TypeParam } from '@pothos/core/types';\nexport * from '@pothos/core/errors';\nexport * from '@pothos/core/plugins';\nexport * from '@pothos/core/types';\nexport * from '@pothos/core/utils';\ndeclare const SchemaBuilder: {\n    registerPlugin: typeof SchemaBuilderClass.registerPlugin;\n    allowPluginReRegistration: boolean;\n    new <Types extends Partial<PothosSchemaTypes.UserSchemaTypes> = {}>(options: Types extends {\n        Defaults: \"v3\";\n    } ? AddVersionedDefaultsToBuilderOptions<PothosSchemaTypes.ExtendDefaultTypes<Types>, \"v3\"> : NormalizeSchemeBuilderOptions<PothosSchemaTypes.ExtendDefaultTypes<Types>>): PothosSchemaTypes.SchemaBuilder<PothosSchemaTypes.ExtendDefaultTypes<Types>>;\n};\nexport default SchemaBuilder;\nexport declare const FieldBuilder: new <Types extends SchemaTypes, ParentShape, Kind extends Exclude<FieldKind, RootName> = Exclude<FieldKind, RootName>>(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: FieldKind, graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[FieldKind]) => PothosSchemaTypes.FieldBuilder<Types, ParentShape, Kind>;\nexport type RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> = PothosSchemaTypes.RootFieldBuilder<Types, ParentShape, Kind>;\nexport declare const RootFieldBuilder: new <Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind>(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: FieldKind, graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[FieldKind]) => PothosSchemaTypes.RootFieldBuilder<Types, ParentShape, Kind>;\nexport type QueryFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.QueryFieldBuilder<Types, ParentShape>;\nexport declare const QueryFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.QueryFieldBuilder<Types, ParentShape>;\nexport type MutationFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.MutationFieldBuilder<Types, ParentShape>;\nexport declare const MutationFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.MutationFieldBuilder<Types, ParentShape>;\nexport type SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.SubscriptionFieldBuilder<Types, ParentShape>;\nexport declare const SubscriptionFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.SubscriptionFieldBuilder<Types, ParentShape>;\nexport type ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.ObjectFieldBuilder<Types, ParentShape>;\nexport declare const ObjectFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.ObjectFieldBuilder<Types, ParentShape>;\nexport type InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> = PothosSchemaTypes.InterfaceFieldBuilder<Types, ParentShape>;\nexport declare const InterfaceFieldBuilder: new <Types extends SchemaTypes, ParentShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>) => PothosSchemaTypes.InterfaceFieldBuilder<Types, ParentShape>;\nexport type InputFieldBuilder<Types extends SchemaTypes, Kind extends 'Arg' | 'InputObject' = 'Arg' | 'InputObject'> = PothosSchemaTypes.InputFieldBuilder<Types, Kind>;\nexport declare const InputFieldBuilder: new <Types extends SchemaTypes, Kind extends \"Arg\" | \"InputObject\" = \"Arg\" | \"InputObject\">(builder: PothosSchemaTypes.SchemaBuilder<Types>, kind: Kind) => PothosSchemaTypes.InputFieldBuilder<Types, Kind>;\nexport type BaseTypeRef<Types extends SchemaTypes, T> = PothosSchemaTypes.BaseTypeRef<Types, T>;\nexport declare const BaseTypeRef: new <Types extends SchemaTypes, T>(kind: \"Enum\" | \"InputObject\" | \"Interface\" | \"Object\" | \"Scalar\" | \"Union\", name: string) => PothosSchemaTypes.BaseTypeRef<Types, T>;\nexport type EnumRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.EnumRef<Types, T, P>;\nexport declare const EnumRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.EnumRef<Types, T, P>;\nexport type InputObjectRef<Types extends SchemaTypes, T> = PothosSchemaTypes.InputObjectRef<Types, T>;\nexport declare const InputObjectRef: new <Types extends SchemaTypes, T>(name: string) => PothosSchemaTypes.InputObjectRef<Types, T>;\nexport type ImplementableInputObjectRef<Types extends SchemaTypes, T extends object> = PothosSchemaTypes.ImplementableInputObjectRef<Types, T>;\nexport declare const ImplementableInputObjectRef: new <Types extends SchemaTypes, T extends object>(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string) => PothosSchemaTypes.ImplementableInputObjectRef<Types, T>;\nexport type InputListRef<Types extends SchemaTypes, T> = PothosSchemaTypes.InputListRef<Types, T>;\nexport declare const InputListRef: new <Types extends SchemaTypes, T>(listType: InputTypeParam<Types>, required: boolean) => PothosSchemaTypes.InputListRef<Types, T>;\nexport type InterfaceRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.InterfaceRef<Types, T, P>;\nexport declare const InterfaceRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.InterfaceRef<Types, T, P>;\nexport type ImplementableInterfaceRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ImplementableInterfaceRef<Types, T, P>;\nexport declare const ImplementableInterfaceRef: new <Types extends SchemaTypes, T, P = T>(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string) => PothosSchemaTypes.ImplementableInterfaceRef<Types, T, P>;\nexport type ObjectRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ObjectRef<Types, T, P>;\nexport declare const ObjectRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.ObjectRef<Types, T, P>;\nexport type ImplementableObjectRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ImplementableObjectRef<Types, T, P>;\nexport declare const ImplementableObjectRef: new <Types extends SchemaTypes, T, P = T>(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string) => PothosSchemaTypes.ImplementableObjectRef<Types, T, P>;\nexport type ScalarRef<Types extends SchemaTypes, T, U, P = T> = PothosSchemaTypes.ScalarRef<Types, T, U, P>;\nexport declare const ScalarRef: new <Types extends SchemaTypes, T, U, P = T>(name: string) => PothosSchemaTypes.ScalarRef<Types, T, U, P>;\nexport type UnionRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.UnionRef<Types, T, P>;\nexport declare const UnionRef: new <Types extends SchemaTypes, T, P = T>(name: string) => PothosSchemaTypes.UnionRef<Types, T, P>;\nexport type ListRef<Types extends SchemaTypes, T, P = T> = PothosSchemaTypes.ListRef<Types, T, P>;\nexport declare const ListRef: new <Types extends SchemaTypes, T, P = T>(listType: TypeParam<Types>, nullable: boolean) => PothosSchemaTypes.ListRef<Types, T, P>;\nexport type FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> = PothosSchemaTypes.FieldRef<Types, T, Kind>;\nexport declare const FieldRef: new <Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind>(kind: Kind, initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosOutputFieldConfig<Types>) => PothosSchemaTypes.FieldRef<Types, T, Kind>;\nexport type InputFieldRef<Types extends SchemaTypes, T> = PothosSchemaTypes.InputFieldRef<Types, T>;\nexport declare const InputFieldRef: new <Types extends SchemaTypes, T>(initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>) => PothosSchemaTypes.InputFieldRef<Types, T>;\nexport type ArgumentRef<Types extends SchemaTypes, T> = PothosSchemaTypes.ArgumentRef<Types, T>;\nexport declare const ArgumentRef: new <Types extends SchemaTypes, T>(initConfig: (name: string, field: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>) => PothosSchemaTypes.ArgumentRef<Types, T>;\nexport { BuildCache } from '@pothos/core/build-cache';\nexport { BuiltinScalarRef } from '@pothos/core/refs/builtin-scalar';\nexport { InputTypeRef } from '@pothos/core/refs/input';\nexport { MutationRef } from '@pothos/core/refs/mutation';\nexport { OutputTypeRef } from '@pothos/core/refs/output';\nexport { QueryRef } from '@pothos/core/refs/query';\nexport { SubscriptionRef } from '@pothos/core/refs/subscription';\n}"
  },
  {
    "moduleName": "@pothos/core/plugins",
    "content": "declare module '@pothos/core/plugins' {\nexport * from '@pothos/core/plugins/merge-plugins';\nexport * from '@pothos/core/plugins/plugin';\n}"
  },
  {
    "moduleName": "@pothos/core/plugins/merge-plugins",
    "content": "declare module '@pothos/core/plugins/merge-plugins' {\nimport type { GraphQLFieldResolver, GraphQLIsTypeOfFn, GraphQLSchema, GraphQLTypeResolver } from 'graphql';\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { PothosEnumValueConfig, PothosInputFieldConfig, PothosInterfaceTypeConfig, PothosObjectTypeConfig, PothosOutputFieldConfig, PothosTypeConfig, PothosUnionTypeConfig, SchemaTypes } from '@pothos/core/types';\nimport { BasePlugin } from '@pothos/core/plugins/plugin';\nexport declare class MergedPlugins<Types extends SchemaTypes> extends BasePlugin<Types> {\n    plugins: BasePlugin<Types, object>[];\n    constructor(buildCache: BuildCache<Types>, plugins: BasePlugin<Types>[]);\n    onTypeConfig(typeConfig: PothosTypeConfig): PothosTypeConfig;\n    onInputFieldConfig(fieldConfig: PothosInputFieldConfig<Types>): PothosInputFieldConfig<Types> | null;\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n    onEnumValueConfig(valueConfig: PothosEnumValueConfig<Types>): PothosEnumValueConfig<Types> | null;\n    beforeBuild(): void;\n    afterBuild(schema: GraphQLSchema): GraphQLSchema;\n    wrapResolve(resolve: GraphQLFieldResolver<unknown, Types['Context'], object>, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    wrapSubscribe(subscribe: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    wrapArgMappers(resolver: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    wrapResolveType(resolveType: GraphQLTypeResolver<unknown, Types['Context']>, typeConfig: PothosInterfaceTypeConfig | PothosUnionTypeConfig): GraphQLTypeResolver<unknown, Types[\"Context\"]>;\n    wrapIsTypeOf(isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined, typeConfig: PothosObjectTypeConfig): GraphQLIsTypeOfFn<unknown, Types[\"Context\"]> | undefined;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/plugins/plugin",
    "content": "declare module '@pothos/core/plugins/plugin' {\nimport type { GraphQLFieldResolver, GraphQLIsTypeOfFn, GraphQLSchema, GraphQLTypeResolver } from 'graphql';\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { PothosEnumValueConfig, PothosInputFieldConfig, PothosInterfaceTypeConfig, PothosObjectTypeConfig, PothosOutputFieldConfig, PothosTypeConfig, PothosUnionTypeConfig, SchemaTypes } from '@pothos/core/types';\nexport declare class BasePlugin<Types extends SchemaTypes, T extends object = object> {\n    name: never;\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    buildCache: BuildCache<Types>;\n    options: PothosSchemaTypes.BuildSchemaOptions<Types>;\n    private requestDataMap;\n    constructor(buildCache: BuildCache<Types>, name: keyof PothosSchemaTypes.Plugins<Types>);\n    /**\n     * Called for each type defined with the SchemaBuilder\n     * @param  {PothosTypeConfig} typeConfig - Config object describing the added type\n     * @return {PothosTypeConfig} Original or updated `typeConfig`\n     */\n    onTypeConfig(typeConfig: PothosTypeConfig): PothosTypeConfig;\n    /**\n     * Called for each field on an Object or Interface type\n     * @param  {PothosOutputFieldConfig} fieldConfig - Config object describing the added field\n     * @return {PothosOutputFieldConfig} Original or updated `fieldConfig`\n     */\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n    /**\n     * Called for each argument or field on an Input object defined in your schema\n     * @param  {PothosInputFieldConfig} fieldConfig - Config object describing the added field\n     * @return {PothosInputFieldConfig} Original or updated `fieldConfig`\n     */\n    onInputFieldConfig(fieldConfig: PothosInputFieldConfig<Types>): PothosInputFieldConfig<Types> | null;\n    /**\n     * Called for each Enum value defined in your schema\n     * @param  {PothosEnumValueConfig} valueConfig - Config object describing the enum value\n     * @return {PothosEnumValueConfig} Original or updated `valueConfig`\n     */\n    onEnumValueConfig(valueConfig: PothosEnumValueConfig<Types>): PothosEnumValueConfig<Types> | null;\n    /**\n     * Called before builder.toSchema() schema is called\n     */\n    beforeBuild(): void;\n    /**\n     * Called after all fields and types have been built during `builder.toSchema()`\n     * @param  {GraphQLSchema} schema - the generated schema\n     * @return {PothosEnumValueConfig} Original or updated `schema`\n     */\n    afterBuild(schema: GraphQLSchema): GraphQLSchema;\n    /**\n     * Called with the resolver for each field in the schema\n     * @param  {GraphQLFieldResolver} resolve - the resolve function\n     * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function\n     * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field\n     */\n    wrapResolve(resolver: GraphQLFieldResolver<unknown, Types['Context'], object>, _fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    /**\n     * Called with the subscribe for each field on the Subscription type\n     * @param  {GraphQLFieldResolver} subscribe - the subscribe function\n     * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this subscribe function\n     * @return {GraphQLFieldResolver} - Either the original, or a new subscribe function to use for this field\n     */\n    wrapSubscribe(subscribe: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, _fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    /**\n     * Called with resolve or subscribe functions, but wraps outside of argMappers so arg mapping errors can be handled\n     * @param  {GraphQLFieldResolver} resolve - the resolve function\n     * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function\n     * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field\n     */\n    wrapArgMappers(resolver: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, _fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    /**\n     * Called with the resolveType for each Interface or Union type\n     * @param  {GraphQLTypeResolver} resolveType - the resolveType function\n     * @param  {PothosInterfaceTypeConfig | PothosUnionTypeConfig} typeConfig - the config object for the Interface or Union type\n     * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field\n     */\n    wrapResolveType(resolveType: GraphQLTypeResolver<unknown, Types['Context']>, _typeConfig: PothosInterfaceTypeConfig | PothosUnionTypeConfig): GraphQLTypeResolver<unknown, Types['Context']>;\n    /**\n     * Called with the isTypeOf for each Object type\n     * @param  {GraphQLTypeResolver} resolveType - the resolveType function\n     * @param  {PothosObjectTypeConfig} typeConfig - the config object for the Interface or Union type\n     * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field\n     */\n    wrapIsTypeOf(isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined, _typeConfig: PothosObjectTypeConfig): GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined;\n    protected runUnique<R>(key: unknown, cb: () => R): R;\n    /**\n     * Creates a data object unique to the current request for use by this plugin\n     * @param  {Types['Context']} context - the context object for the current request\n     * @return {object} - The data object for the current request\n     */\n    protected createRequestData(_context: Types['Context']): T;\n    /**\n     * Returns a data object for the current request.  requires `createRequestData` to be implemented\n     * @param  {Types['Context']} context - the context object for the current request\n     * @return {object} - The data object for the current request\n     */\n    protected requestData(context: Types['Context']): T;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/arg",
    "content": "declare module '@pothos/core/refs/arg' {\nimport { inputFieldShapeKey, type PothosInputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class ArgumentRef<Types extends SchemaTypes, T = unknown> {\n    kind: \"Arg\";\n    fieldName?: string;\n    $inferInput: T;\n    [inputFieldShapeKey]: T;\n    protected pendingActions: ((config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | void)[];\n    private initConfig;\n    private onUseCallbacks;\n    constructor(initConfig: (name: string, field: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>);\n    onConfig(cb: (config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | void): void;\n    updateConfig(cb: (config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | void): void;\n    getConfig(name: string, field: string, typeConfig: PothosTypeConfig): PothosInputFieldConfig<Types>;\n    onFirstUse(cb: (config: PothosInputFieldConfig<Types>) => void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/base-with-fields",
    "content": "declare module '@pothos/core/refs/base-with-fields' {\nimport type { FieldMap, InterfaceParam, PothosInterfaceTypeConfig, PothosMutationTypeConfig, PothosObjectTypeConfig, PothosQueryTypeConfig, PothosSubscriptionTypeConfig, SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { FieldRef } from '@pothos/core/refs/field';\nexport type ObjectLikeConfig = PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig;\nexport declare class TypeRefWithFields<Types extends SchemaTypes, Config extends ObjectLikeConfig | PothosInterfaceTypeConfig> extends BaseTypeRef<Types, Config> {\n    private fields;\n    private fieldCbs;\n    private interfaces;\n    addFields(fields: () => FieldMap): void;\n    addInterfaces(interfaces: InterfaceParam<Types>[] | (() => InterfaceParam<Types>[])): void;\n    onField(cb: (name: string, ref: FieldRef<Types>) => void): void;\n    prepareForBuild(): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/base",
    "content": "declare module '@pothos/core/refs/base' {\nimport type { SchemaTypes } from '@pothos/core/types';\nexport declare class BaseTypeRef<Types extends SchemaTypes, T = unknown> implements PothosSchemaTypes.BaseTypeRef<Types, T> {\n    kind: \"InputObject\" | \"Enum\" | \"Scalar\" | \"List\" | \"Object\" | \"Interface\" | \"Union\" | \"InputList\";\n    name: string;\n    association: BaseTypeRef<Types, T> | string | null;\n    protected configCallbacks: Set<(config: T) => void>;\n    protected preparedForBuild: boolean;\n    private currentConfig;\n    constructor(kind: 'Enum' | 'InputList' | 'InputObject' | 'Interface' | 'List' | 'Object' | 'Scalar' | 'Union', name: string, config?: T | null);\n    toString(): string;\n    associate(ref: BaseTypeRef<Types, T> | string): void;\n    onConfig(cb: (config: T) => T | void): void;\n    updateConfig(config: T | ((oldConfig: T) => T)): void;\n    prepareForBuild(): void;\n    protected onceOnConfig(cb: (config: T) => T | void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/builtin-scalar",
    "content": "declare module '@pothos/core/refs/builtin-scalar' {\nimport type { GraphQLScalarType } from 'graphql';\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ScalarRef } from '@pothos/core/refs/scalar';\nexport declare class BuiltinScalarRef<Types extends SchemaTypes, T, U> extends ScalarRef<Types, T, U> {\n    type: GraphQLScalarType<unknown, unknown>;\n    constructor(type: GraphQLScalarType);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/enum",
    "content": "declare module '@pothos/core/refs/enum' {\nimport { type InputRef, inputShapeKey, type OutputRef, outputShapeKey, type PothosEnumTypeConfig, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class EnumRef<Types extends SchemaTypes, T, U = T> extends BaseTypeRef<Types, PothosEnumTypeConfig> implements OutputRef<T>, InputRef<U>, PothosSchemaTypes.EnumRef<Types, T, U> {\n    kind: \"Enum\";\n    $inferType: T;\n    $inferInput: U;\n    [outputShapeKey]: T;\n    [inputShapeKey]: U;\n    constructor(name: string, config?: PothosEnumTypeConfig);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/field",
    "content": "declare module '@pothos/core/refs/field' {\nimport { type FieldKind, outputFieldShapeKey, type PothosOutputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> implements PothosSchemaTypes.FieldRef<Types, T, Kind> {\n    kind: FieldKind;\n    fieldName?: string;\n    $inferType: T;\n    [outputFieldShapeKey]: T;\n    protected pendingActions: ((config: PothosOutputFieldConfig<Types>) => PothosOutputFieldConfig<Types> | undefined)[];\n    private initConfig;\n    private onUseCallbacks;\n    constructor(kind: Kind, initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosOutputFieldConfig<Types>);\n    updateConfig(cb: (config: PothosOutputFieldConfig<Types>) => PothosOutputFieldConfig<Types> | undefined): void;\n    getConfig(name: string, typeConfig: PothosTypeConfig): PothosOutputFieldConfig<Types>;\n    onFirstUse(cb: (config: PothosOutputFieldConfig<Types>) => void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input-field",
    "content": "declare module '@pothos/core/refs/input-field' {\nimport { inputFieldShapeKey, type PothosInputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core/types';\nexport declare class InputFieldRef<Types extends SchemaTypes, T = unknown> implements PothosSchemaTypes.InputFieldRef<Types, T> {\n    kind: \"InputObject\";\n    fieldName?: string;\n    $inferInput: T;\n    [inputFieldShapeKey]: T;\n    protected pendingActions: ((config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | undefined)[];\n    private initConfig;\n    private onUseCallbacks;\n    constructor(initConfig: (name: string, typeConfig: PothosTypeConfig) => PothosInputFieldConfig<Types>);\n    updateConfig(cb: (config: PothosInputFieldConfig<Types>) => PothosInputFieldConfig<Types> | undefined): void;\n    getConfig(name: string, typeConfig: PothosTypeConfig): PothosInputFieldConfig<Types>;\n    onFirstUse(cb: (config: PothosInputFieldConfig<Types>) => void): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input-list",
    "content": "declare module '@pothos/core/refs/input-list' {\nimport { type InputTypeParam, inputShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class InputListRef<Types extends SchemaTypes, T> extends BaseTypeRef<Types> implements PothosSchemaTypes.InputListRef<Types, T> {\n    kind: \"InputList\";\n    [inputShapeKey]: T;\n    $inferInput: T;\n    listType: InputTypeParam<Types>;\n    required: boolean;\n    constructor(listType: InputTypeParam<Types>, required: boolean);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input-object",
    "content": "declare module '@pothos/core/refs/input-object' {\nimport { type InputFieldMap, type InputFieldsFromShape, type InputRef, inputShapeKey, type PothosInputObjectTypeConfig, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { InputFieldRef } from '@pothos/core/refs/input-field';\nexport declare class InputObjectRef<Types extends SchemaTypes, T> extends BaseTypeRef<Types, PothosInputObjectTypeConfig> implements InputRef<T>, PothosSchemaTypes.InputObjectRef<Types, T> {\n    kind: \"InputObject\";\n    $inferInput: T;\n    [inputShapeKey]: T;\n    private fields;\n    private fieldCbs;\n    constructor(name: string);\n    addFields(fields: () => InputFieldMap): void;\n    onField(cb: (name: string, ref: InputFieldRef<Types>) => void): void;\n}\nexport declare class ImplementableInputObjectRef<Types extends SchemaTypes, T extends object, Resolved = T> extends InputObjectRef<Types, Resolved> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string);\n    implement(options: PothosSchemaTypes.InputObjectTypeOptions<Types, InputFieldsFromShape<Types, T, 'InputObject'>>): InputObjectRef<Types, Resolved>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/input",
    "content": "declare module '@pothos/core/refs/input' {\nimport { inputShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class InputTypeRef<Types extends SchemaTypes, T> extends BaseTypeRef<Types> {\n    kind: \"InputObject\" | \"Enum\" | \"Scalar\";\n    $inferInput: T;\n    [inputShapeKey]: T;\n    constructor(kind: 'Enum' | 'InputObject' | 'Scalar', name: string);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/interface",
    "content": "declare module '@pothos/core/refs/interface' {\nimport { type InterfaceParam, type InterfaceTypeOptions, type OutputRef, outputShapeKey, type PothosInterfaceTypeConfig, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { TypeRefWithFields } from '@pothos/core/refs/base-with-fields';\nexport declare class InterfaceRef<Types extends SchemaTypes, T, P = T> extends TypeRefWithFields<Types, PothosInterfaceTypeConfig> implements OutputRef<T>, PothosSchemaTypes.InterfaceRef<Types, T, P> {\n    kind: \"Interface\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    constructor(name: string, config?: PothosInterfaceTypeConfig);\n}\nexport declare class ImplementableInterfaceRef<Types extends SchemaTypes, Shape, Parent = Shape> extends InterfaceRef<Types, Shape, Parent> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string);\n    implement<const Interfaces extends InterfaceParam<Types>[]>(options: InterfaceTypeOptions<Types, ImplementableInterfaceRef<Types, Shape, Parent>, Parent, Interfaces>): PothosSchemaTypes.InterfaceRef<Types, Shape, Parent>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/list",
    "content": "declare module '@pothos/core/refs/list' {\nimport { outputShapeKey, parentShapeKey, type SchemaTypes, type TypeParam } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class ListRef<Types extends SchemaTypes, T, P = T> extends BaseTypeRef<Types> implements PothosSchemaTypes.ListRef<Types, T, P> {\n    kind: \"List\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    listType: TypeParam<Types>;\n    nullable: boolean;\n    constructor(listType: TypeParam<Types>, nullable: boolean);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/mutation",
    "content": "declare module '@pothos/core/refs/mutation' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ObjectRef } from '@pothos/core/refs/object';\nexport declare class MutationRef<Types extends SchemaTypes> extends ObjectRef<Types, Types['Root']> {\n    kind: \"Object\";\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/object",
    "content": "declare module '@pothos/core/refs/object' {\nimport { type InterfaceParam, type ObjectTypeOptions, type OutputRef, outputShapeKey, type PothosMutationTypeConfig, type PothosObjectTypeConfig, type PothosQueryTypeConfig, type PothosSubscriptionTypeConfig, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { TypeRefWithFields } from '@pothos/core/refs/base-with-fields';\nexport type ObjectLikeConfig = PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig;\nexport declare class ObjectRef<Types extends SchemaTypes, T, P = T> extends TypeRefWithFields<Types, ObjectLikeConfig> implements OutputRef<T>, PothosSchemaTypes.ObjectRef<Types, T, P> {\n    kind: \"Object\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    constructor(name: string, config?: ObjectLikeConfig);\n}\nexport declare class ImplementableObjectRef<Types extends SchemaTypes, Shape, Parent = Shape> extends ObjectRef<Types, Shape, Parent> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string);\n    implement<const Interfaces extends InterfaceParam<Types>[]>(options: Omit<ObjectTypeOptions<Types, ImplementableObjectRef<Types, Shape, Parent>, Parent, Interfaces>, 'name'>): PothosSchemaTypes.ObjectRef<Types, Shape, Parent>;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/output",
    "content": "declare module '@pothos/core/refs/output' {\nimport { outputShapeKey, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class OutputTypeRef<Types extends SchemaTypes, T, P = T> extends BaseTypeRef<Types> {\n    kind: \"Enum\" | \"Scalar\" | \"Object\" | \"Interface\" | \"Union\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    constructor(kind: 'Enum' | 'Interface' | 'Object' | 'Scalar' | 'Union', name: string);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/query",
    "content": "declare module '@pothos/core/refs/query' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ObjectRef } from '@pothos/core/refs/object';\nexport declare class QueryRef<Types extends SchemaTypes> extends ObjectRef<Types, Types['Root']> {\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/scalar",
    "content": "declare module '@pothos/core/refs/scalar' {\nimport { type InputRef, inputShapeKey, type OutputRef, outputShapeKey, type PothosScalarTypeConfig, parentShapeKey, type SchemaTypes } from '@pothos/core/types';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class ScalarRef<Types extends SchemaTypes, T, U, P = T> extends BaseTypeRef<Types, PothosScalarTypeConfig> implements OutputRef<T>, InputRef<U>, PothosSchemaTypes.ScalarRef<Types, T, U, P> {\n    kind: \"Scalar\";\n    $inferType: T;\n    $inferInput: U;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    [inputShapeKey]: U;\n    constructor(name: string, config?: PothosScalarTypeConfig);\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/subscription",
    "content": "declare module '@pothos/core/refs/subscription' {\nimport type { SchemaTypes } from '@pothos/core/types';\nimport { ObjectRef } from '@pothos/core/refs/object';\nexport declare class SubscriptionRef<Types extends SchemaTypes> extends ObjectRef<Types, Types['Root']> {\n}\n}"
  },
  {
    "moduleName": "@pothos/core/refs/union",
    "content": "declare module '@pothos/core/refs/union' {\nimport type { PothosUnionTypeConfig, SchemaTypes } from '@pothos/core/types';\nimport { type ObjectParam, type OutputRef, outputShapeKey, parentShapeKey } from '@pothos/core/types/type-params';\nimport { BaseTypeRef } from '@pothos/core/refs/base';\nexport declare class UnionRef<Types extends SchemaTypes, T, P = T> extends BaseTypeRef<Types, PothosUnionTypeConfig> implements OutputRef<T>, PothosSchemaTypes.UnionRef<Types, T, P> {\n    kind: \"Union\";\n    $inferType: T;\n    [outputShapeKey]: T;\n    [parentShapeKey]: P;\n    private types;\n    constructor(name: string, config?: PothosUnionTypeConfig);\n    addTypes(types: ObjectParam<Types>[] | (() => ObjectParam<Types>[])): void;\n    prepareForBuild(): void;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/types/builder-options",
    "content": "declare module '@pothos/core/types/builder-options' {\nimport type { GraphQLResolveInfo } from 'graphql';\nimport type { ArgumentRef } from '@pothos/core/refs/arg';\nimport type { InputFieldRef } from '@pothos/core/refs/input-field';\nimport type { InterfaceRef } from '@pothos/core/refs/interface';\nimport type { ObjectRef } from '@pothos/core/refs/object';\nimport type { SchemaTypes, VersionedSchemaBuilderOptions } from '@pothos/core/types/schema-types';\nimport type { BaseEnum, EnumParam, FieldNullability, GenericFieldRef, GenericInputFieldRef, ParentShape as GetParentShape, InputRef, InterfaceParam, inputFieldShapeKey, ObjectParam, ShapeFromTypeParam, TypeParam } from '@pothos/core/types/type-params';\nimport type { MaybePromise, Merge, Normalize, NormalizeNullableFields, RemoveNeverKeys, Simplify } from '@pothos/core/types/utils';\nexport type AddVersionedDefaultsToBuilderOptions<Types extends SchemaTypes, Version extends keyof VersionedSchemaBuilderOptions<SchemaTypes>> = PothosSchemaTypes.SchemaBuilderOptions<Types> extends infer Options ? VersionedSchemaBuilderOptions<Types>[Version] extends infer Defaults ? RemoveNeverKeys<Defaults & Omit<Options, keyof Defaults>> : never : never;\nexport type NormalizeSchemeBuilderOptions<Types extends SchemaTypes> = RemoveNeverKeys<PothosSchemaTypes.SchemaBuilderOptions<Types>>;\nexport type Resolver<Parent, Args, Context, Type, Return = unknown> = (parent: Parent, args: Args, context: Context, info: GraphQLResolveInfo) => [Type] extends [readonly (infer Item)[] | null | undefined] ? ListResolveValue<Type, Item, Return> : MaybePromise<Type>;\nexport type ListResolveValue<Type, Item, Return> = unknown extends AsyncIterable<unknown> ? Return extends readonly unknown[] ? ArrayResolverResult<Type, Item, Return> : IterableResolverResult<Type, Item> & Return : Return extends AsyncIterable<unknown> ? AsyncIterableResolverResult<Type, Item> & Return : Return extends readonly unknown[] ? ArrayResolverResult<Type, Item, Return> : Return extends Iterable<unknown> ? IterableResolverResult<Type, Item> & Return : (IterableResolverResult<Type, Item> | AsyncIterableResolverResult<Type, Item>) & Return;\ntype ArrayResolverResult<Type, Item, Return> = null extends Type ? Return extends MaybePromise<readonly MaybePromise<Item>[] | null | undefined> ? Return : MaybePromise<readonly MaybePromise<Item>[]> | null | undefined : Return extends MaybePromise<readonly MaybePromise<Item>[]> ? Return : MaybePromise<readonly MaybePromise<Item>[]>;\ntype AsyncIterableResolverResult<Type, Item> = null extends Type ? MaybePromise<AsyncIterable<Item> | null | undefined> : MaybePromise<AsyncIterable<Item>>;\ntype IterableResolverResult<Type, Item> = null extends Type ? MaybePromise<Iterable<MaybePromise<Item>> | null | undefined> : MaybePromise<Iterable<MaybePromise<Item>>>;\nexport type Subscriber<Parent, Args, Context, Shape> = (parent: Parent, args: Args, context: Context, info: GraphQLResolveInfo) => MaybePromise<AsyncIterable<Shape>>;\nexport type EnumValues<Types extends SchemaTypes> = EnumValueConfigMap<Types> | readonly string[];\nexport type EnumValueConfigMap<Types extends SchemaTypes> = Record<string, PothosSchemaTypes.EnumValueConfig<Types>>;\nexport type ShapeFromEnumValues<Types extends SchemaTypes, Values extends EnumValues<Types>> = Values extends readonly string[] ? Values[number] : Values extends EnumValueConfigMap<Types> ? {\n    [K in keyof Values]: Values[K]['value'] extends number | string ? Values[K]['value'] : K;\n}[keyof Values] : never;\nexport type ObjectFieldsShape<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.ObjectFieldBuilder<Types, Shape>) => FieldMap;\nexport type InterfaceFieldsShape<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.InterfaceFieldBuilder<Types, Shape>) => FieldMap;\nexport type QueryFieldsShape<Types extends SchemaTypes> = (t: PothosSchemaTypes.QueryFieldBuilder<Types, Types['Root']>) => FieldMap;\nexport type MutationFieldsShape<Types extends SchemaTypes> = (t: PothosSchemaTypes.MutationFieldBuilder<Types, Types['Root']>) => FieldMap;\nexport type SubscriptionFieldsShape<Types extends SchemaTypes> = (t: PothosSchemaTypes.SubscriptionFieldBuilder<Types, Types['Root']>) => FieldMap;\nexport type ObjectFieldThunk<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.ObjectFieldBuilder<Types, Shape>) => GenericFieldRef<unknown>;\nexport type InterfaceFieldThunk<Types extends SchemaTypes, Shape> = (t: PothosSchemaTypes.InterfaceFieldBuilder<Types, Shape>) => GenericFieldRef<unknown>;\nexport type QueryFieldThunk<Types extends SchemaTypes> = (t: PothosSchemaTypes.QueryFieldBuilder<Types, Types['Root']>) => GenericFieldRef<unknown>;\nexport type MutationFieldThunk<Types extends SchemaTypes> = (t: PothosSchemaTypes.MutationFieldBuilder<Types, Types['Root']>) => GenericFieldRef<unknown>;\nexport type SubscriptionFieldThunk<Types extends SchemaTypes> = (t: PothosSchemaTypes.SubscriptionFieldBuilder<Types, Types['Root']>) => GenericFieldRef<unknown>;\nexport type FieldMap = Record<string, GenericFieldRef<unknown>>;\nexport type InputFieldMap = Record<string, GenericInputFieldRef<unknown>>;\nexport type FieldOptionsFromKind<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, Kind extends FieldKind, ResolveShape, ResolveReturnShape> = PothosSchemaTypes.FieldOptionsByKind<Types, ParentShape, Type, Nullable, Args, ResolveShape, ResolveReturnShape>[Kind];\nexport type ObjectTypeOptions<Types extends SchemaTypes, Param extends ObjectParam<Types>, Shape, Interfaces extends InterfaceParam<Types>[]> = Normalize<(Param extends string ? {} : Param extends ObjectRef<Types, unknown> ? {\n    name?: string;\n} : {\n    name: string;\n}) & (PothosSchemaTypes.ObjectTypeOptions<Types, Shape> | PothosSchemaTypes.ObjectTypeWithInterfaceOptions<Types, Shape, Interfaces>)>;\nexport type InterfaceTypeOptions<Types extends SchemaTypes, Param extends InterfaceParam<Types>, Shape, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[], ResolveType = unknown> = PothosSchemaTypes.InterfaceTypeOptions<Types, Shape, Interfaces, ResolveType> & (Param extends string ? {} : Param extends InterfaceRef<Types, unknown> ? {\n    name?: string;\n} : {\n    name: string;\n});\nexport type EnumTypeOptions<Types extends SchemaTypes, Param extends EnumParam, Values extends EnumValues<Types>> = Param extends BaseEnum ? Merge<Omit<PothosSchemaTypes.EnumTypeOptions<Types, Values>, 'values'> & {\n    name: string;\n    values?: Partial<Record<keyof Param, Omit<PothosSchemaTypes.EnumValueConfig<Types>, 'value'>>>;\n}> : PothosSchemaTypes.EnumTypeOptions<Types, Values>;\nexport type ArgBuilder<Types extends SchemaTypes> = Omit<PothosSchemaTypes.InputFieldBuilder<Types, 'Arg'>, 'field'> & PothosSchemaTypes.InputFieldBuilder<Types, 'Arg'>['field'];\nexport type ValidateInterfaces<Shape, Types extends SchemaTypes, Interfaces extends InterfaceParam<Types>> = Interfaces extends InterfaceParam<Types> ? Shape extends GetParentShape<Types, Interfaces> ? Interfaces : 'Object shape must extend interface shape' : never;\nexport type OneOfInputShapeFromFields<Fields extends InputFieldMap> = keyof Fields extends infer K extends keyof Fields ? K extends unknown ? Simplify<{\n    [Name in K]: NonNullable<InputShapeFromField<Fields[K]>>;\n} & {\n    [Name in keyof Fields as Name extends K ? never : Name]?: never;\n}> : never : never;\nexport type InputShapeFromFields<Fields extends InputFieldMap> = NormalizeNullableFields<{\n    [K in string & keyof Fields]: InputShapeFromField<Fields[K]>;\n}>;\nexport type InputFieldsFromShape<Types extends SchemaTypes, Shape, Kind extends 'Arg' | 'InputObject'> = {\n    [K in keyof Shape]: Kind extends 'Arg' ? ArgumentRef<Types, Shape[K]> : Kind extends 'InputObject' ? InputFieldRef<Types, Shape[K]> : never;\n};\nexport type InputShapeFromField<Field extends GenericInputFieldRef> = Field extends {\n    [inputFieldShapeKey]: infer T;\n} ? T : never;\nexport type FieldKind = keyof PothosSchemaTypes.FieldOptionsByKind<SchemaTypes, {}, TypeParam<SchemaTypes>, boolean, {}, {}, {}> & keyof PothosSchemaTypes.PothosKindToGraphQLType;\nexport type InputFieldKind = keyof PothosSchemaTypes.InputFieldOptionsByKind<SchemaTypes, InputRef<unknown>, boolean>;\nexport type CompatibleTypes<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>> = {\n    [K in keyof ParentShape]-?: Awaited<ParentShape[K]> extends ShapeFromTypeParam<Types, Type, Nullable> ? K : never;\n}[keyof ParentShape] & string;\nexport type ExposeNullability<Types extends SchemaTypes, Type extends TypeParam<Types>, ParentShape, Name extends keyof ParentShape, Nullable extends FieldNullability<Type>> = Awaited<ParentShape[Name]> extends ShapeFromTypeParam<Types, Type, Nullable> ? {\n    nullable?: ExposeNullableOption<Types, Type, ParentShape, Name> & Nullable;\n} : {\n    nullable: ExposeNullableOption<Types, Type, ParentShape, Name> & Nullable;\n};\nexport type ExposeNullableOption<Types extends SchemaTypes, Type extends TypeParam<Types>, ParentShape, Name extends keyof ParentShape> = FieldNullability<Type> & (Type extends [unknown] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [T] extends [NonNullable<T>] ? Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean | {\n    items: boolean;\n    list: boolean;\n} : true | {\n    items: boolean;\n    list: true;\n} : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? {\n    items: true;\n    list: boolean;\n} : {\n    items: true;\n    list: true;\n} : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true);\nexport type InferredFieldOptionsKind<Types extends SchemaTypes = SchemaTypes> = keyof PothosSchemaTypes.InferredFieldOptions<Types>;\nexport type InferredFieldOptionsByKind<Types extends SchemaTypes, Kind extends InferredFieldOptionsKind, ResolveShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveReturnShape = unknown> = PothosSchemaTypes.InferredFieldOptions<Types, ResolveShape, Type, Nullable, Args, ResolveReturnShape>[Kind];\nexport type InferredFieldOptionKeys<Kind extends InferredFieldOptionsKind = InferredFieldOptionsKind> = PothosSchemaTypes.InferredFieldOptions<SchemaTypes>[Kind] extends infer Options ? Options extends unknown ? keyof Options : never : never;\nexport {};\n}"
  },
  {
    "moduleName": "@pothos/core/types/configs",
    "content": "declare module '@pothos/core/types/configs' {\nimport type { GraphQLEnumType, GraphQLEnumTypeConfig, GraphQLEnumValueConfig, GraphQLFieldConfig, GraphQLInputFieldConfig, GraphQLInputObjectType, GraphQLInputObjectTypeConfig, GraphQLInterfaceType, GraphQLInterfaceTypeConfig, GraphQLObjectType, GraphQLObjectTypeConfig, GraphQLScalarType, GraphQLScalarTypeConfig, GraphQLUnionType, GraphQLUnionTypeConfig } from 'graphql';\nimport type { FieldKind, FieldOptionsFromKind, InputFieldMap } from '@pothos/core/types/builder-options';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nimport type { FieldNullability, FieldRequiredness, InputType, InputTypeParam, InterfaceParam, ObjectParam, OutputType, TypeParam } from '@pothos/core/types/type-params';\nimport type { MaybePromise, Merge, MergeUnion, PartialResolveInfo } from '@pothos/core/types/utils';\nexport interface PothosQueryTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Query';\n    graphqlKind: 'Object';\n    pothosOptions: PothosSchemaTypes.QueryTypeOptions;\n}\nexport interface PothosMutationTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Mutation';\n    graphqlKind: 'Object';\n    pothosOptions: PothosSchemaTypes.MutationTypeOptions;\n}\nexport interface PothosSubscriptionTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Subscription';\n    graphqlKind: 'Object';\n    pothosOptions: PothosSchemaTypes.SubscriptionTypeOptions;\n}\nexport interface PothosObjectTypeConfig extends Omit<GraphQLObjectTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Object';\n    graphqlKind: 'Object';\n    interfaces: InterfaceParam<SchemaTypes>[];\n    pothosOptions: PothosSchemaTypes.ObjectTypeOptions;\n}\nexport interface PothosInterfaceTypeConfig extends Omit<GraphQLInterfaceTypeConfig<unknown, object>, 'fields' | 'interfaces'> {\n    kind: 'Interface';\n    graphqlKind: 'Interface';\n    interfaces: InterfaceParam<SchemaTypes>[];\n    pothosOptions: PothosSchemaTypes.InterfaceTypeOptions;\n}\nexport interface PothosUnionTypeConfig extends Omit<GraphQLUnionTypeConfig<unknown, object>, 'types'> {\n    kind: 'Union';\n    graphqlKind: 'Union';\n    types: ObjectParam<SchemaTypes>[];\n    pothosOptions: PothosSchemaTypes.UnionTypeOptions;\n}\nexport interface PothosEnumTypeConfig extends GraphQLEnumTypeConfig {\n    kind: 'Enum';\n    graphqlKind: 'Enum';\n    pothosOptions: PothosSchemaTypes.EnumTypeOptions;\n}\nexport interface PothosScalarTypeConfig extends GraphQLScalarTypeConfig<unknown, unknown> {\n    kind: 'Scalar';\n    graphqlKind: 'Scalar';\n    pothosOptions: PothosSchemaTypes.ScalarTypeOptions;\n}\nexport interface PothosInputObjectTypeConfig extends Omit<GraphQLInputObjectTypeConfig, 'fields'> {\n    kind: 'InputObject';\n    graphqlKind: 'InputObject';\n    pothosOptions: PothosSchemaTypes.InputObjectTypeOptions;\n}\nexport type PothosTypeConfig = PothosEnumTypeConfig | PothosInputObjectTypeConfig | PothosInterfaceTypeConfig | PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosScalarTypeConfig | PothosSubscriptionTypeConfig | PothosUnionTypeConfig;\nexport type PothosTypeKind = PothosTypeConfig['kind'];\nexport type PothosKindToGraphQLTypeClass<T extends PothosTypeKind> = {\n    Object: GraphQLObjectType;\n    Interface: GraphQLInterfaceType;\n    Union: GraphQLUnionType;\n    Enum: GraphQLEnumType;\n    Scalar: GraphQLScalarType;\n    InputObject: GraphQLInputObjectType;\n}[PothosSchemaTypes.PothosKindToGraphQLType[T]];\nexport type PothosFieldKindToConfig<Types extends SchemaTypes, Kind extends FieldKind> = {\n    [K in FieldKind]: Merge<Omit<GraphQLFieldConfig<unknown, object>, 'args' | 'type'> & {\n        kind: K;\n        graphqlKind: PothosSchemaTypes.PothosKindToGraphQLType[K];\n        parentType: string;\n        name: string;\n        type: PothosOutputFieldType<Types>;\n        args: Record<string, PothosInputFieldConfig<Types>>;\n        argMappers: ((args: Record<string, unknown>, context: Types['Context'], info: PartialResolveInfo) => MaybePromise<Record<string, unknown>>)[];\n        pothosOptions: FieldOptionsFromKind<Types, unknown, TypeParam<Types>, FieldNullability<[unknown]>, InputFieldMap, K, unknown, unknown> & MergeUnion<{\n            [K in keyof PothosSchemaTypes.InferredFieldOptions<SchemaTypes>]: PothosSchemaTypes.InferredFieldOptions<SchemaTypes>[K];\n        }[keyof PothosSchemaTypes.InferredFieldOptions<SchemaTypes>]>;\n    }>;\n}[Kind];\nexport interface PothosInputFieldConfig<Types extends SchemaTypes> extends Omit<GraphQLInputFieldConfig, 'type'> {\n    kind: 'Arg' | 'InputObject';\n    graphqlKind: 'Arg' | 'InputObject';\n    name: string;\n    parentField: string | undefined;\n    parentType: string;\n    type: PothosInputFieldType<Types>;\n    pothosOptions: PothosSchemaTypes.InputFieldOptionsByKind<Types, InputTypeParam<Types>, FieldRequiredness<[unknown]>>[keyof PothosSchemaTypes.InputFieldOptionsByKind];\n}\nexport interface PothosEnumValueConfig<Types extends SchemaTypes> extends GraphQLEnumValueConfig {\n    pothosOptions: PothosSchemaTypes.EnumValueConfig<Types>;\n}\nexport type PothosOutputFieldConfig<Types extends SchemaTypes> = PothosFieldKindToConfig<Types, FieldKind>;\nexport type PothosFieldConfig<Types extends SchemaTypes> = PothosInputFieldConfig<Types> | PothosOutputFieldConfig<Types>;\nexport type GraphQLFieldKind = PothosFieldConfig<SchemaTypes>['graphqlKind'];\nexport type PothosOutputFieldType<Types extends SchemaTypes> = {\n    kind: 'Enum' | 'Interface' | 'Object' | 'Scalar' | 'Union';\n    ref: OutputType<Types>;\n    nullable: boolean;\n} | {\n    kind: 'List';\n    type: PothosOutputFieldType<Types>;\n    nullable: boolean;\n};\nexport type PothosNameOutputFieldType<Types extends SchemaTypes> = Exclude<PothosOutputFieldType<Types>, {\n    kind: 'List';\n}>;\nexport type PothosInputFieldType<Types extends SchemaTypes> = {\n    kind: 'Enum' | 'InputObject' | 'Scalar';\n    ref: InputType<Types>;\n    required: boolean;\n} | {\n    kind: 'List';\n    type: PothosInputFieldType<Types>;\n    required: boolean;\n};\nexport type PothosNameInputFieldType<Types extends SchemaTypes> = Exclude<PothosInputFieldType<Types>, {\n    kind: 'List';\n}>;\n}"
  },
  {
    "moduleName": "@pothos/core/types/global",
    "content": "declare module '@pothos/core/types/global' {\nimport '@pothos/core/types/global/type-options';\nimport '@pothos/core/types/global/field-options';\nimport '@pothos/core/types/global/classes';\nimport '@pothos/core/types/global/schema-types';\n}"
  },
  {
    "moduleName": "@pothos/core/types",
    "content": "declare module '@pothos/core/types' {\nimport '@pothos/core/types/global';\nexport * from '@pothos/core/types/builder-options';\nexport * from '@pothos/core/types/configs';\nexport * from '@pothos/core/types/plugins';\nexport * from '@pothos/core/types/schema-types';\nexport * from '@pothos/core/types/type-params';\nexport * from '@pothos/core/types/utils';\n}"
  },
  {
    "moduleName": "@pothos/core/types/plugins",
    "content": "declare module '@pothos/core/types/plugins' {\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { BasePlugin } from '@pothos/core/plugins/plugin';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nexport type PluginConstructorMap<Types extends SchemaTypes> = {\n    [K in keyof PothosSchemaTypes.Plugins<SchemaTypes>]: new (buildCache: BuildCache<SchemaTypes>, name: K) => BasePlugin<Types> & PothosSchemaTypes.Plugins<Types>[K];\n};\nexport type PluginMap<Types extends SchemaTypes> = {\n    [K in keyof PluginConstructorMap<Types>]: InstanceType<PluginConstructorMap<Types>[K]>;\n};\nexport type PluginName = keyof PluginConstructorMap<SchemaTypes>;\n}"
  },
  {
    "moduleName": "@pothos/core/types/schema-types",
    "content": "declare module '@pothos/core/types/schema-types' {\nimport type { InferredFieldOptionsKind } from '@pothos/core/types/builder-options';\nexport interface SchemaTypes extends PothosSchemaTypes.UserSchemaTypes {\n    outputShapes: {\n        String: unknown;\n        ID: unknown;\n        Int: unknown;\n        Float: unknown;\n        Boolean: unknown;\n    };\n    inputShapes: {\n        String: unknown;\n        ID: unknown;\n        Int: unknown;\n        Float: unknown;\n        Boolean: unknown;\n    };\n    Objects: {};\n    Inputs: {};\n    Interfaces: {};\n    Scalars: {\n        String: {\n            Input: unknown;\n            Output: unknown;\n        };\n        ID: {\n            Input: unknown;\n            Output: unknown;\n        };\n        Int: {\n            Input: unknown;\n            Output: unknown;\n        };\n        Float: {\n            Input: unknown;\n            Output: unknown;\n        };\n        Boolean: {\n            Input: unknown;\n            Output: unknown;\n        };\n    };\n    DefaultFieldNullability: boolean;\n    DefaultInputFieldRequiredness: boolean;\n    InferredFieldOptionsKind: InferredFieldOptionsKind;\n    Root: object;\n    Context: object;\n}\nexport type MergedScalars<PartialTypes extends Partial<PothosSchemaTypes.UserSchemaTypes>> = (PartialTypes['Defaults'] extends 'v3' ? V3DefaultScalars : DefaultScalars) extends infer Defaults ? SchemaTypes['Scalars'] & {\n    [K in keyof Defaults | keyof PartialTypes['Scalars']]: K extends keyof PartialTypes['Scalars'] ? PartialTypes['Scalars'][K] : K extends keyof Defaults ? Defaults[K] : never;\n} : never;\nexport interface VersionedSchemaBuilderOptions<Types extends SchemaTypes> {\n    v3: PothosSchemaTypes.V3SchemaBuilderOptions<Types>;\n}\nexport interface DefaultsByVersion {\n    v3: PothosSchemaTypes.V3DefaultSchemaTypes;\n}\nexport interface DefaultScalars {\n    String: {\n        Input: string;\n        Output: string;\n    };\n    ID: {\n        Input: string;\n        Output: bigint | number | string;\n    };\n    Int: {\n        Input: number;\n        Output: number;\n    };\n    Float: {\n        Input: number;\n        Output: number;\n    };\n    Boolean: {\n        Input: boolean;\n        Output: boolean;\n    };\n}\nexport interface V3DefaultScalars {\n    String: {\n        Input: string;\n        Output: string;\n    };\n    ID: {\n        Input: number | string;\n        Output: number | string;\n    };\n    Int: {\n        Input: number;\n        Output: number;\n    };\n    Float: {\n        Input: number;\n        Output: number;\n    };\n    Boolean: {\n        Input: boolean;\n        Output: boolean;\n    };\n}\nexport type BaseScalarNames = 'Boolean' | 'Float' | 'ID' | 'Int' | 'String';\nexport type ScalarName<Types extends SchemaTypes> = string & (BaseScalarNames | keyof Types['Scalars']);\nexport type RootName = 'Mutation' | 'Query' | 'Subscription';\n}"
  },
  {
    "moduleName": "@pothos/core/types/type-params",
    "content": "declare module '@pothos/core/types/type-params' {\nimport type { BaseTypeRef } from '@pothos/core/refs/base';\nimport type { InterfaceRef } from '@pothos/core/refs/interface';\nimport type { ObjectRef } from '@pothos/core/refs/object';\nimport type { SchemaTypes } from '@pothos/core/types/schema-types';\nexport declare const outputShapeKey: unique symbol;\nexport declare const parentShapeKey: unique symbol;\nexport declare const abstractReturnShapeKey: unique symbol;\nexport declare const inputShapeKey: unique symbol;\nexport declare const inputFieldShapeKey: unique symbol;\nexport declare const outputFieldShapeKey: unique symbol;\nexport declare const typeBrandKey: unique symbol;\nexport type OutputShape<Types extends SchemaTypes, T> = T extends {\n    [outputShapeKey]: infer U;\n} ? U : T extends new (...args: any[]) => infer U ? U extends {\n    [outputShapeKey]: infer V;\n} ? V : U : T extends keyof Types['outputShapes'] ? Types['outputShapes'][T] : T extends BaseEnum ? ValuesFromEnum<T> : never;\nexport type ParentShape<Types extends SchemaTypes, T> = T extends {\n    [parentShapeKey]: infer U;\n} ? U : OutputShape<Types, T>;\nexport type AbstractReturnShape<Types extends SchemaTypes, T, ResolveType = unknown> = unknown extends ResolveType ? T extends {\n    [abstractReturnShapeKey]: infer U;\n} ? U : OutputShape<Types, T> : OutputShape<Types, T>;\nexport type InputShape<Types extends SchemaTypes, T> = T extends {\n    [inputShapeKey]: infer U;\n} ? U : T extends new (...args: any[]) => infer U ? U extends {\n    [inputShapeKey]: infer V;\n} ? V : U : T extends keyof Types['inputShapes'] ? Types['inputShapes'][T] : T extends BaseEnum ? ValuesFromEnum<T> : never;\nexport interface OutputRefShape<T> {\n    [outputShapeKey]: T;\n}\nexport interface InputRefShape<T> {\n    [inputShapeKey]: T;\n}\nexport interface OutputRef<T = unknown> {\n    [outputShapeKey]: T;\n    name: string;\n    kind: 'Enum' | 'Interface' | 'Object' | 'Scalar' | 'Union';\n}\nexport interface InputRef<T = unknown> {\n    [inputShapeKey]: T;\n    name: string;\n    kind: 'Enum' | 'InputList' | 'InputObject' | 'Scalar';\n}\nexport type OutputType<Types extends SchemaTypes> = BaseEnum | keyof Types['outputShapes'] | (new (...args: any[]) => any) | {\n    [outputShapeKey]: unknown;\n};\nexport type InputType<Types extends SchemaTypes> = BaseEnum | keyof Types['inputShapes'] | {\n    [inputShapeKey]: unknown;\n};\nexport type ConfigurableRef<Types extends SchemaTypes> = BaseTypeRef<Types, unknown> | InputType<Types> | OutputType<Types>;\nexport type TypeParam<Types extends SchemaTypes> = OutputType<Types> | [OutputType<Types>];\nexport type InputTypeParam<Types extends SchemaTypes> = InputType<Types> | [InputType<Types>];\nexport type ObjectParam<Types extends SchemaTypes> = Extract<OutputType<Types>, keyof Types['Objects']> | ObjectRef<Types, unknown> | (new (...args: any[]) => any);\nexport type InterfaceParam<Types extends SchemaTypes> = Extract<OutputType<Types>, keyof Types['Interfaces']> | InterfaceRef<Types, unknown> | (new (...args: any[]) => unknown);\nexport interface BaseEnum {\n    [s: string]: number | string;\n    [s: number]: string;\n}\nexport type ValuesFromEnum<T extends BaseEnum> = T[keyof T];\nexport type EnumParam = BaseEnum | string;\nexport type ShapeWithNullability<Types extends SchemaTypes, Shape, Nullable extends boolean> = boolean extends Nullable ? Types['DefaultFieldNullability'] extends true ? Shape | null | undefined : Shape : Nullable extends true ? Shape | null | undefined : Shape;\nexport type ShapeFromTypeParam<Types extends SchemaTypes, Param extends TypeParam<Types>, Nullable extends FieldNullability<Param>> = Param extends [OutputType<Types>] ? ShapeFromListTypeParam<Types, Param, Nullable> : FieldNullability<Param> extends Nullable ? Types['DefaultFieldNullability'] extends true ? OutputShape<Types, Param> | null | undefined : OutputShape<Types, Param> : Nullable extends true ? OutputShape<Types, Param> | null | undefined : OutputShape<Types, Param>;\nexport type ShapeFromListTypeParam<Types extends SchemaTypes, Param extends [OutputType<Types>], Nullable extends FieldNullability<Param>> = FieldNullability<Param> extends Nullable ? Types['DefaultFieldNullability'] extends true ? readonly OutputShape<Types, Param[0]>[] | null | undefined : readonly OutputShape<Types, Param[0]>[] : Nullable extends true ? readonly OutputShape<Types, Param[0]>[] | null | undefined : Nullable extends false ? readonly OutputShape<Types, Param[0]>[] : Nullable extends {\n    list: infer List;\n    items: infer Items;\n} ? Items extends boolean ? List extends true ? readonly ShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] | null | undefined : readonly ShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] : never : never;\nexport type FieldNullability<Param> = boolean | (Param extends [unknown] ? boolean | {\n    items: boolean;\n    list: boolean;\n} : boolean);\nexport type InputShapeFromTypeParam<Types extends SchemaTypes, Param extends InputTypeParam<Types>, Required extends FieldRequiredness<Param>> = Param extends [InputType<Types>] ? InputShapeFromListTypeParam<Types, Param, Required> : FieldRequiredness<Param> extends Required ? Types['DefaultInputFieldRequiredness'] extends false ? InputShape<Types, Param> | null | undefined : InputShape<Types, Param> : Required extends true ? InputShape<Types, Param> : InputShape<Types, Param> | null | undefined;\nexport type InputShapeFromListTypeParam<Types extends SchemaTypes, Param extends [InputType<Types>], Required extends FieldRequiredness<Param>> = FieldRequiredness<Param> extends Required ? Types['DefaultInputFieldRequiredness'] extends false ? InputShape<Types, Param[0]>[] | null | undefined : InputShape<Types, Param[0]>[] : Required extends true ? InputShape<Types, Param[0]>[] : Required extends false ? InputShape<Types, Param[0]>[] | null | undefined : FieldRequiredness<Param> extends Required ? InputShape<Types, Param[0]>[] | null | undefined : Required extends boolean | {\n    list: infer List;\n    items: infer Items;\n} ? Items extends boolean ? List extends true ? InputShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] : InputShapeFromTypeParam<Types, Param[0], Items extends false ? false : true>[] | null | undefined : never : never;\nexport type FieldRequiredness<Param> = boolean | (Param extends [unknown] ? boolean | {\n    items: boolean;\n    list: boolean;\n} : boolean);\nexport type InputOrArgRef<Types extends SchemaTypes, T, Kind extends 'Arg' | 'InputObject'> = Kind extends 'Arg' ? PothosSchemaTypes.ArgumentRef<Types, T> : Kind extends 'InputObject' ? PothosSchemaTypes.InputFieldRef<Types, T> : never;\nexport interface GenericFieldRef<T = unknown> {\n    [outputFieldShapeKey]: T;\n}\nexport interface GenericInputFieldRef<T = unknown> {\n    [inputFieldShapeKey]: T;\n}\n}"
  },
  {
    "moduleName": "@pothos/core/types/utils",
    "content": "declare module '@pothos/core/types/utils' {\nimport type { GraphQLResolveInfo } from 'graphql';\nexport type MaybePromise<T> = Promise<T> | T;\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\nexport type RequiredKeys<T extends object> = Exclude<keyof T, OptionalKeys<T>>;\nexport type OptionalKeys<T extends object> = {\n    [K in keyof T]: T[K] | undefined extends T[K] ? K : T[K] | null extends T[K] ? K : never;\n}[keyof T];\nexport type NonEmptyKeys<T extends object> = undefined extends {} ? never : {\n    [K in keyof T]: {} extends T[K] ? never : T[K] extends NonNullable<T[K]> ? K : never;\n}[keyof T];\nexport type EmptyKeys<T extends object> = {\n    [K in keyof T]: {} extends T[K] ? K : T[K] extends NonNullable<T[K]> ? never : K;\n}[keyof T];\nexport type Normalize<T> = T extends object ? {\n    [K in keyof T]: T[K];\n} : T;\nexport type NullableToOptional<T> = T extends object ? Normalize<{\n    [K in OptionalKeys<T>]?: T[K];\n} & {\n    [K in RequiredKeys<T>]: T[K];\n}> : T;\nexport type EmptyToOptional<T> = T extends object ? Normalize<{\n    [K in EmptyKeys<T> | OptionalKeys<T>]?: T[K];\n} & {\n    [K in NonEmptyKeys<T>]: T[K];\n}> : T;\nexport type NormalizeNullable<T> = undefined extends T ? T | null | undefined : null extends T ? T | null | undefined : T;\nexport type NormalizeNullableFields<T extends object> = Normalize<{\n    [K in OptionalKeys<T>]?: T[K] | null | undefined;\n} & {\n    [K in RequiredKeys<T>]: T[K];\n}>;\nexport type IsSimpleRecord<T> = ([\n    T\n] extends [\n    Record<string, any>\n] ? keyof T extends infer K ? K extends string ? T[K] extends (...args: any[]) => unknown ? [\n    1\n] extends [T[K]] ? never : false : never : never : false : false) extends never ? true : false;\nexport type RecursivelyNormalizeNullableFields<T> = T extends null | undefined ? null | undefined : T extends (infer L)[] ? RecursivelyNormalizeNullableFields<L>[] : T extends (...args: any[]) => unknown ? T : keyof T extends string ? IsSimpleRecord<T> extends true ? Normalize<{\n    [K in OptionalKeys<T & object>]?: K extends string ? RecursivelyNormalizeNullableFields<NonNullable<T[K]>> | null | undefined : T[K];\n} & {\n    [K in RequiredKeys<T & object>]: RecursivelyNormalizeNullableFields<NonNullable<T[K]>>;\n}> : T : T;\nexport type RemoveNeverKeys<T extends {}> = {\n    [K in keyof T as [T[K]] extends [never] ? never : K]: T[K];\n};\nexport type Merge<T> = {\n    [K in keyof T]: T[K];\n} & {};\nexport type MergeUnion<T, Keys extends keyof T = T extends unknown ? keyof T : never> = Merge<T extends unknown ? {\n    [K in Keys as K extends keyof T ? never : K]?: never;\n} & {\n    [K in Keys as K extends keyof T ? K : never]: T[K & keyof T];\n} : never>;\nexport interface Path {\n    prev: Path | undefined;\n    key: number | string;\n    typename: string | undefined;\n}\nexport type LastIndex<T extends unknown[]> = T extends [unknown, ...infer U] ? U['length'] : 0;\nexport type NormalizeArgs<T extends unknown[], Index extends keyof T = LastIndex<T>> = undefined extends T[Index] ? {} extends T[Index] ? undefined extends {} ? {\n    [K in keyof T]?: T[K];\n} : T : {\n    [K in keyof T]-?: T[K];\n} : {} extends T[Index] ? {\n    [K in keyof T]?: T[K];\n} : T;\nexport type IsStrictMode = undefined extends {} ? false : true;\nexport interface PartialResolveInfo {\n    fragments: GraphQLResolveInfo['fragments'];\n    variableValues: GraphQLResolveInfo['variableValues'];\n    schema: GraphQLResolveInfo['schema'];\n}\nexport type Simplify<T> = {\n    [KeyType in keyof T]: T[KeyType];\n} & {};\nexport type DistributeOmit<T, K> = T extends {} ? {\n    [K2 in keyof T as K2 extends K ? never : K2]: T[K2];\n} & {} : T;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/base64",
    "content": "declare module '@pothos/core/utils/base64' {\nexport declare function encodeBase64(value: string): string;\nexport declare function decodeBase64(value: string): string;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/context-cache",
    "content": "declare module '@pothos/core/utils/context-cache' {\nexport declare const contextCacheSymbol: unique symbol;\nexport declare function initContextCache(): {\n    [contextCacheSymbol]: {};\n};\nexport interface ContextCache<T, C extends object, Args extends unknown[]> {\n    (context: C, ...args: Args): T;\n    delete: (context: C) => void;\n}\nexport declare function createContextCache<T, C extends object = object, Args extends unknown[] = []>(create: (context: C, ...args: Args) => T): ContextCache<T, C, Args>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/enums",
    "content": "declare module '@pothos/core/utils/enums' {\nimport type { BaseEnum, EnumValues, PothosEnumValueConfig, SchemaTypes } from '@pothos/core/types';\nexport declare function normalizeEnumValues<Types extends SchemaTypes>(values: EnumValues<SchemaTypes>): Record<string, PothosEnumValueConfig<Types>>;\nexport declare function valuesFromEnum<Types extends SchemaTypes>(Enum: BaseEnum, values?: Record<string, Omit<PothosSchemaTypes.EnumValueConfig<Types>, 'value'>>): Record<string, PothosEnumValueConfig<Types>>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils",
    "content": "declare module '@pothos/core/utils' {\nimport { type DirectiveNode, type FieldNode, type GraphQLDirective, type GraphQLField } from 'graphql';\nimport { type InputType, type InputTypeParam, type MaybePromise, type OutputType, type PartialResolveInfo, type SchemaTypes, type TypeParam } from '@pothos/core/types';\nexport * from '@pothos/core/utils/base64';\nexport * from '@pothos/core/utils/context-cache';\nexport * from '@pothos/core/utils/enums';\nexport * from '@pothos/core/utils/input';\nexport * from '@pothos/core/utils/params';\nexport * from '@pothos/core/utils/sort-classes';\nexport declare function assertNever(value: never): never;\nexport declare function assertArray(value: unknown): value is unknown[];\nexport declare function isThenable(value: unknown): value is PromiseLike<unknown>;\nexport declare function verifyRef(ref: unknown): void;\nexport declare function verifyInterfaces(interfaces: unknown): void;\nexport declare function brandWithType<Types extends SchemaTypes>(val: unknown, type: OutputType<Types>): void;\nexport declare function getTypeBrand(val: unknown): OutputType<SchemaTypes> | null;\nexport declare function unwrapListParam<Types extends SchemaTypes>(param: InputTypeParam<Types> | TypeParam<Types>): InputType<Types> | OutputType<Types>;\nexport declare function unwrapOutputListParam<Types extends SchemaTypes>(param: TypeParam<Types>): OutputType<Types>;\nexport declare function unwrapInputListParam<Types extends SchemaTypes>(param: InputTypeParam<Types>): InputType<Types>;\n/**\n * Helper for allowing plugins to fulfill the return of the `next` resolver, without paying the cost of the\n * Promise if not required.\n */\nexport declare function completeValue<T, R>(valOrPromise: PromiseLike<T> | T, onSuccess: (completedVal: T) => PromiseLike<R> | R, onError?: (errVal: unknown) => PromiseLike<R> | R): Promise<Awaited<R>> | Awaited<R>;\nexport declare function getMappedArgumentValues(def: GraphQLDirective | GraphQLField<unknown, unknown>, node: DirectiveNode | FieldNode, context: object, info: PartialResolveInfo): MaybePromise<{\n    [argument: string]: unknown;\n}>;\nexport declare function reduceMaybeAsync<T, R>(items: T[], initialValue: R, fn: (value: R, item: T, i: number) => MaybePromise<R>): MaybePromise<R>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/input",
    "content": "declare module '@pothos/core/utils/input' {\nimport type { BuildCache } from '@pothos/core/build-cache';\nimport type { PothosInputFieldConfig, PothosInputFieldType, PothosTypeConfig, SchemaTypes } from '@pothos/core/types';\nexport interface InputTypeFieldsMapping<Types extends SchemaTypes, T> {\n    configs: Record<string, PothosInputFieldConfig<Types>>;\n    map: InputFieldsMapping<Types, T> | null;\n}\nexport type InputFieldMapping<Types extends SchemaTypes, T> = {\n    kind: 'Enum';\n    isList: boolean;\n    listDepth: number;\n    config: PothosInputFieldConfig<Types>;\n    value: T;\n} | {\n    kind: 'InputObject';\n    config: PothosInputFieldConfig<Types>;\n    isList: boolean;\n    listDepth: number;\n    value: T | null;\n    fields: InputTypeFieldsMapping<Types, T>;\n} | {\n    kind: 'Scalar';\n    isList: boolean;\n    listDepth: number;\n    config: PothosInputFieldConfig<Types>;\n    value: T;\n};\nexport type InputFieldsMapping<Types extends SchemaTypes, T> = Map<string, InputFieldMapping<Types, T>>;\nexport declare function resolveInputTypeConfig<Types extends SchemaTypes>(type: PothosInputFieldType<Types>, buildCache: BuildCache<Types>): Extract<PothosTypeConfig, {\n    kind: 'Enum' | 'InputObject' | 'Scalar';\n}>;\nexport declare function mapInputFields<Types extends SchemaTypes, T>(inputs: Record<string, PothosInputFieldConfig<Types>>, buildCache: BuildCache<Types>, mapper: (config: PothosInputFieldConfig<Types>) => T | null, cache?: Map<string, InputTypeFieldsMapping<Types, T>>): InputFieldsMapping<Types, T> | null;\nexport declare function createInputValueMapper<Types extends SchemaTypes, T, Args extends unknown[] = []>(argMap: InputFieldsMapping<Types, T>, mapValue: (val: unknown, mapping: InputFieldMapping<Types, T>, ...args: Args) => unknown): (obj: object, map?: InputFieldsMapping<Types, T>, ...args: Args) => Record<string, unknown>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/params",
    "content": "declare module '@pothos/core/utils/params' {\nimport type { ConfigStore } from '@pothos/core/config-store';\nimport type { FieldNullability, FieldRequiredness, InputType, InputTypeParam, OutputType, PothosInputFieldType, PothosOutputFieldType, SchemaTypes, TypeParam } from '@pothos/core/types';\nexport declare function unwrapOutputFieldType<Types extends SchemaTypes>(type: PothosOutputFieldType<Types>): OutputType<Types>;\nexport declare function typeFromParam<Types extends SchemaTypes>(param: TypeParam<Types>, configStore: ConfigStore<Types>, nullableOption: FieldNullability<[unknown]>): PothosOutputFieldType<Types>;\nexport declare function unwrapInputFieldType<Types extends SchemaTypes>(type: PothosInputFieldType<Types>): InputType<Types>;\nexport declare function inputTypeFromParam<Types extends SchemaTypes>(param: InputTypeParam<Types>, configStore: ConfigStore<Types>, requiredOption: FieldRequiredness<[unknown]>): PothosInputFieldType<Types>;\n}"
  },
  {
    "moduleName": "@pothos/core/utils/sort-classes",
    "content": "declare module '@pothos/core/utils/sort-classes' {\nexport declare function classDepth(obj: {}): number;\nexport declare function sortClasses<T extends new (...args: any[]) => unknown>(classes: T[]): T[];\n}"
  }
];

// Plugin types (loaded on-demand)
export const pluginTypeDefinitions: Record<string, TypeDefinition[]> = {
  "@pothos/plugin-simple-objects": [
    {
      "moduleName": "@pothos/plugin-simple-objects/global-types",
      "content": "import type { FieldMap, FieldNullability, InputFieldMap, InterfaceFieldsShape, InterfaceParam, Normalize, ObjectFieldsShape, ParentShape, SchemaTypes, TypeParam, UnionToIntersection } from '@pothos/core';\nimport type { PothosSimpleObjectsPlugin } from '.';\nimport type { OutputShapeFromFields, SimpleObjectFieldsShape } from '@pothos/plugin-simple-objects/types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface Plugins<Types extends SchemaTypes> {\n            simpleObjects: PothosSimpleObjectsPlugin<Types>;\n        }\n        interface SchemaBuilder<Types extends SchemaTypes> {\n            simpleObject: <const Interfaces extends InterfaceParam<Types>[], Fields extends FieldMap, Shape extends Normalize<OutputShapeFromFields<Fields> & UnionToIntersection<ParentShape<Types, Interfaces[number]>>>>(name: string, options: SimpleObjectTypeOptions<Types, Interfaces, Fields, Shape>, fields?: ObjectFieldsShape<Types, Shape>) => ObjectRef<Types, Shape>;\n            simpleInterface: <const Interfaces extends InterfaceParam<Types>[], Fields extends FieldMap, Shape extends Normalize<OutputShapeFromFields<Fields> & UnionToIntersection<ParentShape<Types, Interfaces[number]>>>>(name: string, options: SimpleInterfaceTypeOptions<Types, Interfaces, Fields, Shape>, fields?: InterfaceFieldsShape<Types, Shape>) => InterfaceRef<Types, Shape>;\n        }\n        interface PothosKindToGraphQLType {\n            SimpleObject: 'Object';\n            SimpleInterface: 'Interface';\n        }\n        interface FieldOptionsByKind<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> {\n            SimpleObject: ObjectFieldOptions<Types, ParentShape, Type, Nullable, Args, ResolveReturnShape>;\n            SimpleInterface: InterfaceFieldOptions<Types, ParentShape, Type, Nullable, Args, ResolveReturnShape>;\n        }\n        type SimpleObjectTypeOptions<Types extends SchemaTypes, Interfaces extends InterfaceParam<Types>[], Fields extends FieldMap, Shape> = Omit<ObjectTypeOptions<Types, Shape> | ObjectTypeWithInterfaceOptions<Types, Shape, Interfaces>, 'fields' | 'interfaces'> & {\n            interfaces?: (() => Interfaces) | Interfaces;\n            fields?: SimpleObjectFieldsShape<Types, Fields>;\n        };\n        interface SimpleInterfaceTypeOptions<Types extends SchemaTypes, Interfaces extends InterfaceParam<Types>[], Fields extends FieldMap, Shape> extends Omit<InterfaceTypeOptions<Types, Shape, Interfaces>, 'fields' | 'interfaces'> {\n            interfaces?: (() => Interfaces) | Interfaces;\n            fields?: SimpleObjectFieldsShape<Types, Fields>;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-simple-objects",
      "content": "declare module '@pothos/plugin-simple-objects' {\nimport '@pothos/plugin-simple-objects/global-types';\nimport { BasePlugin, type SchemaTypes } from '@pothos/core';\ndeclare const pluginName = \"simpleObjects\";\nexport default pluginName;\nexport declare class PothosSimpleObjectsPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-simple-objects/types",
      "content": "declare module '@pothos/plugin-simple-objects/types' {\nimport type { FieldMap, GenericFieldRef, NullableToOptional, SchemaTypes } from '@pothos/core';\nexport type SimpleObjectFieldsShape<Types extends SchemaTypes, Fields extends FieldMap> = (t: PothosSchemaTypes.RootFieldBuilder<Types, unknown, 'SimpleObject'>) => Fields;\nexport type SimpleInterfaceFieldsShape<Types extends SchemaTypes, Fields extends FieldMap> = (t: PothosSchemaTypes.RootFieldBuilder<Types, unknown, 'SimpleInterface'>) => Fields;\nexport type OutputShapeFromFields<Fields extends FieldMap> = NullableToOptional<{\n    [K in keyof Fields]: Fields[K] extends GenericFieldRef<infer T> ? T : never;\n}>;\n}"
    }
  ],
  "@pothos/plugin-relay": [
    {
      "moduleName": "@pothos/plugin-relay/field-builder",
      "content": "declare module '@pothos/plugin-relay/field-builder' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/global-types",
      "content": "import { type FieldKind, type FieldNullability, type FieldOptionsFromKind, type FieldRequiredness, type InferredFieldOptionKeys, type InputFieldMap, type InputFieldsFromShape, type InputOrArgRef, type InputShapeFromFields, type InputShapeFromTypeParam, type InterfaceParam, inputShapeKey, type Merge, type NormalizeArgs, type ObjectFieldsShape, type ObjectFieldThunk, type ObjectParam, type OutputShape, type OutputType, type ParentShape, type Resolver, type SchemaTypes, type ShapeFromTypeParam } from '@pothos/core';\nimport type { DefaultEdgesNullability, PothosRelayPlugin } from '.';\nimport type { ImplementableNodeRef, NodeRef } from '@pothos/plugin-relay/node-ref';\nimport type { ConnectionResultShape, ConnectionShape, ConnectionShapeForType, ConnectionShapeFromResolve, GetAwaitedListItem, GlobalIDFieldOptions, GlobalIDInputFieldOptions, GlobalIDInputShape, GlobalIDListFieldOptions, GlobalIDListInputFieldOptions, GlobalIDShape, InputShapeWithClientMutationId, NodeFieldOptions, NodeListFieldOptions, NodeObjectOptions, NodeRefOptions, PageInfoShape, RelayMutationFieldOptions, RelayMutationInputOptions, RelayMutationPayloadOptions, RelayPluginOptions } from '@pothos/plugin-relay/types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface Plugins<Types extends SchemaTypes> {\n            relay: PothosRelayPlugin<Types>;\n        }\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            relay?: RelayPluginOptions<Types>;\n        }\n        interface V3SchemaBuilderOptions<Types extends SchemaTypes> {\n            relay: never;\n            relayOptions: RelayPluginOptions<Types>;\n        }\n        interface UserSchemaTypes {\n            Connection: {};\n            DefaultEdgesNullability: FieldNullability<[unknown]>;\n            DefaultNodeNullability: boolean;\n        }\n        interface ExtendDefaultTypes<PartialTypes extends Partial<UserSchemaTypes>> {\n            Connection: PartialTypes['Connection'] & {};\n            DefaultEdgesNullability: FieldNullability<[\n                unknown\n            ]> extends PartialTypes['DefaultEdgesNullability'] ? PartialTypes['Defaults'] extends 'v3' ? {\n                list: false;\n                items: true;\n            } : DefaultEdgesNullability : FieldNullability<[unknown]> & PartialTypes['DefaultEdgesNullability'];\n            DefaultNodeNullability: boolean extends PartialTypes['DefaultNodeNullability'] ? false : PartialTypes['DefaultNodeNullability'] & boolean;\n        }\n        interface SchemaBuilder<Types extends SchemaTypes> {\n            pageInfoRef: () => ObjectRef<Types, PageInfoShape>;\n            nodeInterfaceRef: () => InterfaceRef<Types, unknown>;\n            nodeRef: <Shape, IDShape = string, Param extends string | ObjectRef<Types, Shape> = string>(param: Param, options: NodeRefOptions<Types, Shape, Shape, IDShape>, fields?: ObjectFieldsShape<Types, Shape>) => Param extends string ? ImplementableNodeRef<Types, Shape, Shape, IDShape> : Param;\n            node: <const Interfaces extends InterfaceParam<Types>[], Param extends ObjectParam<Types>, IDShape = string>(param: Param, options: NodeObjectOptions<Types, Param, Interfaces, IDShape>, fields?: ObjectFieldsShape<Types, ParentShape<Types, Param>>) => NodeRef<Types, OutputShape<Types, Param>, ParentShape<Types, Param>, IDShape>;\n            globalConnectionFields: (fields: ObjectFieldsShape<Types, ConnectionShape<Types, {}, false>>) => void;\n            globalConnectionField: (name: string, field: ObjectFieldThunk<Types, ConnectionShape<Types, {}, false>>) => void;\n            relayMutationField: <Fields extends InputFieldMap, Nullable extends boolean, ResolveShape, ResolveReturnShape, const Interfaces extends InterfaceParam<Types>[], InputName extends string = 'input', Args extends InputFieldMap = {}>(name: string, inputOptions: InputObjectRef<Types, unknown> | RelayMutationInputOptions<Types, Fields, InputName> | null, fieldOptions: RelayMutationFieldOptions<Types, Fields, Nullable, InputName, ResolveShape, ResolveReturnShape, Args>, payloadOptions: RelayMutationPayloadOptions<Types, ResolveShape, Interfaces>) => {\n                inputType: InputObjectRef<Types, InputShapeWithClientMutationId<Types, Fields>>;\n                payloadType: ObjectRef<Types, ResolveShape>;\n            };\n            connectionObject: <Type extends OutputType<Types>, ResolveReturnShape, EdgeNullability extends FieldNullability<[unknown]> = Types['DefaultEdgesNullability'], NodeNullability extends boolean = Types['DefaultNodeNullability'], const ConnectionInterfaces extends InterfaceParam<Types>[] = [], const EdgeInterfaces extends InterfaceParam<Types>[] = []>(connectionOptions: ConnectionObjectOptions<Types, Type, EdgeNullability, NodeNullability, ResolveReturnShape, ConnectionInterfaces> & {\n                name: string;\n                type: Type;\n            }, ...args: NormalizeArgs<[\n                edgeOptions: ObjectRef<Types, {\n                    cursor: string;\n                    node?: ShapeFromTypeParam<Types, Type, NodeNullability>;\n                }> | (ConnectionEdgeObjectOptions<Types, Type, NodeNullability, ResolveReturnShape, EdgeInterfaces> & {\n                    name?: string;\n                })\n            ]>) => ObjectRef<Types, ConnectionShapeForType<Types, Type, false, EdgeNullability, NodeNullability>>;\n            edgeObject: <Type extends OutputType<Types>, ResolveReturnShape, NodeNullability extends boolean = Types['DefaultNodeNullability'], const Interfaces extends InterfaceParam<Types>[] = []>(edgeOptions: ConnectionEdgeObjectOptions<Types, Type, NodeNullability, ResolveReturnShape, Interfaces> & {\n                type: Type;\n                name: string;\n                nodeNullable?: NodeNullability;\n            }) => ObjectRef<Types, {\n                cursor: string;\n                node: ShapeFromTypeParam<Types, Type, NodeNullability>;\n            }>;\n        }\n        interface InputFieldBuilder<Types extends SchemaTypes, Kind extends 'Arg' | 'InputObject'> {\n            connectionArgs: () => {\n                [K in keyof DefaultConnectionArguments]-?: InputOrArgRef<Types, DefaultConnectionArguments[K], Kind>;\n            };\n            globalID: <Req extends boolean, For extends ObjectParam<Types>>(...args: NormalizeArgs<[options: GlobalIDInputFieldOptions<Types, Req, Kind, For>]>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, GlobalIDInputShape<For extends {\n                parseId?: (...args: any[]) => infer T;\n            } ? T : string>, Req>, Kind>;\n            globalIDList: <Req extends FieldRequiredness<['ID']>, For extends ObjectParam<Types>>(...args: NormalizeArgs<[options: GlobalIDListInputFieldOptions<Types, Req, Kind, For>]>) => InputOrArgRef<Types, InputShapeFromTypeParam<Types, [\n                {\n                    [inputShapeKey]: {\n                        typename: string;\n                        id: For extends {\n                            parseId?: (...args: any[]) => infer T;\n                        } ? T : string;\n                    };\n                }\n            ], Req>, Kind>;\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> {\n            globalID: <Args extends InputFieldMap, Nullable extends FieldNullability<'ID'>, ResolveReturnShape>(options: GlobalIDFieldOptions<Types, ParentShape, Args, Nullable, ResolveReturnShape, Kind>) => FieldRef<Types, ShapeFromTypeParam<Types, 'ID', Nullable>>;\n            globalIDList: <Args extends InputFieldMap, Nullable extends FieldNullability<['ID']>, ResolveReturnShape>(options: GlobalIDListFieldOptions<Types, ParentShape, Args, Nullable, ResolveReturnShape, Kind>) => FieldRef<Types, ShapeFromTypeParam<Types, ['ID'], Nullable>>;\n            node: <Args extends InputFieldMap, ResolveShape>(options: NodeFieldOptions<Types, ParentShape, Args, ResolveShape, Kind>) => FieldRef<Types, unknown>;\n            nodeList: <Args extends InputFieldMap, ResolveShape>(options: NodeListFieldOptions<Types, ParentShape, Args, ResolveShape, Kind>) => FieldRef<Types, readonly unknown[]>;\n            connection: <Type extends OutputType<Types>, Args extends InputFieldMap, Nullable extends boolean, ResolveShape, ResolveReturnShape, EdgeNullability extends FieldNullability<[unknown]> = Types['DefaultEdgesNullability'], NodeNullability extends boolean = Types['DefaultNodeNullability'], const ConnectionInterfaces extends InterfaceParam<Types>[] = [], const EdgeInterfaces extends InterfaceParam<Types>[] = [], ConnectionResult extends ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability> = ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability>>(options: FieldOptionsFromKind<Types, ParentShape, Type, Nullable, InputFieldsFromShape<Types, DefaultConnectionArguments, 'Arg'> & (InputFieldMap extends Args ? {} : Args), Kind, ResolveShape, ResolveReturnShape> extends infer FieldOptions ? ConnectionFieldOptions<Types, FieldOptions extends {\n                resolve?: (parent: infer P, ...args: any[]) => unknown;\n            } ? P : unknown extends ResolveShape ? ParentShape : ResolveShape, Type, Nullable, EdgeNullability, NodeNullability, Args, ResolveReturnShape, ConnectionResult> & Omit<FieldOptions, 'args' | 'type' | InferredFieldOptionKeys> : never, ...args: NormalizeArgs<[\n                connectionOptions: ObjectRef<Types, ConnectionShapeForType<Types, Type, false, EdgeNullability, NodeNullability, ConnectionResult>> | Omit<ConnectionObjectOptions<Types, Type, EdgeNullability, NodeNullability, ResolveReturnShape, ConnectionInterfaces>, 'edgesNullable'>,\n                edgeOptions: ConnectionEdgeObjectOptions<Types, Type, NodeNullability, ResolveReturnShape, EdgeInterfaces> | ObjectRef<Types, {\n                    cursor: string;\n                    node?: ShapeFromTypeParam<Types, Type, NodeNullability>;\n                }>\n            ], 0>) => FieldRef<Types, ConnectionShapeForType<Types, Type, Nullable, EdgeNullability, NodeNullability>>;\n        }\n        interface ConnectionFieldOptions<Types extends SchemaTypes, ParentShape, Type extends OutputType<Types>, Nullable extends boolean, EdgeNullability extends FieldNullability<[unknown]>, NodeNullability extends boolean, Args extends InputFieldMap, ResolveReturnShape, ConnectionResult extends ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability> = ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability>> {\n            type: Type;\n            args?: Args;\n            edgesNullable?: EdgeNullability;\n            nodeNullable?: NodeNullability;\n            resolve: Resolver<ParentShape, DefaultConnectionArguments & InputShapeFromFields<Args>, Types['Context'], ConnectionShapeForType<Types, Type, Nullable, EdgeNullability, NodeNullability, ConnectionResult>, ResolveReturnShape>;\n        }\n        interface ConnectionObjectOptions<Types extends SchemaTypes, Type extends OutputType<Types>, EdgeNullability extends FieldNullability<[unknown]>, NodeNullability extends boolean, Resolved, Interfaces extends InterfaceParam<Types>[] = [], ConnectionResult extends ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability> = ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability>> extends ObjectTypeWithInterfaceOptions<Types, ConnectionShapeFromResolve<Types, Type, false, EdgeNullability, NodeNullability, Resolved, ConnectionResult>, Interfaces> {\n            name?: string;\n            edgesNullable?: EdgeNullability;\n            nodeNullable?: NodeNullability;\n            edgesField?: Omit<ObjectFieldOptions<Types, {}, ObjectRef<Types, {}>, Types['DefaultNodeNullability'], {}, GlobalIDShape<Types> | string>, 'args' | 'nullable' | InferredFieldOptionKeys | 'type'>;\n        }\n        interface ConnectionEdgeObjectOptions<Types extends SchemaTypes, Type extends OutputType<Types>, NodeNullability extends boolean, Resolved, Interfaces extends InterfaceParam<Types>[] = []> extends ObjectTypeWithInterfaceOptions<Types, GetAwaitedListItem<Merge<ConnectionShapeFromResolve<Types, Type, false, false, NodeNullability, Resolved>['edges']>>, Interfaces> {\n            name?: string;\n            nodeField?: Omit<ObjectFieldOptions<Types, {}, ObjectRef<Types, {}>, Types['DefaultNodeNullability'], {}, GlobalIDShape<Types> | string>, 'args' | 'nullable' | InferredFieldOptionKeys | 'type'>;\n        }\n        interface DefaultConnectionArguments {\n            first?: number | null | undefined;\n            last?: number | null | undefined;\n            before?: string | null | undefined;\n            after?: string | null | undefined;\n        }\n        interface ConnectionShapeHelper<Types extends SchemaTypes, T, Nullable> {\n            shape: ConnectionShape<Types, T, Nullable>;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay",
      "content": "declare module '@pothos/plugin-relay' {\nimport '@pothos/plugin-relay/global-types';\nimport '@pothos/plugin-relay/field-builder';\nimport '@pothos/plugin-relay/input-field-builder';\nimport '@pothos/plugin-relay/schema-builder';\nimport { BasePlugin, type PothosOutputFieldConfig, type SchemaTypes } from '@pothos/core';\nexport * from '@pothos/plugin-relay/node-ref';\nexport * from '@pothos/plugin-relay/types';\nexport * from '@pothos/plugin-relay/utils';\ndeclare const pluginName = \"relay\";\nexport default pluginName;\nexport declare class PothosRelayPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n    private mappingCache;\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/input-field-builder",
      "content": "declare module '@pothos/plugin-relay/input-field-builder' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/node-ref",
      "content": "declare module '@pothos/plugin-relay/node-ref' {\nimport { ImplementableObjectRef, type ObjectParam, ObjectRef, type SchemaTypes } from '@pothos/core';\nimport type { NodeRefOptions } from '@pothos/plugin-relay/types';\nexport declare const relayIDShapeKey: unique symbol;\nexport declare class NodeRef<Types extends SchemaTypes, T, P = T, IDShape = string> extends ObjectRef<Types, T, P> {\n    [relayIDShapeKey]: IDShape;\n    parseId: ((id: string, ctx: object) => IDShape) | undefined;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string, param: ObjectParam<Types>, options: NodeRefOptions<Types, T, P, IDShape>);\n}\nexport declare class ImplementableNodeRef<Types extends SchemaTypes, T, P = T, IDShape = string> extends ImplementableObjectRef<Types, T, P> {\n    parseId: ((id: string, ctx: object) => IDShape) | undefined;\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, name: string, options: NodeRefOptions<Types, T, P, IDShape>);\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/schema-builder",
      "content": "declare module '@pothos/plugin-relay/schema-builder' {\nimport { ObjectRef, type SchemaTypes } from '@pothos/core';\nimport type { ConnectionShape } from '@pothos/plugin-relay/types';\nexport declare const connectionRefs: WeakMap<PothosSchemaTypes.SchemaBuilder<SchemaTypes>, ObjectRef<SchemaTypes, ConnectionShape<SchemaTypes, unknown, boolean>>[]>;\nexport declare const globalConnectionFieldsMap: WeakMap<PothosSchemaTypes.SchemaBuilder<SchemaTypes>, ((ref: ObjectRef<SchemaTypes, ConnectionShape<SchemaTypes, unknown, boolean>>) => void)[]>;\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/types",
      "content": "declare module '@pothos/plugin-relay/types' {\nimport { type ArgumentRef, type DistributeOmit, type EmptyToOptional, type FieldKind, type FieldNullability, type FieldOptionsFromKind, type FieldRequiredness, type InferredFieldOptionKeys, type InputFieldMap, type InputFieldRef, type InputFieldsFromShape, type InputRef, type InputShapeFromFields, type InterfaceParam, inputShapeKey, type ListResolveValue, type MaybePromise, type Merge, type Normalize, type ObjectFieldsShape, type ObjectParam, type ObjectRef, type ObjectTypeOptions, type OutputRef, type OutputRefShape, type OutputShape, type OutputType, type ParentShape, type Resolver, type SchemaTypes, type ShapeFromListTypeParam, type ShapeFromTypeParam } from '@pothos/core';\nimport type { GraphQLResolveInfo } from 'graphql';\nexport type RelayPluginOptions<Types extends SchemaTypes> = EmptyToOptional<{\n    idFieldName?: string;\n    idFieldOptions?: Partial<Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, 'ID', boolean, {}, PageInfoShape>, 'args' | 'nullable' | 'type' | InferredFieldOptionKeys>>;\n    relayMutationFieldOptions?: Omit<PothosSchemaTypes.MutationFieldOptions<Types, ObjectRef<Types, {}>, boolean, {}, unknown>, 'args' | 'type' | InferredFieldOptionKeys>;\n    clientMutationId?: 'omit' | 'optional' | 'required';\n    cursorType?: 'ID' | 'String';\n    edgeCursorType?: 'ID' | 'String';\n    pageInfoCursorType?: 'ID' | 'String';\n    brandLoadedObjects?: boolean;\n    nodeTypeOptions: Omit<PothosSchemaTypes.InterfaceTypeOptions<Types, unknown>, 'fields'>;\n    pageInfoTypeOptions: Omit<PothosSchemaTypes.ObjectTypeOptions<Types, PageInfoShape>, 'fields'>;\n    nodeQueryOptions: false | (Omit<PothosSchemaTypes.QueryFieldOptions<Types, OutputRefShape<GlobalIDShape<Types> | string>, boolean, {\n        id: ArgumentRef<Types, {\n            typename: string;\n            id: string;\n        }>;\n    }, Promise<unknown>>, 'args' | 'type' | InferredFieldOptionKeys> & {\n        args?: {\n            id?: Omit<GlobalIDInputFieldOptions<Types, true, 'Arg', ObjectParam<Types>>, 'required'>;\n        };\n        resolve?: (parent: Types['Root'], args: {\n            id: {\n                typename: string;\n                id: string;\n            };\n        }, context: Types['Context'], info: GraphQLResolveInfo, resolveNode: (id: {\n            typename: string;\n            id: string;\n        }) => MaybePromise<unknown>) => MaybePromise<unknown>;\n    });\n    nodesQueryOptions: false | (Omit<PothosSchemaTypes.QueryFieldOptions<Types, [\n        OutputRefShape<GlobalIDShape<Types> | string>\n    ], FieldNullability<[unknown]>, {\n        ids: ArgumentRef<Types, {\n            typename: string;\n            id: string;\n        }[]>;\n    }, Promise<unknown>[]>, 'args' | 'type' | InferredFieldOptionKeys> & {\n        args?: {\n            ids?: Omit<GlobalIDListInputFieldOptions<Types, true, 'Arg', ObjectParam<Types>>, 'required'>;\n        };\n        resolve?: (parent: Types['Root'], args: {\n            ids: {\n                typename: string;\n                id: string;\n            }[];\n        }, context: Types['Context'], info: GraphQLResolveInfo, resolveNodes: (ids: {\n            id: string;\n            typename: string;\n        }[]) => Promise<unknown[]>) => MaybePromise<readonly MaybePromise<unknown>[]>;\n    });\n    mutationInputArgOptions: Omit<PothosSchemaTypes.ArgFieldOptions<Types, InputRef<{}>, boolean>, 'fields' | 'type'>;\n    clientMutationIdInputOptions: Omit<PothosSchemaTypes.InputObjectFieldOptions<Types, 'ID', boolean>, 'type'>;\n    clientMutationIdFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, 'ID', boolean, {}, Types['Scalars']['ID']['Output']>, 'args' | 'type' | InferredFieldOptionKeys>;\n    cursorFieldOptions: Normalize<Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, 'ID' | 'String', false, {}, Types['Scalars']['ID' | 'String']['Output']>, 'args' | 'type' | InferredFieldOptionKeys> & {\n        type?: 'ID' | 'String';\n    }>;\n    nodeFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, ObjectRef<Types, {}>, Types['DefaultNodeNullability'], {}, GlobalIDShape<Types> | string>, 'args' | 'nullable' | 'type' | InferredFieldOptionKeys> & {\n        nullable?: Types['DefaultNodeNullability'];\n    };\n    edgesFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, [\n        ObjectRef<Types, {}>\n    ], Types['DefaultEdgesNullability'], {}, unknown[]>, 'args' | 'nullable' | 'type' | InferredFieldOptionKeys> & {\n        nullable?: Types['DefaultEdgesNullability'];\n    };\n    nodesFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, [\n        ObjectRef<Types, {}>\n    ], FieldNullability<[unknown]>, {}, unknown[]>, 'args' | 'type' | InferredFieldOptionKeys>;\n    pageInfoFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, OutputRef<PageInfoShape>, boolean, {}, PageInfoShape>, 'args' | 'type' | InferredFieldOptionKeys>;\n    hasNextPageFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, PageInfoShape, 'Boolean', boolean, {}, boolean>, 'args' | 'type' | InferredFieldOptionKeys>;\n    hasPreviousPageFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, PageInfoShape, 'Boolean', boolean, {}, boolean>, 'args' | 'type' | InferredFieldOptionKeys>;\n    startCursorFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, PageInfoShape, 'ID' | 'String', boolean, {}, string | null>, 'args' | 'type' | InferredFieldOptionKeys>;\n    endCursorFieldOptions: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, PageInfoShape, 'ID' | 'String', boolean, {}, string | null>, 'args' | 'type' | InferredFieldOptionKeys>;\n    beforeArgOptions: Omit<PothosSchemaTypes.InputObjectFieldOptions<Types, 'ID' | 'String', boolean>, 'required' | 'type'>;\n    afterArgOptions: Omit<PothosSchemaTypes.InputObjectFieldOptions<Types, 'ID' | 'String', boolean>, 'required' | 'type'>;\n    firstArgOptions: Omit<PothosSchemaTypes.InputObjectFieldOptions<Types, 'Int', boolean>, 'required' | 'type'>;\n    lastArgOptions: Omit<PothosSchemaTypes.InputObjectFieldOptions<Types, 'Int', boolean>, 'required' | 'type'>;\n    encodeGlobalID?: (typename: string, id: bigint | number | string, ctx: Types['Context']) => string;\n    decodeGlobalID?: (globalID: string, ctx: Types['Context']) => {\n        typename: string;\n        id: string;\n    };\n    defaultConnectionTypeOptions: Partial<PothosSchemaTypes.ObjectTypeOptions<Types, ConnectionShape<Types, unknown, false, true, true>>>;\n    defaultEdgeTypeOptions: Partial<PothosSchemaTypes.ObjectTypeOptions<Types, {\n        cursor: string;\n        node: unknown;\n    }>>;\n    defaultPayloadTypeOptions: Partial<PothosSchemaTypes.ObjectTypeOptions<Types, {}>>;\n    defaultMutationInputTypeOptions: Partial<Omit<PothosSchemaTypes.InputObjectTypeOptions<Types, {}>, 'fields'>>;\n    defaultConnectionFieldOptions?: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, OutputRef<ConnectionShape<Types, unknown, false, true, true>>, boolean, InputFieldsFromShape<Types, DefaultConnectionArguments, 'Arg'>, ConnectionShape<Types, unknown, false, true, true>>, 'args' | 'type' | InferredFieldOptionKeys>;\n    nodesOnConnection?: Omit<PothosSchemaTypes.ObjectFieldOptions<Types, {}, [\n        ObjectRef<Types, {}>\n    ], {\n        list: false;\n        items: Types['DefaultNodeNullability'];\n    }, {}, GlobalIDShape<Types> | string>, 'args' | 'nullable' | 'type' | InferredFieldOptionKeys> | boolean;\n}>;\nexport interface DefaultEdgesNullability {\n    list: true;\n    items: true;\n}\nexport interface PageInfoShape {\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n    startCursor?: string | null;\n    endCursor?: string | null;\n}\nexport interface GlobalIDShape<Types extends SchemaTypes> {\n    id: OutputShape<Types, 'ID'>;\n    type: OutputType<Types> | string;\n}\nexport type ArrayConnectionEdgesShape<Types extends SchemaTypes, T, NodeNullable extends boolean, EdgesNullable extends FieldNullability<[unknown]>> = ShapeFromListTypeParam<Types, [\n    ObjectRef<Types, {\n        cursor: string;\n        node: NodeNullable extends false ? T : T | null | undefined;\n    }>\n], EdgesNullable>;\nexport type ConnectionEdgesShape<Types extends SchemaTypes, T, NodeNullable extends boolean, EdgesNullable extends FieldNullability<[unknown]>> = ArrayConnectionEdgesShape<Types, T, NodeNullable, EdgesNullable> extends infer Edges ? Awaited<ListResolveValue<Edges, Edges extends readonly (infer Item)[] ? Item : never, unknown>> : never;\nexport interface ConnectionResultShape<Types extends SchemaTypes, T, EdgesNullable extends FieldNullability<[unknown]> = Types['DefaultEdgesNullability'], NodeNullable extends boolean = Types['DefaultNodeNullability']> {\n    pageInfo: MaybePromise<PageInfoShape>;\n    edges: MaybePromise<ConnectionEdgesShape<Types, T, NodeNullable, EdgesNullable>>;\n}\nexport interface ArrayConnectionResultShape<Types extends SchemaTypes, T, EdgesNullable extends FieldNullability<[unknown]> = Types['DefaultEdgesNullability'], NodeNullable extends boolean = Types['DefaultNodeNullability']> {\n    pageInfo: PageInfoShape;\n    edges: ArrayConnectionEdgesShape<Types, T, NodeNullable, EdgesNullable>;\n}\nexport type ConnectionShape<Types extends SchemaTypes, T, Nullable, EdgesNullable extends FieldNullability<[unknown]> = Types['DefaultEdgesNullability'], NodeNullable extends boolean = Types['DefaultNodeNullability'], ConnectionResult extends ConnectionResultShape<Types, T, EdgesNullable, NodeNullable> = ConnectionResultShape<Types, T, EdgesNullable, NodeNullable>> = (Nullable extends false ? never : null | undefined) | Merge<ConnectionResult & Types['Connection']>;\nexport type ArrayConnectionShape<Types extends SchemaTypes, T, Nullable, EdgesNullable extends FieldNullability<[unknown]> = Types['DefaultEdgesNullability'], NodeNullable extends boolean = Types['DefaultNodeNullability'], ConnectionResult extends ArrayConnectionResultShape<Types, T, EdgesNullable, NodeNullable> = ArrayConnectionResultShape<Types, T, EdgesNullable, NodeNullable>> = (Nullable extends false ? never : null | undefined) | (ConnectionResult & Types['Connection']);\nexport type ConnectionShapeFromBaseShape<Types extends SchemaTypes, Shape, Nullable extends boolean> = ConnectionShape<Types, Shape, Nullable>;\nexport type ConnectionShapeForType<Types extends SchemaTypes, Type extends OutputType<Types>, Nullable extends boolean, EdgeNullability extends FieldNullability<[unknown]>, NodeNullability extends boolean, ConnectionResult extends ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability> = ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability>> = ConnectionShape<Types, ShapeFromTypeParam<Types, Type, false>, Nullable, EdgeNullability, NodeNullability, ConnectionResult>;\nexport type ConnectionShapeFromResolve<Types extends SchemaTypes, Type extends OutputType<Types>, Nullable extends boolean, EdgeNullability extends FieldNullability<[unknown]>, NodeNullability extends boolean, Resolved, ConnectionResult extends ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability> = ConnectionResultShape<Types, ShapeFromTypeParam<Types, Type, false>, EdgeNullability, NodeNullability>> = Merge<Resolved extends Promise<infer T> ? NonNullable<T> extends ConnectionShapeForType<Types, Type, Nullable, EdgeNullability, NodeNullability> ? NonNullable<T> : ConnectionShapeForType<Types, Type, Nullable, EdgeNullability, NodeNullability, ConnectionResult> & NonNullable<T> : Resolved extends ConnectionShapeForType<Types, Type, Nullable, EdgeNullability, NodeNullability, ConnectionResult> ? NonNullable<Resolved> : ConnectionShapeForType<Types, Type, Nullable, EdgeNullability, NodeNullability, ConnectionResult> & NonNullable<Resolved>>;\nexport interface DefaultConnectionArguments extends PothosSchemaTypes.DefaultConnectionArguments {\n}\nexport type NodeBaseObjectOptionsForParam<Types extends SchemaTypes, Param extends ObjectParam<Types>, Interfaces extends InterfaceParam<Types>[]> = ObjectTypeOptions<Types, Param, ParentShape<Types, Param>, Interfaces>;\nexport type NodeRefOptions<Types extends SchemaTypes, T, P = T, IDShape = string> = {\n    id: Omit<FieldOptionsFromKind<Types, P, 'ID', false, {}, 'Object', OutputShape<Types, 'ID'>, MaybePromise<OutputShape<Types, 'ID'>>>, 'args' | 'nullable' | 'type'> & {\n        parse?: (id: string, ctx: Types['Context']) => IDShape;\n    };\n    brandLoadedObjects?: boolean;\n    loadOne?: (id: IDShape, context: Types['Context']) => MaybePromise<T | null | undefined>;\n    loadMany?: (ids: IDShape[], context: Types['Context']) => MaybePromise<readonly MaybePromise<T | null | undefined>[]>;\n    loadWithoutCache?: (id: IDShape, context: Types['Context'], info: GraphQLResolveInfo) => MaybePromise<T | null | undefined>;\n    loadManyWithoutCache?: (ids: IDShape[], context: Types['Context']) => MaybePromise<readonly MaybePromise<T | null | undefined>[]>;\n};\nexport type NodeObjectOptions<Types extends SchemaTypes, Param extends ObjectParam<Types>, Interfaces extends InterfaceParam<Types>[], IDShape = string> = NodeBaseObjectOptionsForParam<Types, Param, Interfaces> & NodeRefOptions<Types, OutputShape<Types, Param>, ParentShape<Types, Param>, IDShape>;\nexport type GlobalIDFieldOptions<Types extends SchemaTypes, ParentShape, Args extends InputFieldMap, Nullable extends boolean, ResolveReturnShape, Kind extends FieldKind = FieldKind> = Omit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, Args, Kind, ParentShape, ResolveReturnShape>, 'type' | InferredFieldOptionKeys> & {\n    resolve: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, OutputRefShape<GlobalIDShape<Types> | string>, true>, ResolveReturnShape>;\n};\nexport type GlobalIDInputFieldOptions<Types extends SchemaTypes, Req extends boolean, Kind extends 'Arg' | 'InputObject', For = unknown> = Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, 'ID', Req>[Kind], 'type'> & {\n    for?: For | For[];\n};\nexport type GlobalIDListInputFieldOptions<Types extends SchemaTypes, Req extends FieldRequiredness<['ID']>, Kind extends 'Arg' | 'InputObject', For = unknown> = Omit<PothosSchemaTypes.InputFieldOptionsByKind<Types, ['ID'], Req>[Kind], 'type'> & {\n    for?: For | For[];\n};\nexport type NodeIDFieldOptions<Types extends SchemaTypes, ParentShape, Args extends InputFieldMap, Nullable extends boolean, ResolveReturnShape, Kind extends FieldKind = FieldKind> = Omit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, Args, Kind, ParentShape, ResolveReturnShape>, 'type' | InferredFieldOptionKeys> & {\n    resolve: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, OutputRefShape<GlobalIDShape<Types> | string>, true>, ResolveReturnShape>;\n};\nexport type GlobalIDListFieldOptions<Types extends SchemaTypes, ParentShape, Args extends InputFieldMap, Nullable extends FieldNullability<[unknown]>, ResolveReturnShape, Kind extends FieldKind = FieldKind> = Omit<FieldOptionsFromKind<Types, ParentShape, [\n    'ID'\n], Nullable, Args, Kind, ParentShape, ResolveReturnShape>, 'type' | InferredFieldOptionKeys> & {\n    resolve: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, [\n        OutputRefShape<GlobalIDShape<Types> | string>\n    ], {\n        list: false;\n        items: true;\n    }>, ResolveReturnShape>;\n};\nexport type NodeFieldOptions<Types extends SchemaTypes, ParentShape, Args extends InputFieldMap, ResolveReturnShape, Kind extends FieldKind = FieldKind> = Omit<FieldOptionsFromKind<Types, ParentShape, OutputRefShape<GlobalIDShape<Types> | string>, true, Args, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys> & {\n    id: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, OutputRefShape<GlobalIDShape<Types> | string>, true>, ResolveReturnShape>;\n};\nexport type NodeListFieldOptions<Types extends SchemaTypes, ParentShape, Args extends InputFieldMap, ResolveReturnShape, Kind extends FieldKind = FieldKind> = Omit<FieldOptionsFromKind<Types, ParentShape, [\n    OutputRefShape<GlobalIDShape<Types> | string>\n], {\n    list: false;\n    items: true;\n}, Args, Kind, ParentShape, ResolveReturnShape>, 'nullable' | 'type' | InferredFieldOptionKeys> & {\n    ids: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, [\n        OutputRefShape<GlobalIDShape<Types> | string>\n    ], {\n        list: false;\n        items: true;\n    }>, ResolveReturnShape>;\n};\nexport interface GlobalIDInputShape<T = string> {\n    [inputShapeKey]: {\n        typename: string;\n        id: T;\n    };\n}\nexport type RelayMutationInputOptions<Types extends SchemaTypes, Fields extends InputFieldMap, InputName extends string> = Omit<PothosSchemaTypes.InputObjectTypeOptions<Types, Fields>, 'fields'> & {\n    name?: string;\n    argName?: InputName;\n    inputFields: (t: PothosSchemaTypes.InputFieldBuilder<Types, 'InputObject'>) => Fields;\n};\nexport type RelayMutationFieldOptions<Types extends SchemaTypes, Fields extends InputFieldMap, Nullable extends boolean, InputName extends string, ResolveShape, ResolveReturnShape, Args extends InputFieldMap = {}> = DistributeOmit<FieldOptionsFromKind<Types, Types['Root'], OutputRef<ResolveShape>, Nullable, Args & {\n    [K in InputName]: ArgumentRef<Types, InputShapeWithClientMutationId<Types, Fields>>;\n}, 'Mutation', ResolveShape, ResolveReturnShape>, 'args' | 'type'> & {\n    args?: Args;\n};\nexport type RelayMutationPayloadOptions<Types extends SchemaTypes, Shape, Interfaces extends InterfaceParam<Types>[]> = Omit<PothosSchemaTypes.ObjectTypeOptions<Types, Shape> | PothosSchemaTypes.ObjectTypeWithInterfaceOptions<Types, Shape, Interfaces>, 'fields'> & {\n    name?: string;\n    outputFields: ObjectFieldsShape<Types, Shape>;\n};\nexport type InputShapeWithClientMutationId<Types extends SchemaTypes, Fields extends InputFieldMap> = InputShapeFromFields<Fields & {\n    clientMutationId: InputFieldRef<Types, Types['Scalars']['ID']['Input']>;\n}>;\nexport type GetAwaitedListItem<T> = NonNullable<Awaited<NonNullable<T>>> extends infer List ? List extends Iterable<infer Item> ? NonNullable<Awaited<Item>> : List extends AsyncIterable<infer Item> ? unknown extends AsyncIterable<unknown> ? never : NonNullable<Item> : never : never;\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/utils/add-node-props",
      "content": "declare module '@pothos/plugin-relay/utils/add-node-props' {\nimport { type ObjectParam, type ObjectRef, type SchemaTypes } from '@pothos/core';\nimport type { NodeRefOptions } from '@pothos/plugin-relay/types';\nexport declare function addNodeProperties<Types extends SchemaTypes, T, P = T, IDShape = string>(name: string, builder: PothosSchemaTypes.SchemaBuilder<Types>, ref: ObjectRef<Types, unknown>, param: ObjectParam<Types> | undefined, options: NodeRefOptions<Types, T, P, IDShape>): void;\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/utils/connections",
      "content": "declare module '@pothos/plugin-relay/utils/connections' {\nimport { type MaybePromise, type Merge, type SchemaTypes } from '@pothos/core';\nimport type { ArrayConnectionShape, DefaultConnectionArguments } from '@pothos/plugin-relay/types';\ninterface ResolveOffsetConnectionOptions {\n    args: DefaultConnectionArguments;\n    defaultSize?: number;\n    maxSize?: number;\n    totalCount?: number;\n}\nexport interface ResolveCursorConnectionOptions<T> {\n    args: DefaultConnectionArguments;\n    defaultSize?: number;\n    maxSize?: number;\n    toCursor: (value: T, nodes: T[]) => string;\n}\nexport interface ResolveCursorConnectionArgs {\n    before?: string;\n    after?: string;\n    limit: number;\n    inverted: boolean;\n}\ninterface ResolveArrayConnectionOptions {\n    args: DefaultConnectionArguments;\n    defaultSize?: number;\n    maxSize?: number;\n}\nexport declare function offsetForArgs(options: ResolveOffsetConnectionOptions): {\n    offset: number;\n    limit: number;\n    hasPreviousPage: boolean;\n    expectedSize: number;\n    hasNextPage: (resultSize: number) => boolean;\n};\nexport declare function resolveOffsetConnection<T, U extends Promise<readonly T[] | null> | readonly T[] | null, C extends number | undefined = undefined>(options: ResolveOffsetConnectionOptions & {\n    totalCount?: C;\n}, resolve: (params: {\n    offset: number;\n    limit: number;\n}) => U & (MaybePromise<readonly T[] | null> | null)): Promise<Merge<ArrayConnectionShape<SchemaTypes, NonNullable<T>, U extends NonNullable<U> ? (Promise<null> extends U ? true : false) : true, T extends NonNullable<T> ? false : {\n    list: false;\n    items: true;\n}, false> & {\n    totalCount: C;\n}>>;\nexport declare function cursorToOffset(cursor: string): number;\nexport declare function offsetToCursor(offset: number): string;\nexport declare function resolveArrayConnection<T>(options: ResolveArrayConnectionOptions, array: readonly T[]): Merge<ArrayConnectionShape<SchemaTypes, NonNullable<T>, false, T extends NonNullable<T> ? false : {\n    list: false;\n    items: true;\n}, false> & {\n    totalCount: number;\n}>;\nexport declare function parseCursorConnectionArgs(options: ResolveOffsetConnectionOptions): {\n    before: string | undefined;\n    after: string | undefined;\n    limit: number;\n    expectedSize: number;\n    inverted: boolean;\n    hasPreviousPage: (resultSize: number) => boolean;\n    hasNextPage: (resultSize: number) => boolean;\n};\ntype NodeType<T> = T extends (infer N)[] | Promise<(infer N)[] | null> | null ? N : never;\nexport declare function resolveCursorConnection<U extends Promise<readonly unknown[] | null> | readonly unknown[] | null>(options: ResolveCursorConnectionOptions<NodeType<U>>, resolve: (params: ResolveCursorConnectionArgs) => U): Promise<Merge<ArrayConnectionShape<SchemaTypes, NodeType<U>, false, false, false>>>;\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/utils/global-ids",
      "content": "declare module '@pothos/plugin-relay/utils/global-ids' {\nexport declare function encodeGlobalID(typename: string, id: bigint | number | string): string;\nexport declare function decodeGlobalID(globalID: string): {\n    typename: string;\n    id: string;\n};\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/utils",
      "content": "declare module '@pothos/plugin-relay/utils' {\nexport * from '@pothos/plugin-relay/utils/connections';\nexport * from '@pothos/plugin-relay/utils/global-ids';\nexport * from '@pothos/plugin-relay/utils/resolve-nodes';\nexport declare function capitalize(s: string): string;\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/utils/internal",
      "content": "declare module '@pothos/plugin-relay/utils/internal' {\nimport { type PartialResolveInfo, type SchemaTypes } from '@pothos/core';\nexport declare function internalEncodeGlobalID<Types extends SchemaTypes>(builder: PothosSchemaTypes.SchemaBuilder<Types>, typename: string, id: bigint | number | string, ctx: object): string;\nexport declare function internalDecodeGlobalID<Types extends SchemaTypes>(builder: PothosSchemaTypes.SchemaBuilder<Types>, globalID: string, ctx: object, info: PartialResolveInfo, parseIdsForTypes: {\n    typename: string;\n    parseId: (id: string, ctx: object) => unknown;\n}[] | boolean): {\n    id: unknown;\n    typename: string;\n};\n}"
    },
    {
      "moduleName": "@pothos/plugin-relay/utils/resolve-nodes",
      "content": "declare module '@pothos/plugin-relay/utils/resolve-nodes' {\nimport { type MaybePromise, type OutputType, type SchemaTypes } from '@pothos/core';\nimport type { GraphQLResolveInfo } from 'graphql';\nexport declare function resolveNodes<Types extends SchemaTypes>(builder: PothosSchemaTypes.SchemaBuilder<Types>, context: object, info: GraphQLResolveInfo, globalIDs: ({\n    id: unknown;\n    typename: string;\n} | null | undefined)[]): Promise<MaybePromise<unknown>[]>;\nexport declare function resolveUncachedNodesForType<Types extends SchemaTypes>(builder: PothosSchemaTypes.SchemaBuilder<Types>, context: object, info: GraphQLResolveInfo, ids: readonly unknown[], type: OutputType<Types> | string): Promise<unknown[]>;\n}"
    }
  ],
  "@pothos/plugin-with-input": [
    {
      "moduleName": "@pothos/plugin-with-input/global-types",
      "content": "import type { FieldKind, FieldNullability, InputFieldMap, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core';\nimport type { PothosWithInputPlugin } from '.';\nimport type { FieldWithInputOptions, WithInputArgOptions, WithInputBuilderOptions, WithInputTypeOptions } from '@pothos/plugin-with-input/types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface UserSchemaTypes {\n            WithInputArgRequired: boolean;\n        }\n        interface ExtendDefaultTypes<PartialTypes extends Partial<UserSchemaTypes>> {\n            WithInputArgRequired: boolean extends PartialTypes['WithInputArgRequired'] ? true : PartialTypes['WithInputArgRequired'] & boolean;\n        }\n        interface Plugins<Types extends SchemaTypes> {\n            withInput: PothosWithInputPlugin<Types>;\n        }\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            withInput?: WithInputBuilderOptions<Types>;\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> {\n            input: InputFieldBuilder<Types, 'InputObject'>;\n            fieldWithInput: <Fields extends InputFieldMap, Type extends TypeParam<Types>, ResolveShape, ResolveReturnShape, ArgRequired extends boolean, Args extends InputFieldMap = {}, Nullable extends FieldNullability<Type> = Types['DefaultFieldNullability'], InputName extends string = 'input'>(options: FieldWithInputOptions<Types, ParentShape, Kind, Args, Fields, Type, Nullable, InputName, ResolveShape, ResolveReturnShape, boolean extends ArgRequired ? Types['WithInputArgRequired'] & boolean : ArgRequired>) => FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>>;\n        }\n        interface FieldWithInputBaseOptions<Types extends SchemaTypes, Args extends InputFieldMap, Fields extends InputFieldMap, InputName extends string, ArgRequired extends boolean> {\n            typeOptions?: WithInputTypeOptions<Types, Fields>;\n            argOptions?: WithInputArgOptions<Types, Fields, InputName, ArgRequired>;\n            input: Fields;\n            args?: Args;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-with-input",
      "content": "declare module '@pothos/plugin-with-input' {\nimport '@pothos/plugin-with-input/global-types';\nimport '@pothos/plugin-with-input/schema-builder';\nimport { BasePlugin, type SchemaTypes } from '@pothos/core';\nexport * from '@pothos/plugin-with-input/types';\ndeclare const pluginName = \"withInput\";\nexport default pluginName;\nexport declare class PothosWithInputPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-with-input/schema-builder",
      "content": "declare module '@pothos/plugin-with-input/schema-builder' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-with-input/types",
      "content": "declare module '@pothos/plugin-with-input/types' {\nimport type { DistributeOmit, FieldKind, FieldNullability, FieldOptionsFromKind, InputFieldMap, InputFieldRef, InputRef, InputShapeFromFields, SchemaTypes, TypeParam } from '@pothos/core';\nexport interface WithInputBuilderOptions<Types extends SchemaTypes> {\n    argOptions?: Omit<PothosSchemaTypes.ArgFieldOptions<Types, InputRef<{}>, true>, 'required' | 'type'> & {\n        required?: Types['WithInputArgRequired'];\n    };\n    typeOptions?: Omit<PothosSchemaTypes.InputObjectTypeOptions<Types, {}>, 'fields'> & {\n        name?: (options: {\n            parentTypeName: string;\n            fieldName: string;\n        }) => string;\n    };\n}\nexport type WithInputInputOptions<Types extends SchemaTypes, Fields extends InputFieldMap, InputName extends string> = Omit<PothosSchemaTypes.InputObjectTypeOptions<Types, Fields>, 'fields'> & {\n    name?: string;\n    argName?: InputName;\n    inputFields: (t: PothosSchemaTypes.InputFieldBuilder<Types, 'InputObject'>) => Fields;\n};\nexport type WithInputTypeOptions<Types extends SchemaTypes, Fields extends InputFieldMap> = Omit<PothosSchemaTypes.InputObjectTypeOptions<Types, Fields>, 'fields'> & {\n    name?: string;\n};\nexport type WithInputArgOptions<Types extends SchemaTypes, Fields extends InputFieldMap, InputName, ArgRequired extends boolean> = Omit<PothosSchemaTypes.ArgFieldOptions<Types, InputRef<InputShapeFromFields<Fields>>, ArgRequired>, 'type'> & {\n    name?: InputName;\n};\nexport type FieldWithInputOptions<Types extends SchemaTypes, ParentShape, Kind extends FieldKind, Args extends InputFieldMap, Fields extends InputFieldMap, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, InputName extends string, ResolveShape, ResolveReturnShape, ArgRequired extends boolean> = DistributeOmit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, Args & {\n    [K in InputName]: InputFieldRef<Types, InputShapeFromFields<Fields> | (true extends ArgRequired ? never : null | undefined)>;\n}, Kind, ResolveShape, ResolveReturnShape>, 'args'> & {\n    typeOptions?: WithInputTypeOptions<Types, Fields>;\n    argOptions?: WithInputArgOptions<Types, Fields, InputName, ArgRequired>;\n    input: Fields;\n    args?: Args;\n};\n}"
    }
  ],
  "@pothos/plugin-scope-auth": [
    {
      "moduleName": "@pothos/plugin-scope-auth/errors",
      "content": "declare module '@pothos/plugin-scope-auth/errors' {\nimport { PothosValidationError } from '@pothos/core';\nimport type { AuthFailure } from '.';\nexport declare class ForbiddenError extends PothosValidationError {\n    code: string;\n    result: AuthFailure;\n    constructor(message: string, result?: AuthFailure);\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/field-builders",
      "content": "declare module '@pothos/plugin-scope-auth/field-builders' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/global-types",
      "content": "import type { FieldKind, FieldNullability, FieldOptionsFromKind, InferredFieldOptionKeys, InputFieldMap, InputShapeFromFields, MaybePromise, Normalize, Resolver, RootName, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core';\nimport type { PothosScopeAuthPlugin } from '.';\nimport type { AuthScopeMap, ContextForAuth, FieldAuthScopes, FieldGrantScopes, ForbiddenResult, ReplaceContext, ScopeAuthInitializer, ScopeAuthPluginOptions, TypeAuthScopes, TypeGrantScopes, UnauthorizedOptions } from '@pothos/plugin-scope-auth/types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface Plugins<Types extends SchemaTypes> {\n            scopeAuth: PothosScopeAuthPlugin<Types>;\n        }\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            scopeAuth: ScopeAuthPluginOptions<Types>;\n        }\n        interface V3SchemaBuilderOptions<Types extends SchemaTypes> {\n            scopeAuth: never;\n            scopeAuthOptions?: Omit<ScopeAuthPluginOptions<Types>, 'authScopes'>;\n            authScopes: ScopeAuthInitializer<Types>;\n        }\n        interface SchemaBuilder<Types extends SchemaTypes> {\n            runAuthScopes: (context: Types['Context'], scopes: AuthScopeMap<Types>, unauthorizedError?: (result: ForbiddenResult) => Error | string) => MaybePromise<void>;\n        }\n        interface BuildSchemaOptions<Types extends SchemaTypes> {\n            disableScopeAuth?: boolean;\n        }\n        interface UserSchemaTypes {\n            AuthScopes: {};\n            AuthContexts: {};\n            DefaultAuthStrategy: 'all' | 'any';\n        }\n        interface ExtendDefaultTypes<PartialTypes extends Partial<UserSchemaTypes>> {\n            AuthScopes: PartialTypes['AuthScopes'] & {};\n            AuthContexts: PartialTypes['AuthContexts'] & {};\n            DefaultAuthStrategy: undefined extends PartialTypes['DefaultAuthStrategy'] ? 'any' : PartialTypes['DefaultAuthStrategy'] & string;\n        }\n        interface RootTypeOptions<Types extends SchemaTypes, Type extends RootName> {\n            authScopes?: TypeAuthScopes<Types, Types['Root']>;\n            grantScopes?: TypeGrantScopes<Types, Types['Root']>;\n        }\n        interface ObjectTypeOptions<Types extends SchemaTypes, Shape> {\n            authScopes?: TypeAuthScopes<Types, Shape>;\n            grantScopes?: TypeGrantScopes<Types, Shape>;\n            runScopesOnType?: boolean;\n            skipInterfaceScopes?: boolean;\n        }\n        interface InterfaceTypeOptions<Types extends SchemaTypes, Shape> {\n            authScopes?: TypeAuthScopes<Types, Shape>;\n            grantScopes?: TypeGrantScopes<Types, Shape>;\n            runScopesOnType?: boolean;\n        }\n        interface FieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> extends UnauthorizedOptions<Types, ParentShape, Type, Nullable, Args> {\n            authScopes?: FieldAuthScopes<Types, ParentShape, InputShapeFromFields<Args>>;\n            grantScopes?: FieldGrantScopes<Types, ParentShape, InputShapeFromFields<Args>>;\n            skipTypeScopes?: boolean;\n        }\n        interface ObjectFieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, ParentShape, Type, Nullable, Args, ParentShape, ResolveReturnShape> {\n            skipInterfaceScopes?: boolean;\n        }\n        interface InterfaceFieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveReturnShape> extends FieldOptions<Types, ParentShape, Type, Nullable, Args, ParentShape, ResolveReturnShape> {\n            skipInterfaceScopes?: boolean;\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> {\n            authField: <Args extends InputFieldMap, Type extends TypeParam<Types>, Scopes extends FieldAuthScopes<Types, ParentShape, InputShapeFromFields<Args>>, ResolveShape, ResolveReturnShape, Nullable extends FieldNullability<Type> = Types['DefaultFieldNullability']>(options: Normalize<Omit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, InferredFieldOptionKeys> & {\n                authScopes: Scopes;\n                resolve: Resolver<ParentShape, InputShapeFromFields<Args>, ContextForAuth<Types, Scopes>, ShapeFromTypeParam<Types, Type, Nullable>, ResolveReturnShape>;\n            }>) => FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n        }\n        interface QueryFieldBuilder<Types extends SchemaTypes, ParentShape> {\n            withAuth: <Scopes extends FieldAuthScopes<Types, ParentShape, Record<string, unknown>>>(scopes: Scopes) => QueryFieldBuilder<ReplaceContext<Types, ContextForAuth<Types, Scopes> & object>, ParentShape>;\n        }\n        interface MutationFieldBuilder<Types extends SchemaTypes, ParentShape> {\n            withAuth: <Scopes extends FieldAuthScopes<Types, ParentShape, Record<string, unknown>>>(scopes: Scopes) => MutationFieldBuilder<ReplaceContext<Types, ContextForAuth<Types, Scopes> & object>, ParentShape>;\n        }\n        interface SubscriptionFieldBuilder<Types extends SchemaTypes, ParentShape> {\n            withAuth: <Scopes extends FieldAuthScopes<Types, ParentShape, Record<string, unknown>>>(scopes: Scopes) => SubscriptionFieldBuilder<ReplaceContext<Types, ContextForAuth<Types, Scopes> & object>, ParentShape>;\n        }\n        interface ObjectFieldBuilder<Types extends SchemaTypes, ParentShape> {\n            withAuth: <Scopes extends FieldAuthScopes<Types, ParentShape, Record<string, unknown>>>(scopes: Scopes) => ObjectFieldBuilder<ReplaceContext<Types, ContextForAuth<Types, Scopes> & object>, ParentShape>;\n        }\n        interface InterfaceFieldBuilder<Types extends SchemaTypes, ParentShape> {\n            withAuth: <Scopes extends FieldAuthScopes<Types, ParentShape, Record<string, unknown>>>(scopes: Scopes) => InterfaceFieldBuilder<ReplaceContext<Types, ContextForAuth<Types, Scopes> & object>, ParentShape>;\n        }\n        interface ScopeAuthFieldAuthScopes<Types extends SchemaTypes, Parent, Args extends {} = {}> {\n            Scopes: FieldAuthScopes<Types, Parent, Args>;\n        }\n        interface ScopeAuthContextForAuth<Types extends SchemaTypes, Scopes extends {}> {\n            Context: ContextForAuth<Types, Scopes>;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth",
      "content": "declare module '@pothos/plugin-scope-auth' {\nimport '@pothos/plugin-scope-auth/global-types';\nimport '@pothos/plugin-scope-auth/schema-builder';\nimport '@pothos/plugin-scope-auth/field-builders';\nimport { BasePlugin, type PothosInterfaceTypeConfig, type PothosMutationTypeConfig, type PothosObjectTypeConfig, type PothosOutputFieldConfig, type PothosQueryTypeConfig, type PothosSubscriptionTypeConfig, type SchemaTypes } from '@pothos/core';\nimport type { GraphQLFieldResolver, GraphQLIsTypeOfFn, GraphQLTypeResolver } from 'graphql';\nimport RequestCache from '@pothos/plugin-scope-auth/request-cache';\nimport type { ResolveStep } from '@pothos/plugin-scope-auth/types';\nexport { RequestCache };\nexport * from '@pothos/plugin-scope-auth/errors';\nexport * from '@pothos/plugin-scope-auth/types';\ndeclare const pluginName = \"scopeAuth\";\nexport default pluginName;\nexport declare class PothosScopeAuthPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n    wrapResolve(resolver: GraphQLFieldResolver<unknown, Types['Context'], object>, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    wrapSubscribe(subscriber: GraphQLFieldResolver<unknown, Types['Context'], object>, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    wrapResolveType(resolveType: GraphQLTypeResolver<unknown, Types['Context']>): GraphQLTypeResolver<unknown, Types['Context']>;\n    wrapIsTypeOf(isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined, typeConfig: PothosObjectTypeConfig): GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined;\n    createStepsForType(typeConfig: PothosInterfaceTypeConfig | PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig, { skipTypeScopes, skipInterfaceScopes, forField, }: {\n        skipTypeScopes?: boolean;\n        skipInterfaceScopes?: boolean;\n        forField: boolean;\n    }): ResolveStep<Types>[];\n    createResolveSteps(fieldConfig: PothosOutputFieldConfig<Types>, typeConfig: PothosInterfaceTypeConfig | PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig, resolver: GraphQLFieldResolver<unknown, Types['Context'], object>, shouldRunTypeScopes: boolean, authorizedOnSubscribe: boolean): ResolveStep<Types>[];\n    createSubscribeSteps(fieldConfig: PothosOutputFieldConfig<Types>, typeConfig: PothosInterfaceTypeConfig | PothosMutationTypeConfig | PothosObjectTypeConfig | PothosQueryTypeConfig | PothosSubscriptionTypeConfig, subscriber: GraphQLFieldResolver<unknown, Types['Context'], object>): ResolveStep<Types>[];\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/is-type-of-helper",
      "content": "declare module '@pothos/plugin-scope-auth/is-type-of-helper' {\nimport { type MaybePromise, type SchemaTypes } from '@pothos/core';\nimport type { GraphQLIsTypeOfFn, GraphQLResolveInfo } from 'graphql';\nimport type { PothosScopeAuthPlugin, ResolveStep } from '.';\nexport declare function isTypeOfHelper<Types extends SchemaTypes>(steps: ResolveStep<Types>[], plugin: PothosScopeAuthPlugin<Types>, isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined): (parent: unknown, context: Types[\"Context\"], info: GraphQLResolveInfo) => MaybePromise<boolean>;\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/request-cache",
      "content": "declare module '@pothos/plugin-scope-auth/request-cache' {\nimport { type MaybePromise, type Path, type SchemaTypes } from '@pothos/core';\nimport type { GraphQLResolveInfo } from 'graphql';\nimport { type AuthFailure, type AuthScopeMap, type ScopeLoaderMap, type TypeAuthScopesFunction } from '@pothos/plugin-scope-auth/types';\nexport default class RequestCache<Types extends SchemaTypes> {\n    builder: PothosSchemaTypes.SchemaBuilder<Types>;\n    context: Types[\"Context\"];\n    mapCache: Map<{}, MaybePromise<AuthFailure | null>>;\n    scopeCache: Map<keyof Types[\"AuthScopes\"], Map<unknown, MaybePromise<AuthFailure | null>>>;\n    typeCache: Map<string, Map<unknown, MaybePromise<AuthFailure | null>>>;\n    typeGrants: Map<string, Map<unknown, MaybePromise<null>>>;\n    grantCache: Map<string, Set<string>>;\n    scopes?: MaybePromise<ScopeLoaderMap<Types>>;\n    cacheKey?: (value: unknown) => unknown;\n    treatErrorsAsUnauthorized: boolean;\n    defaultStrategy: 'all' | 'any';\n    constructor(builder: PothosSchemaTypes.SchemaBuilder<Types>, context: Types['Context']);\n    static fromContext<T extends SchemaTypes>(context: T['Context'], builder: PothosSchemaTypes.SchemaBuilder<T>): RequestCache<T>;\n    static clearForContext<T extends SchemaTypes>(context: T['Context']): void;\n    getScopes(): MaybePromise<ScopeLoaderMap<Types>>;\n    withScopes<T>(cb: (scopes: ScopeLoaderMap<Types>) => MaybePromise<T>): MaybePromise<T>;\n    saveGrantedScopes(scopes: readonly string[], path: Path | undefined): null;\n    testGrantedScopes(scope: string, path: Path): boolean;\n    grantTypeScopes(type: string, parent: unknown, path: Path | undefined, cb: () => MaybePromise<readonly string[]>): Promise<null>;\n    evaluateScopeLoader<T extends keyof Types['AuthScopes']>(scopes: ScopeLoaderMap<Types>, name: T, arg: Types['AuthScopes'][T]): import(\"./types\").AllAuthScopesFailure | import(\"./types\").AnyAuthScopesFailure | import(\"./types\").AuthScopeFailure | import(\"./types\").AuthScopeFunctionFailure | import(\"./types\").GrantedScopeFailure | import(\"./types\").UnknownAuthFailure | Promise<AuthFailure | null>;\n    evaluateScopeMapWithScopes({ $all, $any, $granted, ...map }: AuthScopeMap<Types>, scopes: ScopeLoaderMap<Types>, info: GraphQLResolveInfo | undefined, forAll: boolean): MaybePromise<AuthFailure | null>;\n    evaluateScopeMap(map: AuthScopeMap<Types> | boolean, info?: GraphQLResolveInfo, forAll?: boolean): MaybePromise<AuthFailure | null>;\n    evaluateTypeScopeFunction(authScopes: TypeAuthScopesFunction<Types, unknown>, type: string, parent: unknown, info: GraphQLResolveInfo): import(\"./types\").AllAuthScopesFailure | import(\"./types\").AnyAuthScopesFailure | import(\"./types\").AuthScopeFailure | import(\"./types\").AuthScopeFunctionFailure | import(\"./types\").GrantedScopeFailure | import(\"./types\").UnknownAuthFailure | Promise<AuthFailure | null>;\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/resolve-helper",
      "content": "declare module '@pothos/plugin-scope-auth/resolve-helper' {\nimport { type PothosOutputFieldConfig, type SchemaTypes } from '@pothos/core';\nimport type { GraphQLResolveInfo } from 'graphql';\nimport type { PothosScopeAuthPlugin } from '.';\nimport { type ResolveStep } from '@pothos/plugin-scope-auth/types';\nexport declare function resolveHelper<Types extends SchemaTypes>(steps: ResolveStep<Types>[], plugin: PothosScopeAuthPlugin<Types>, fieldConfig: PothosOutputFieldConfig<Types>): (parent: unknown, args: {}, context: Types[\"Context\"], info: GraphQLResolveInfo) => unknown;\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/schema-builder",
      "content": "declare module '@pothos/plugin-scope-auth/schema-builder' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/steps",
      "content": "declare module '@pothos/plugin-scope-auth/steps' {\nimport { type SchemaTypes } from '@pothos/core';\nimport type { GraphQLFieldResolver } from 'graphql';\nimport type { FieldAuthScopes, FieldGrantScopes, ResolveStep, TypeAuthScopes, TypeGrantScopes } from '@pothos/plugin-scope-auth/types';\nexport declare function createTypeAuthScopesStep<Types extends SchemaTypes>(authScopes: TypeAuthScopes<Types, unknown>, type: string): ResolveStep<Types>;\nexport declare function createTypeGrantScopesStep<Types extends SchemaTypes>(grantScopes: TypeGrantScopes<Types, unknown>, type: string, forField: boolean): ResolveStep<Types>;\nexport declare function createFieldAuthScopesStep<Types extends SchemaTypes>(authScopes: FieldAuthScopes<Types, {}, {}>): ResolveStep<Types>;\nexport declare function createFieldGrantScopesStep<Types extends SchemaTypes>(grantScopes: FieldGrantScopes<Types, {}, {}>): ResolveStep<Types>;\nexport declare function createResolveStep<Types extends SchemaTypes>(resolver: GraphQLFieldResolver<unknown, Types['Context'], object>): ResolveStep<Types>;\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/types",
      "content": "declare module '@pothos/plugin-scope-auth/types' {\nimport type { FieldNullability, InputFieldMap, InputShapeFromFields, MaybePromise, Merge, SchemaTypes, ShapeFromTypeParam, TypeParam, UnionToIntersection } from '@pothos/core';\nimport type { GraphQLResolveInfo } from 'graphql';\nimport type RequestCache from '@pothos/plugin-scope-auth/request-cache';\nexport interface ScopeAuthPluginOptions<Types extends SchemaTypes> {\n    unauthorizedError?: UnauthorizedForTypeErrorFn<Types, {}>;\n    cacheKey?: (value: unknown) => unknown;\n    runScopesOnType?: boolean;\n    treatErrorsAsUnauthorized?: boolean;\n    authorizeOnSubscribe?: boolean;\n    defaultStrategy?: Types['DefaultAuthStrategy'];\n    authScopes: ScopeAuthInitializer<Types>;\n}\nexport interface BuiltInScopes<Types extends SchemaTypes> {\n    $all?: true extends true ? AuthScopeMap<Types> : never;\n    $any?: true extends true ? AuthScopeMap<Types> : never;\n    $granted?: string;\n}\nexport type AuthScopeMap<Types extends SchemaTypes> = Merge<BuiltInScopes<Types> & Partial<Types['AuthScopes']>>;\nexport type ScopeLoaderMap<Types extends SchemaTypes> = {\n    [K in keyof Types['AuthScopes']]: boolean | ((param: Types['AuthScopes'][K]) => MaybePromise<boolean>);\n};\nexport type ScopeAuthInitializer<Types extends SchemaTypes> = (context: Types['Context']) => MaybePromise<ScopeLoaderMap<Types>>;\nexport type TypeAuthScopesFunction<Types extends SchemaTypes, Parent> = (parent: Parent, context: Types['Context']) => MaybePromise<AuthScopeMap<Types> | boolean>;\nexport type TypeAuthScopes<Types extends SchemaTypes, Parent> = AuthScopeMap<Types> | TypeAuthScopesFunction<Types, Parent>;\nexport type FieldAuthScopes<Types extends SchemaTypes, Parent, Args extends {}> = AuthScopeMap<Types> | ((parent: Parent, args: Args, context: Types['Context'], info: GraphQLResolveInfo) => MaybePromise<AuthScopeMap<Types> | boolean>);\nexport type TypeGrantScopes<Types extends SchemaTypes, Parent> = (parent: Parent, context: Types['Context']) => MaybePromise<readonly string[]>;\nexport type FieldGrantScopes<Types extends SchemaTypes, Parent, Args extends {}> = string[] | ((parent: Parent, args: Args, context: Types['Context'], info: GraphQLResolveInfo) => MaybePromise<readonly string[]>);\nexport declare enum AuthScopeFailureType {\n    AuthScope = \"AuthScope\",\n    AuthScopeFunction = \"AuthScopeFunction\",\n    GrantedScope = \"GrantedScope\",\n    AnyAuthScopes = \"AnyAuthScopes\",\n    AllAuthScopes = \"AllAuthScopes\",\n    Unknown = \"Unknown\"\n}\nexport interface AuthScopeFailure {\n    kind: AuthScopeFailureType.AuthScope;\n    scope: string;\n    parameter: unknown;\n    error: Error | null;\n}\nexport interface AuthScopeFunctionFailure {\n    kind: AuthScopeFailureType.AuthScopeFunction;\n    error: Error | null;\n}\nexport interface UnknownAuthFailure {\n    kind: AuthScopeFailureType.Unknown;\n}\nexport interface AnyAuthScopesFailure {\n    kind: AuthScopeFailureType.AnyAuthScopes;\n    failures: AuthFailure[];\n}\nexport interface AllAuthScopesFailure {\n    kind: AuthScopeFailureType.AllAuthScopes;\n    failures: AuthFailure[];\n}\nexport interface GrantedScopeFailure {\n    kind: AuthScopeFailureType.GrantedScope;\n    scope: string;\n}\nexport type AuthFailure = AllAuthScopesFailure | AnyAuthScopesFailure | AuthScopeFailure | AuthScopeFunctionFailure | GrantedScopeFailure | UnknownAuthFailure;\nexport interface ForbiddenResult {\n    message: string;\n    failure: AuthFailure;\n}\nexport interface ResolveStep<Types extends SchemaTypes> {\n    run: (cache: RequestCache<Types>, parent: unknown, args: Record<string, unknown>, context: {}, info: GraphQLResolveInfo, setResolved: (val: unknown) => void) => MaybePromise<AuthFailure | null>;\n    errorMessage: string | ((parent: unknown, args: Record<string, unknown>, context: {}, info: GraphQLResolveInfo) => string);\n}\nexport type ContextForAuth<Types extends SchemaTypes, Scopes> = 'any' extends Types['DefaultAuthStrategy'] ? ContextForAuthUnion<Types, Scopes> : UnionToIntersection<ContextForAuthUnion<Types, Scopes>>;\ntype ContextForAuthUnion<Types extends SchemaTypes, Scopes> = Scopes extends (...args: any[]) => infer R ? ContextForAuthUnion<Types, R> : Scopes extends boolean ? Types['Context'] : keyof Scopes extends infer Scope ? Scope extends keyof Types['AuthContexts'] ? Types['AuthContexts'][Scope] : Scope extends '$any' ? ContextForAuthUnion<Types, Scopes[Scope & keyof Scopes]> : Scope extends '$all' ? UnionToIntersection<ContextForAuthUnion<Types, Scopes[Scope & keyof Scopes]>> : Types['Context'] : never;\nexport type UnauthorizedResolver<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap> = (parent: ParentShape, args: InputShapeFromFields<Args>, context: Types['Context'], info: GraphQLResolveInfo, error: Error) => MaybePromise<ShapeFromTypeParam<Types, Type, Nullable>>;\nexport type UnauthorizedErrorFn<Types extends SchemaTypes, ParentShape, Args extends InputFieldMap> = (parent: ParentShape, args: InputShapeFromFields<Args>, context: Types['Context'], info: GraphQLResolveInfo, result: ForbiddenResult) => Error | string;\nexport type UnauthorizedForTypeErrorFn<Types extends SchemaTypes, ParentShape> = (parent: ParentShape, context: Types['Context'], info: GraphQLResolveInfo, result: ForbiddenResult) => Error | string;\nexport interface UnauthorizedOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap> {\n    unauthorizedError?: UnauthorizedErrorFn<Types, ParentShape, Args>;\n    unauthorizedResolver?: UnauthorizedResolver<Types, ParentShape, Type, Nullable, Args>;\n}\nexport type ReplaceContext<Types extends SchemaTypes, Context extends object> = Omit<Types, 'Context'> & {\n    Context: Context;\n};\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-scope-auth/util",
      "content": "declare module '@pothos/plugin-scope-auth/util' {\nimport type { Path, PothosFieldConfig, SchemaTypes } from '@pothos/core';\nimport type { AuthScopeMap } from '.';\nexport declare function canCache<Types extends SchemaTypes>(map: AuthScopeMap<Types>): boolean;\nexport declare function cacheKey(path: Path | undefined): string;\nexport declare function isObjectOrInterface(fieldConfig: PothosFieldConfig<never>): fieldConfig is {\n    description?: import(\"graphql/jsutils/Maybe\").Maybe<string>;\n    resolve?: import(\"graphql\").GraphQLFieldResolver<unknown, object, any, unknown> | undefined;\n    subscribe?: import(\"graphql\").GraphQLFieldResolver<unknown, object, any, unknown> | undefined;\n    deprecationReason?: import(\"graphql/jsutils/Maybe\").Maybe<string>;\n    extensions?: import(\"graphql/jsutils/Maybe\").Maybe<Readonly<import(\"graphql\").GraphQLFieldExtensions<unknown, object, any>>>;\n    astNode?: import(\"graphql/jsutils/Maybe\").Maybe<import(\"graphql\").FieldDefinitionNode>;\n    kind: \"Object\";\n    graphqlKind: \"Object\";\n    parentType: string;\n    name: string;\n    type: import(\"@pothos/core\").PothosOutputFieldType<never>;\n    args: Record<string, import(\"@pothos/core\").PothosInputFieldConfig<never>>;\n    argMappers: ((args: Record<string, unknown>, context: never, info: import(\"@pothos/core\").PartialResolveInfo) => import(\"@pothos/core\").MaybePromise<Record<string, unknown>>)[];\n    pothosOptions: never;\n} | {\n    description?: import(\"graphql/jsutils/Maybe\").Maybe<string>;\n    resolve?: import(\"graphql\").GraphQLFieldResolver<unknown, object, any, unknown> | undefined;\n    subscribe?: import(\"graphql\").GraphQLFieldResolver<unknown, object, any, unknown> | undefined;\n    deprecationReason?: import(\"graphql/jsutils/Maybe\").Maybe<string>;\n    extensions?: import(\"graphql/jsutils/Maybe\").Maybe<Readonly<import(\"graphql\").GraphQLFieldExtensions<unknown, object, any>>>;\n    astNode?: import(\"graphql/jsutils/Maybe\").Maybe<import(\"graphql\").FieldDefinitionNode>;\n    kind: \"Interface\";\n    graphqlKind: \"Interface\";\n    parentType: string;\n    name: string;\n    type: import(\"@pothos/core\").PothosOutputFieldType<never>;\n    args: Record<string, import(\"@pothos/core\").PothosInputFieldConfig<never>>;\n    argMappers: ((args: Record<string, unknown>, context: never, info: import(\"@pothos/core\").PartialResolveInfo) => import(\"@pothos/core\").MaybePromise<Record<string, unknown>>)[];\n    pothosOptions: never;\n};\n}"
    }
  ],
  "@pothos/plugin-errors": [
    {
      "moduleName": "@pothos/plugin-errors/field-builder",
      "content": "declare module '@pothos/plugin-errors/field-builder' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-errors/global-types",
      "content": "import type { FieldKind, FieldNullability, InputFieldMap, ObjectParam, SchemaTypes, ShapeFromListTypeParam, ShapeFromTypeParam, TypeParam } from '@pothos/core';\nimport type { PothosErrorsPlugin } from '.';\nimport type { ErrorFieldOptions, ErrorsPluginOptions, ErrorUnionFieldOptions, ErrorUnionListFieldOptions } from '@pothos/plugin-errors/types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface Plugins<Types extends SchemaTypes> {\n            errors: PothosErrorsPlugin<Types>;\n        }\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            errors?: ErrorsPluginOptions<Types>;\n        }\n        interface V3SchemaBuilderOptions<Types extends SchemaTypes> {\n            errors: never;\n            errorOptions?: ErrorsPluginOptions<Types>;\n        }\n        interface FieldOptions<Types extends SchemaTypes = SchemaTypes, ParentShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveShape = unknown, ResolveReturnShape = unknown> {\n            errors?: ErrorFieldOptions<Types, Type, ShapeFromTypeParam<Types, Type, false>, Nullable>;\n            itemErrors?: Type extends [infer Item extends TypeParam<Types>] ? ErrorFieldOptions<Types, Item, ShapeFromTypeParam<Types, Item, false>, false> : never;\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> {\n            errorUnionField: <Args extends InputFieldMap, Type extends ObjectParam<Types>, Nullable extends FieldNullability<Type> = Types['DefaultFieldNullability'], ResolveShape = unknown, ResolveReturnShape = unknown>(options: ErrorUnionFieldOptions<Types, ParentShape, Type, Nullable, Args, Kind, ResolveShape, ResolveReturnShape>) => FieldRef<Types, ShapeFromTypeParam<Types, Type, Nullable>, Kind>;\n            errorUnionListField: <Args extends InputFieldMap, Type extends ObjectParam<Types>, Nullable extends FieldNullability<[Type]> = Types['DefaultFieldNullability'], ResolveShape = unknown, ResolveReturnShape = unknown>(options: ErrorUnionListFieldOptions<Types, ParentShape, Type, Nullable, Args, Kind, ResolveShape, ResolveReturnShape>) => FieldRef<Types, ShapeFromListTypeParam<Types, [Type], Nullable>, Kind>;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-errors",
      "content": "declare module '@pothos/plugin-errors' {\nimport '@pothos/plugin-errors/global-types';\nimport '@pothos/plugin-errors/field-builder';\nimport { BasePlugin, type Normalize, type PothosOutputFieldConfig, type PothosOutputFieldType, type SchemaTypes, type TypeParam } from '@pothos/core';\nimport type { GraphQLFieldResolver, GraphQLIsTypeOfFn } from 'graphql';\nimport type { ErrorFieldOptions, GetTypeName } from '@pothos/plugin-errors/types';\nexport * from '@pothos/plugin-errors/types';\nexport * from '@pothos/plugin-errors/utils';\ndeclare const pluginName = \"errors\";\nexport default pluginName;\nexport declare class PothosErrorsPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n    wrapIsTypeOf(isTypeOf: GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined): GraphQLIsTypeOfFn<unknown, Types['Context']> | undefined;\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n    wrapResolve(resolver: GraphQLFieldResolver<unknown, Types['Context'], object>, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object>;\n    wrapSubscribe(subscribe: GraphQLFieldResolver<unknown, Types['Context'], object>, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    wrapArgMappers(resolver: GraphQLFieldResolver<unknown, Types['Context'], object> | undefined, fieldConfig: PothosOutputFieldConfig<Types>): GraphQLFieldResolver<unknown, Types['Context'], object> | undefined;\n    createResultType(parentTypeName: string, fieldName: string, type: TypeParam<Types>, fieldType: PothosOutputFieldType<Types>, errorOptions: ErrorFieldOptions<Types, TypeParam<Types>, unknown, false>, directResultError: string, defaultResultName: GetTypeName, defaultUnionName: GetTypeName, builderResultOptions?: Normalize<Omit<PothosSchemaTypes.ObjectTypeOptions<Types, {}>, 'interfaces' | 'isTypeOf'> & {\n        name?: GetTypeName;\n    }>, builderUnionOptions?: Normalize<Omit<PothosSchemaTypes.UnionTypeOptions<Types>, 'resolveType' | 'types'> & {\n        name?: GetTypeName;\n    }>): PothosSchemaTypes.UnionRef<Types, unknown, unknown>;\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-errors/types",
      "content": "declare module '@pothos/plugin-errors/types' {\nimport type { EmptyToOptional, FieldKind, FieldNullability, FieldOptionsFromKind, InferredFieldOptionKeys, InputFieldMap, InputShapeFromFields, Normalize, ObjectParam, Resolver, SchemaTypes, ShapeFromTypeParam, TypeParam } from '@pothos/core';\nexport type GetTypeName = (options: {\n    parentTypeName: string;\n    fieldName: string;\n}) => string;\nexport interface ErrorsPluginOptions<Types extends SchemaTypes> {\n    defaultTypes?: (new (...args: any[]) => unknown)[];\n    directResult?: boolean;\n    defaultUnionOptions?: Normalize<Omit<PothosSchemaTypes.UnionTypeOptions<Types>, 'resolveType' | 'types'> & {\n        name?: GetTypeName;\n    }>;\n    defaultResultOptions?: Normalize<Omit<PothosSchemaTypes.ObjectTypeOptions<Types, {}>, 'interfaces' | 'isTypeOf'> & {\n        name?: GetTypeName;\n    }>;\n    defaultItemResultOptions?: Normalize<Omit<PothosSchemaTypes.ObjectTypeOptions<Types, {}>, 'interfaces' | 'isTypeOf'> & {\n        name?: GetTypeName;\n    }>;\n    defaultItemUnionOptions?: Normalize<Omit<PothosSchemaTypes.UnionTypeOptions<Types>, 'resolveType' | 'types'> & {\n        name?: GetTypeName;\n    }>;\n    /**\n     * Callback for logging any errors which are handled by the errors plugin, this\n     * function will not be called for errors that are not handled by the errors plugin\n     **/\n    onResolvedError?: (error: Error) => void;\n    /**\n     * Errors thrown during custom argument validation or mapping will be processed like errors thrown in resolvers\n     * This will enables catching errors thrown by the validation plugin.\n     *\n     * This settings may have security implications because auth checks for a field will not be applied when handling input errors\n     */\n    unsafelyHandleInputErrors?: boolean;\n}\nexport type ErrorFieldOptions<Types extends SchemaTypes, Type extends TypeParam<Types>, Shape, Nullable extends FieldNullability<Type>> = EmptyToOptional<{\n    types?: (new (...args: any[]) => unknown)[];\n    directResult?: Type extends unknown[] ? false : boolean;\n    union: Normalize<Omit<PothosSchemaTypes.UnionTypeOptions<Types>, 'resolveType' | 'types'> & {\n        name?: string;\n    }>;\n    result: Normalize<Omit<PothosSchemaTypes.ObjectTypeOptions<Types, Shape>, 'interfaces' | 'isTypeOf'> & {\n        name?: string;\n    }>;\n    dataField: Normalize<Omit<PothosSchemaTypes.ObjectFieldOptions<Types, Shape, Type, Type extends [unknown] ? {\n        list: false;\n        items: Nullable extends {\n            items: boolean;\n        } ? Nullable['items'] : true;\n    } : false, {}, Shape>, 'args' | 'nullable' | 'type' | InferredFieldOptionKeys> & {\n        name?: string;\n    }>;\n}>;\nexport type ErrorUnionFieldOptions<Types extends SchemaTypes, ParentShape, Type extends ObjectParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, Kind extends FieldKind, ResolveShape, ResolveReturnShape> = Normalize<Omit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type' | 'resolve' | 'errors'> & {\n    types: Type[];\n    resolve?: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, Type, Nullable>>;\n    union?: Normalize<Omit<PothosSchemaTypes.UnionTypeOptions<Types, Type>, 'types'> & {\n        name?: string;\n    }>;\n}>;\nexport type ErrorUnionListFieldOptions<Types extends SchemaTypes, ParentShape, Type extends ObjectParam<Types>, Nullable extends FieldNullability<[Type]>, Args extends InputFieldMap, Kind extends FieldKind, ResolveShape, ResolveReturnShape> = Normalize<Omit<FieldOptionsFromKind<Types, ParentShape, [\n    Type\n], Nullable, Args, Kind, ResolveShape, ResolveReturnShape>, 'type' | 'resolve'> & {\n    types: Type[];\n    resolve?: Resolver<ParentShape, InputShapeFromFields<Args>, Types['Context'], ShapeFromTypeParam<Types, [Type], Nullable>>;\n    union?: Normalize<Omit<PothosSchemaTypes.UnionTypeOptions<Types, Type>, 'types'> & {\n        name?: string;\n    }>;\n}>;\n}"
    },
    {
      "moduleName": "@pothos/plugin-errors/utils",
      "content": "declare module '@pothos/plugin-errors/utils' {\nimport { typeBrandKey } from '@pothos/core';\nimport type { GetTypeName } from '@pothos/plugin-errors/types';\nexport { typeBrandKey };\nexport declare function extractAndSortErrorTypes<T>(types: T[]): (new (...args: never[]) => unknown)[];\nexport declare const unwrapError: unique symbol;\nexport declare const errorTypeMap: WeakMap<{}, new (...args: never[]) => unknown>;\nexport declare function capitalize(s: string): string;\nexport declare const defaultGetUnionName: GetTypeName;\nexport declare const defaultGetResultName: GetTypeName;\nexport declare const defaultGetListItemResultName: GetTypeName;\nexport declare const defaultGetListItemUnionName: GetTypeName;\nexport declare function createErrorProxy(target: {}, ref: unknown, state: {\n    wrapped: boolean;\n}): {};\nexport declare function wrapOrThrow(error: unknown, pothosErrors: (new (...args: never[]) => unknown)[], onResolvedError?: (error: Error) => void): {};\nexport declare function wrapErrorIfMatches(value: unknown, errorTypes: (new (...args: never[]) => unknown)[], onResolvedError?: (error: Error) => void): unknown;\nexport declare function yieldErrors(result: Iterable<unknown>, pothosErrors: (new (...args: never[]) => unknown)[], onResolvedError?: (error: Error) => void): Generator<unknown, void, unknown>;\nexport declare function yieldAsyncErrors(result: AsyncIterable<unknown>, pothosErrors: (new (...args: never[]) => unknown)[], onResolvedError?: (error: Error) => void): AsyncGenerator<unknown, void, unknown>;\n}"
    }
  ],
  "@pothos/plugin-validation": [
    {
      "moduleName": "@pothos/plugin-validation/errors",
      "content": "declare module '@pothos/plugin-validation/errors' {\nimport { PothosValidationError } from '@pothos/core';\nimport type { StandardSchemaV1 } from '@pothos/plugin-validation/standard-schema';\nexport declare class InputValidationError extends PothosValidationError {\n    issues: readonly StandardSchemaV1.Issue[];\n    constructor({ issues }: StandardSchemaV1.FailureResult);\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-validation/global-types",
      "content": "import type { FieldKind, FieldNullability, FieldRequiredness, InputFieldMap, InputFieldsFromShape, InputType, SchemaTypes, TypeParam } from '@pothos/core';\nimport type { PothosValidationPlugin } from '.';\nimport type { StandardSchemaV1 } from '@pothos/plugin-validation/standard-schema';\nimport type { ValidationPluginOptions } from '@pothos/plugin-validation/types';\ndeclare module 'graphql' {\n    interface GraphQLInputFieldExtensions {\n        '@pothos/plugin-validation'?: {\n            schemas?: StandardSchemaV1[];\n            parentSchemas?: StandardSchemaV1[];\n        };\n    }\n    interface GraphQLObjectTypeExtensions {\n        '@pothos/plugin-validation'?: {\n            schemas?: StandardSchemaV1[];\n        };\n    }\n    interface GraphQLInputObjectTypeExtensions {\n        '@pothos/plugin-validation'?: {\n            schemas?: StandardSchemaV1[];\n        };\n    }\n    interface GraphQLFieldExtensions<_TSource, _TContext, _TArgs = any> {\n        '@pothos/plugin-validation'?: {\n            schemas?: StandardSchemaV1[];\n        };\n    }\n}\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface Plugins<Types extends SchemaTypes> {\n            validation: PothosValidationPlugin<Types>;\n        }\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            validation?: ValidationPluginOptions<Types>;\n        }\n        interface FieldOptions<Types extends SchemaTypes, ParentShape, Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, Args extends InputFieldMap, ResolveShape, ResolveReturnShape> {\n            validate?: StandardSchemaV1;\n        }\n        interface InputObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Fields extends InputFieldMap = InputFieldMap> {\n            validate?: StandardSchemaV1;\n        }\n        interface InputFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            validate?: StandardSchemaV1;\n        }\n        interface InputObjectRef<Types extends SchemaTypes, T> {\n            validate<R>(schema: StandardSchemaV1<unknown, R>): InputObjectRef<Types, R>;\n        }\n        interface FieldRef<Types extends SchemaTypes, T = unknown, Kind extends FieldKind = FieldKind> {\n            validate<R>(schema: StandardSchemaV1<unknown, R>): FieldRef<Types, R, Kind>;\n        }\n        interface InputFieldRef<Types extends SchemaTypes, T> {\n            validate<R>(schema: StandardSchemaV1<unknown, R>): InputFieldRef<Types, R>;\n        }\n        interface ArgumentRef<Types extends SchemaTypes, T> {\n            validate<R>(schema: StandardSchemaV1<unknown, R>): ArgumentRef<Types, R>;\n        }\n        interface RootFieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> {\n            validate<Args extends InputFieldMap, R>(args: Args, schema: StandardSchemaV1<unknown, R>): InputFieldsFromShape<Types, R, 'Arg'>;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-validation",
      "content": "declare module '@pothos/plugin-validation' {\nimport '@pothos/plugin-validation/global-types';\nimport '@pothos/plugin-validation/methods';\nimport { BasePlugin, type PothosInputFieldConfig, type PothosOutputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core';\nimport { InputValidationError } from '@pothos/plugin-validation/errors';\nimport type { StandardSchemaV1 } from '@pothos/plugin-validation/standard-schema';\nexport * from '@pothos/plugin-validation/types';\nexport { InputValidationError, type StandardSchemaV1 };\ndeclare const pluginName = \"validation\";\nexport declare class PothosValidationPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n    onInputFieldConfig(fieldConfig: PothosInputFieldConfig<Types>): PothosInputFieldConfig<Types>;\n    onTypeConfig(typeConfig: PothosTypeConfig): PothosTypeConfig;\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types> | null;\n}\nexport default pluginName;\n}"
    },
    {
      "moduleName": "@pothos/plugin-validation/methods",
      "content": "declare module '@pothos/plugin-validation/methods' {\nexport {};\n}"
    },
    {
      "moduleName": "@pothos/plugin-validation/standard-schema",
      "content": "declare module '@pothos/plugin-validation/standard-schema' {\n/**\nCopied without modification from https://github.com/standard-schema/standard-schema\n\nMIT License\n\nCopyright (c) 2024 Colin McDonnell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n/** biome-ignore-all lint/style/useConsistentArrayType: use standard schema style */\n/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n    /** The Standard Schema properties. */\n    readonly '~standard': StandardSchemaV1.Props<Input, Output>;\n}\nexport declare namespace StandardSchemaV1 {\n    /** The Standard Schema properties interface. */\n    interface Props<Input = unknown, Output = Input> {\n        /** The version number of the standard. */\n        readonly version: 1;\n        /** The vendor name of the schema library. */\n        readonly vendor: string;\n        /** Validates unknown input values. */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /** Inferred types associated with the schema. */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    /** The result interface of the validate function. */\n    type Result<Output> = SuccessResult<Output> | FailureResult;\n    /** The result interface if validation succeeds. */\n    interface SuccessResult<Output> {\n        /** The typed output value. */\n        readonly value: Output;\n        /** The non-existent issues. */\n        readonly issues?: undefined;\n    }\n    /** The result interface if validation fails. */\n    interface FailureResult {\n        /** The issues of failed validation. */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /** The issue interface of the failure output. */\n    interface Issue {\n        /** The error message of the issue. */\n        readonly message: string;\n        /** The path of the issue, if any. */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /** The path segment interface of the issue. */\n    interface PathSegment {\n        /** The key representing a path segment. */\n        readonly key: PropertyKey;\n    }\n    /** The Standard Schema types interface. */\n    interface Types<Input = unknown, Output = Input> {\n        /** The input type of the schema. */\n        readonly input: Input;\n        /** The output type of the schema. */\n        readonly output: Output;\n    }\n    /** Infers the input type of a Standard Schema. */\n    type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema['~standard']['types']>['input'];\n    /** Infers the output type of a Standard Schema. */\n    type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema['~standard']['types']>['output'];\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-validation/types",
      "content": "declare module '@pothos/plugin-validation/types' {\nimport type { SchemaTypes } from '@pothos/core';\nimport type { StandardSchemaV1 } from '@pothos/plugin-validation/standard-schema';\nexport interface ValidationPluginOptions<Types extends SchemaTypes> {\n    validationError?: ValidationErrorFn<Types>;\n}\nexport type ValidationErrorFn<Types extends SchemaTypes> = (failure: StandardSchemaV1.FailureResult, args: Record<string, unknown>, context: Types['Context']) => Error | string;\n}"
    },
    {
      "moduleName": "@pothos/plugin-validation/utils",
      "content": "declare module '@pothos/plugin-validation/utils' {\nimport { type InputFieldMapping, type InputFieldsMapping, type MaybePromise, type PartialResolveInfo, type SchemaTypes } from '@pothos/core';\nimport type { StandardSchemaV1 } from '@pothos/plugin-validation/standard-schema';\nexport declare function createArgsValidator<Types extends SchemaTypes>(argMappings: InputFieldsMapping<Types, {\n    typeSchemas: StandardSchemaV1[];\n    fieldSchemas: StandardSchemaV1[];\n}> | null, argsSchemas: StandardSchemaV1[] | StandardSchemaV1 | null, options: {\n    validationError: (failure: StandardSchemaV1.FailureResult, args: Record<string, unknown>, context: Types['Context'], info: PartialResolveInfo) => Error;\n}): (args: Record<string, unknown>, context: Types[\"Context\"], info: PartialResolveInfo) => MaybePromise<Record<string, unknown>>;\nexport declare function createInputValueMapper<Types extends SchemaTypes, T, Args extends unknown[] = []>(argMap: InputFieldsMapping<Types, T>, mapType: (val: unknown, mapping: InputFieldMapping<Types, T>, addIssues: (issues: readonly StandardSchemaV1.Issue[]) => void, ...args: Args) => unknown, mapField: (val: unknown, mapping: InputFieldMapping<Types, T>, addIssues: (issues: readonly StandardSchemaV1.Issue[]) => void, ...args: Args) => unknown): (obj: object, map?: InputFieldsMapping<Types, T>, path?: (string | number)[], ...args: Args) => MaybePromise<StandardSchemaV1.Result<Record<string, unknown>>>;\nexport declare function reduceMaybeAsync<T, R>(items: T[], initialValue: R, fn: (value: R, item: T, i: number) => MaybePromise<R | null>): MaybePromise<R | null>;\n}"
    }
  ],
  "@pothos/plugin-directives": [
    {
      "moduleName": "@pothos/plugin-directives/global-types",
      "content": "import type { EnumValues, FieldNullability, FieldRequiredness, InputFieldMap, InputType, InterfaceParam, ObjectParam, RootName, SchemaTypes, TypeParam } from '@pothos/core';\nimport type { PothosDirectivesPlugin } from '.';\nimport type { DirectiveLocation, Directives } from '@pothos/plugin-directives/types';\ndeclare global {\n    export namespace PothosSchemaTypes {\n        interface Plugins<Types extends SchemaTypes> {\n            directives: PothosDirectivesPlugin<Types>;\n        }\n        interface UserSchemaTypes {\n            Directives: Record<string, {\n                locations: DirectiveLocation;\n                args?: Record<string, unknown>;\n            }>;\n        }\n        interface ExtendDefaultTypes<PartialTypes extends Partial<UserSchemaTypes>> {\n            Directives: PartialTypes['Directives'] & {};\n        }\n        interface SchemaBuilderOptions<Types extends SchemaTypes> {\n            directives?: {\n                useGraphQLToolsUnorderedDirectives?: boolean;\n            };\n        }\n        interface V3SchemaBuilderOptions<Types extends SchemaTypes> {\n            directives: never;\n            useGraphQLToolsUnorderedDirectives?: boolean;\n        }\n        interface EnumTypeOptions<Types extends SchemaTypes = SchemaTypes, Values extends EnumValues<Types> = EnumValues<Types>> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'ENUM'>;\n        }\n        interface ObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'OBJECT'>;\n        }\n        interface RootTypeOptions<Types extends SchemaTypes, Type extends RootName> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'OBJECT'>;\n        }\n        interface InputObjectTypeOptions<Types extends SchemaTypes = SchemaTypes, Fields extends InputFieldMap = InputFieldMap> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'INPUT_OBJECT'>;\n        }\n        interface InterfaceTypeOptions<Types extends SchemaTypes = SchemaTypes, Shape = unknown, Interfaces extends InterfaceParam<Types>[] = InterfaceParam<Types>[]> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'INTERFACE'>;\n        }\n        interface UnionTypeOptions<Types extends SchemaTypes = SchemaTypes, Member extends ObjectParam<Types> = ObjectParam<Types>> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'UNION'>;\n        }\n        interface ScalarTypeOptions<Types extends SchemaTypes = SchemaTypes, ScalarInputShape = unknown, ScalarOutputShape = unknown> extends BaseTypeOptions<Types> {\n            directives?: Directives<Types, 'SCALAR'>;\n        }\n        interface FieldOptions<Types extends SchemaTypes = SchemaTypes, ParentShape = unknown, Type extends TypeParam<Types> = TypeParam<Types>, Nullable extends FieldNullability<Type> = FieldNullability<Type>, Args extends InputFieldMap = InputFieldMap, ResolveShape = unknown, ResolveReturnShape = unknown> {\n            directives?: Directives<Types, 'FIELD_DEFINITION'>;\n        }\n        interface InputObjectFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            directives?: Directives<Types, 'INPUT_FIELD_DEFINITION'>;\n        }\n        interface ArgFieldOptions<Types extends SchemaTypes = SchemaTypes, Type extends InputType<Types> | [InputType<Types>] = InputType<Types> | [InputType<Types>], Req extends FieldRequiredness<Type> = FieldRequiredness<Type>> {\n            directives?: Directives<Types, 'ARGUMENT_DEFINITION'>;\n        }\n        interface EnumValueConfig<Types extends SchemaTypes = SchemaTypes> {\n            directives?: Directives<Types, 'ENUM_VALUE'>;\n        }\n        interface BuildSchemaOptions<Types extends SchemaTypes> {\n            schemaDirectives?: Directives<Types, 'SCHEMA'>;\n        }\n    }\n}"
    },
    {
      "moduleName": "@pothos/plugin-directives",
      "content": "declare module '@pothos/plugin-directives' {\nimport '@pothos/plugin-directives/global-types';\nimport { BasePlugin, type PothosEnumValueConfig, type PothosInputFieldConfig, type PothosOutputFieldConfig, type PothosTypeConfig, type SchemaTypes } from '@pothos/core';\nimport type { GraphQLSchema } from 'graphql';\nimport type { DirectiveList } from '@pothos/plugin-directives/types';\nexport * from '@pothos/plugin-directives/types';\ndeclare const pluginName = \"directives\";\nexport default pluginName;\nexport declare class PothosDirectivesPlugin<Types extends SchemaTypes> extends BasePlugin<Types> {\n    onOutputFieldConfig(fieldConfig: PothosOutputFieldConfig<Types>): PothosOutputFieldConfig<Types>;\n    onInputFieldConfig(fieldConfig: PothosInputFieldConfig<Types>): PothosInputFieldConfig<Types>;\n    onEnumValueConfig(valueConfig: PothosEnumValueConfig<Types>): PothosEnumValueConfig<Types>;\n    onTypeConfig(typeConfig: PothosTypeConfig): PothosTypeConfig;\n    afterBuild(schema: GraphQLSchema): GraphQLSchema;\n    mergeDirectives(left: DirectiveList | Record<string, object>, right: DirectiveList | Record<string, object>): DirectiveList | Record<string, object>;\n    normalizeDirectives(directives: DirectiveList | Record<string, object>): DirectiveList | Record<string, object>;\n}\n}"
    },
    {
      "moduleName": "@pothos/plugin-directives/mock-ast",
      "content": "declare module '@pothos/plugin-directives/mock-ast' {\nimport '@pothos/plugin-directives/global-types';\nimport { type GraphQLSchema } from 'graphql';\nexport default function mockAst(schema: GraphQLSchema): void;\n}"
    },
    {
      "moduleName": "@pothos/plugin-directives/types",
      "content": "declare module '@pothos/plugin-directives/types' {\nimport type { SchemaTypes } from '@pothos/core';\nexport type DirectiveLocation = 'ARGUMENT_DEFINITION' | 'ENUM_VALUE' | 'ENUM' | 'FIELD_DEFINITION' | 'INPUT_FIELD_DEFINITION' | 'INPUT_OBJECT' | 'INTERFACE' | 'OBJECT' | 'SCALAR' | 'SCHEMA' | 'UNION';\nexport type DirectiveList = {\n    name: string;\n    args?: object;\n}[];\nexport type DirectivesFor<Types extends SchemaTypes, Location extends DirectiveLocation> = {\n    [K in keyof Types['Directives']]: Location extends Types['Directives'][K]['locations'] ? K : never;\n}[keyof Types['Directives']];\nexport type Directives<Types extends SchemaTypes, Location extends DirectiveLocation> = {\n    [K in keyof Types['Directives']]: Types['Directives'][K]['locations'] extends Location ? {\n        name: K;\n        args: Types['Directives'][K]['args'];\n    } : never;\n}[keyof Types['Directives']][] | {\n    [K in DirectivesFor<Types, Location>]?: Types['Directives'][K]['args'] & {};\n};\n}"
    }
  ]
};

export function getCoreTypeDefinitions(): TypeDefinition[] {
  return coreTypeDefinitions;
}

export function getPluginTypeDefinitions(pluginName: string): TypeDefinition[] {
  return pluginTypeDefinitions[pluginName] || [];
}

export function getAllPluginNames(): string[] {
  return Object.keys(pluginTypeDefinitions);
}
